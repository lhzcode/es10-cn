{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 Ecma标准定义了2019年ECMAScript语言。这是第十版的ECMAScript语言规范。自1997年出版的第一版，ECMAScript已经是世界上最广泛使用的通用编程语言。它是众所周知的嵌入在Web浏览器中的语言，但也已广泛用于服务器和嵌入式应用程序 本Ecma标准建立在几项开创性技术上，其中最为著名的是JavaScript（网景）和JScript （微软）。JavaScript语言由网景的Brendan Eich发明而第一次出现在该公司的Navigator 2.0浏览器中。此后该语言出现在网景公司后续所有浏览器中，同时出现在微软公司自Internet Explorer 3.0始的所有浏览器中。 本标准的开发始于1996年11月，第一版在1997年6月被Ecma General Assembly采纳。 这项标准随后提交至ISO/IEC JTC 1，并在1998年4月被接纳为国际标准ISO/IEC 16262，其推进过程是相当快的。1998年6月Ecma General Assembly通过了ECMA-262第二版以保持其与ISO/IEC 16262的完全一致性。实际上，第一版到第二版的变更仅仅是编辑性的。 第三版标准引入了强大的正则表达式、更佳的字符串处理、新的控制语句、try/catch异常处理、更严密地错误定义、格式化的数字输出以及一些为国际化和未来语言成长预留的小变更。1999年12月ECMAScript标准第三版被Ecma General Assembly采纳，并于2002年6月作为ISO/IEC 16262:2002发布。 自第三版发布以来，ECMAScript因其与万维网的关联而获得了广泛应用，它实质上已经成为所有web浏览器都提供的一种编程语言。为编制第四版ECMAScript，人们做了大量的工作。尽管这些工作没能完成，也没有发布第四版标准，但其中部分促进了第六版的发展。 ECMAScript第五版（发布为ECMA-262 5th edition）编入了很多事实上已经在浏览器实现中形成共识的语言规范解析，并且增加了对自第三版发布以来出现的新功能的支持。这些新功能包括访问器属性、反射创建和对象检测、属性特性的程序控制、新增数组操作函数、JSON对象编码格式、以及提供了改进的错误检查和程序安全性的严格模式。第五版在2009年12月的Ecma大会上被采用。 第五版被提交给ISO/IEC JTC 1，并且在2011年的 ISO/IEC 16262:2011 上被作为国际标准被通过。ECMAScript标准的5.1版进行了一些小的修正，并与ISO/IEC 16262:2011保持一致。第5.1版在2011年6月底Ecma大会上被采纳。 备受关注的第6版的开发于2009年开始，当时第5版正准备发布。然而，一些重大的实验和那些可以追溯到1999年第3版的发布时的语言增强方面的设计工作却使得第6版领先于第5版。 从真正意义上来讲，第6版的完成将这15年来的努力推向了顶峰。增加这些东西的初衷和目标有很多，包括对大型应用提供更好的支持，库的创建，还有将ECMAScript作为其他语言的编译结果的用法。同时，也包括一些重大的增强，如模块系统，类（class）声明，词法块级作用域，迭代器（iterator）和生成器（generator），为异步编程而生的promise，解构，以及适当的尾部调用。ECMAScript中内置的库得以扩充，目的是提供更多的数据抽象功能。如，map，set，数组二进制操作（TypedArray），字符串填充，正则表达式改进。内置库同样也通过子类来扩充。第6版是增量式的语言和库增强，于2015年6月在大会上被采纳。 ECMAScript 2016 规范是Ecam TC39的第一个发布版，新的发布策略将会每年发布一次新版本，并且公布进展过程。纯文本的源文档从ECMAScript 2015源文档开始时在Github上建立，目的是为更进一步的发展提供一个基础。 在标准发展的这些年，提交了数以百计的pr和issue，它们为我们修复了很多bug，编辑错误以及其他方面的提升。除此之外，众多的软件工具被创造，帮助了我们。如Ecmarkup, Ecmarkdown, 以及Grammarkdown。规范同时也提供了对新的求幂运算符（**）的以及数组的includes方法的支持。 ECMAScript 2017 介绍了异步（Async）函数、共享内存、原子（Atomics）以及较小的语言和库的功能增强、错误修复和编辑上的更新。异步函数通过promise返回函数语法，改善了异步编程体验。共享内存和原子技术引入了一种新的内存模型，该模型允许多主体程序使用原子操作进行通信，以确保即使在并行CPU。该规范还包括有关Object的新静态方法：Object.values，Object.entries，和Object.getOwnPropertyDescriptors。 ECMAScript 2018 介绍了由异步迭代协议和异步生成器提供的异步迭代支持。它还包括四个新的正则表达式功能：dotAll标志，命名捕获组，Unicode属性转义和后置断言。最后，它包括rest参数和对对象属性的扩展运算符支持。 该规范（第10版）引入了一些新的内置函数：Array.prototype上用于扁平化数组的flat和flatMap，用于将Object.entries的返回值直接转换为新的Object的Object.fromEntries，以及广泛实施但非标准的String.prototype.trimLeft和trimRight内置函数的更好的替代方案，即String.prototype中的trimStart和trimEnd。另外，该规范包括对语法和语义的一些次要更新。更新的语法包括可选的catch绑定参数，并允许字符串文字中的U+2028（行分隔符）和U+2029（参数分隔符）与JSON对齐。其他更新包括：Array.prototype.sort稳定排序；JSON.stringify返回格式正确的UTF-8（无论输入如何）；以及Function.prototype.toString返回相应的原始源文本或标准占位符。 代表不同组织的众多个人也为Ecma TC39现在及之前的发展做出来很多显著的贡献。除此之外，也出现了一个支持TC39并为ECMAScript努力的充满活力的社区。这个社区review了大量的草案，报告了大量的bug，并对实现进行了实验，贡献了测试相关的工具，使全世界的ECMAScript的开发者从中受益。原谅我们，无法对这些做出努力的贡献者们一一感谢。 Allen Wirfs-Brock ECMA-262, Project Editor, 6th Edition Brian Terlson ECMA-262, Project Editor, 7th through 10th Editions Ecma标准定义了2019年ECMAScript语言。这是第十版的ECMAScript语言规范。自1997年出版的第一版，ECMAScript已经是世界上最广泛使用的通用编程语言。它是众所周知的嵌入在Web浏览器中的语言，但也已广泛用于服务器和嵌入式应用程序 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,Ecma介绍,introduction"},"scope.html":{"url":"scope.html","title":"1 范围","keywords":"","body":"1 范围 本规范定义了ECMAScript 2019通用程序语言。 本规范定义了ECMAScript 2019通用程序语言。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,es范围,scope"},"conformance.html":{"url":"conformance.html","title":"2 一致性","keywords":"","body":"2 一致性 符合标准的ECMAScript实现，必须提供并支持本规范描述的所有类型、值、对象、属性、函数、程序语法和语义。 符合标准的ECMAScript实现，必须按照最新版本的Unicode标准和 ISO / IEC 10646 解释源文本输入。 符合标准的ECMAScript实现，提供应用程序编程接口（API）。这些接口需要支持不同自然语言和国家的人们的语言和文化传统。同时必须实现在ECMA-402最新版中定义的与本规范兼容的接口。 符合标准的ECMAScript实现，允许提供超出本规范描述的额外的类型、值、对象、属性和函数； 尤其是对本规范描述的对象，允许提供本规范未描述的属性和属性值。 符合标准的ECMAScript实现，允许支持本规范未描述的程序语法和正则表达式语法；尤其是对本规范11.6.2.2节列出的“未来保留字”，允许将其作为程序语法。 符合标准的ECMAScript实现，绝对不能实现任何在16.2节中列出的禁止的扩展。 符合标准的ECMAScript实现，必须提供并支持本规范描述的所有类型、值、对象、属性、函数、程序语法和语义。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,一致性,conformance "},"normative-references.html":{"url":"normative-references.html","title":"3 规范性引用","keywords":"","body":"3 规范性引用 下面的文档链接对于本规范的应用程序是必不可少的。对于标注了日期的引用，代表只适用于标注的那个版本。对于没有标注日期的引用，则适用于最新的版本（包括修正案）。 ISO/IEC 10646：信息技术 - 通用多八位（Multiple-Octet）编码字符集，以及2005修正案1，2006修正案2，2008修正案3，2008修正案4，以及额外的修正案，勘误，后续标准。 ECMA-402，ECMAScript 2015国际化API规范 http://www.ecma-international.org/publications/standards/Ecma-402.htm ECMA-404，JSON数据交换格式 http://www.ecma-international.org/publications/standards/Ecma-404.htm 下面的文档链接对于本规范的应用程序是必不可少的。对于标注了日期的引用，代表只适用于标注的那个版本。对于没有标注日期的引用，则适用于最新的版本（包括修正案）。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,规范性引用,normative-references"},"overview.html":{"url":"overview.html","title":"4 概述","keywords":"","body":"4 概述 本节包含对ECMAScript语言非规范性的概述。 ECMAScript是一种在宿主环境中执行计算并处理计算对象的面向对象编程语言。这里的ECMAScript 并不是计算性自完备的；事实上，本规范并没有规定外部数据输入和计算结果输出。相反，我们期望ECMAScript程序的计算环境不仅提供本规范中描述的对象和其他设施，还能提供某些特定环境下的宿主对象；除非为了说明宿主对象可能提供某些属性和方法以供ECMAScript程序访问，这些宿主对象描述和行为都超出了本规范的范围。 ECMAScript最初被设计用来作为一门脚本语言，但是现在已经被广泛地作为一门通用语言使用。 脚本语言是一种用于操作、自定义、自动化现有系统设施的编程语言。在这种系统中，用户已经可以通过一个用户界面使用可用功能，脚本语言正是暴露这些有用功能给程序控制的一种机制。这样，现有系统可以说是提供了对象和设施的一种宿主环境，以完善脚本语言能力。因此，设计脚本语言时，就考虑到了可被专业和非专业程序员都能使用。 ECMAScript最初被设计为Web脚本语言，提供一种机制，使浏览器中的网页更加活跃，使基于Web的客户端/服务器架构能够执行服务器计算。ECMAScript 可以为各种宿主环境提供核心的脚本功能，因此本文档为不依赖特定宿主环境的核心脚本语言作出规范。 ECMAScript的用法已经远远超过了普通的脚本语言，现在它被用作许多不同环境下的编程任务的各个方面。随着ECMAScript用法的扩充，它也拥有越来越多的特性。现在，ECMAScript已经是一门功能完备的通用语言。 ECMAScript的一些机能和其他编程语言的类似；特别是下列文献所描述的Java™、Self和Scheme： ISO/IEC 9899:1996, Programming Languages – C. Gosling, James, Bill Joy and Guy Steele. The Java™ Language Specification. Addison Wesley Publishing Co., 1996. Ungar, David, and Smith, Randall B. Self: The Power of Simplicity. OOPSLA '87 Conference Proceedings, pp. 227-241, Orlando, FL, October 1987. IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990. 4.1 Web 脚本 WEB 浏览器为了增加客户端的计算能力而引入 ECMAScript 宿主环境，例如，它提供的对象有：windows，menus，pop-ups，dialog boxes，text areas，anchors，frames，history，cookies 及输入 / 输出等等。进一步来说，WEB 浏览器中提供的这种宿主环境可以让脚本代码处理诸如改变焦点、页面和图片的加载、卸载、错误和放弃，选择，表单提交和鼠标交互等等事件。脚本代码出现在 HTML 中，显示出来的页面则是一个由用户接口元素、已确定计算出来的文本以及图片的集合。脚本代码根据用户的交互而做出反应，并不需要存在一个主程序。 WEB 服务器为了服务端的计算提供了完全不一样的宿主环境，包括的对象有：requrests，clients，files 以及数据锁定和分享机制。通过浏览器端脚本及服务端脚本的配合使用，在为基于 WEB 方式的应用程序提供可定制的用户接口的同时时，也将计算分布到客户端和服务端进行。 每一种支持 ECMAScript 的 WEB 浏览器和服务器都将它们自身的宿主环境作为 ECMAScript 的补充，以使得 ECMAScript 的执行环境变得完整。 4.2 ECMAScript 概览 下面是非正式的 ECMAScript 概述 —— 并未描述语言的所有部分。此概述并非标准的一部分。 ECMAScript 是基于对象的：基本语言和宿主设施都由对象提供，ECMAScript 程序是一组可通信的对象。ECMAScript 对象是属性的集合，每个属性有零个或多个特性，以及属性的使用方式。例如，当设置一个属性的Writable特性为 false 时，任何试图更改此属性值的 ECMAScript 代码的都会执行失败。属性是一个容器，它可以存放其他 对象、原始值、函数。原始值是以下内置类型之一的成员：Undefined、Null、Boolean、Number、String；对象是剩下的内置类型Object的成员；函数是可调用的对象。方法是通过属性与对象关联的函数。 ECMAScript 定义了一组内置对象，完善了 ECMAScript 实体的定义。这些内置对象包括全局对象；语言运行时语义基础的对象，包括 Object, Function, Boolean, Symbol和各种Error对象；代表和操纵数值的对象，包括Math, Number和Date；文本处理对象String和RegExp；索引集合值的对象，包括数组和九种不同类型的类型化数组，它们的元素都具有特定的数值数据表示形式；键控集合，包括Map和Set对象； 支持结构化数据的对象，包括JSON对象，ArrayBuffer，SharedArrayBuffer和DataView；支持控件抽象的对象，包括生成器函数和Promise对象； 反射对象，包括Proxy和Reflect。 ECMAScript 中还定义一组内置运算符。ECMAScript 运算符包括 一元运算符、乘法运算符、加法运算符、位移运算符、关系运算符、等值运算符、二元按位运算符、二元逻辑运算符、赋值运算符、逗号运算符。 大型ECMAScript程序需要模块支持，这些模块允许将程序分为多个语句和声明的序列。 每个模块显式地识别它用到的由其它模块提供的声明，同时它自己内部的声明也能被其他模块所用。 ECMAScript 语法有意设计成与 Java 语法类似。ECMAScript 的语法是松散的，使其能够作为一个易于使用的脚本语言。例如，一个变量不需要有类型声明，属性也不需要与类型关联，定义的函数也不需要声明在函数调用语句的前面。 4.2.1 Objects ECMAScript 不使用诸如 C++、Smalltalk、Java 中的类。相反，对象可以通过各种方式创建，包括字面量符号、构造器 创建对象然后运行代码初始化其全部或部分属性值，并为这些属性分配初始值。每个构造器是一个拥有名为“prototype”属性的函数。此属性用于实现 原型继承 和 属性共享。构造器通过 new 表达式创建对象：例如，new Date(2009,11) 创建一个新 Date 对象。不使用 new 调用一个构造器的结果，依赖构造器本身。例如，Date() 产生一个表示当前日期时间的字符串，而不是一个对象。 每个由构造器创建的对象都有一个隐式引用（叫做对象的原型）链接到构造器的“prototype”属性值。再者，原型可能有一个非空隐式引用链接到它自己的原型，以此类推，这叫做 原型链。当一个引用被连接到对象的属性上时，引用会指向原型链中包含此属性名的第一个对象对应的属性。换句话说，首先检查对象直接的同名属性，如果对象包含同名的属性，引用即指向此属性，如果该对象不包含同名的属性，则下一步检查对象的原型，以此类推。 通常在基于类的面向对象语言中，实例拥有状态，类拥有方法，并且只能继承结构和行为。在 ECMAScript 中，对象拥有状态和方法，并且结构，行为，状态全都可继承。 所有不直接包含原型中包含的特定属性的对象会共享此属性及属性值。图1 说明了这一点： CF 是一个构造器（也是一个对象）。五个对象已用 new 表达式创建 : cf1、cf2、cf3、cf4、cf5。每个对象都有名为 q1 和 q2 的属性。虚线表示隐式原型关系；例如：cf3 的原型是 CFp。构造器 CF 自己有名为 P1 和 P2 的两个属性，这对 CFp、cf1、cf2、cf3、cf4、cf5 是不可见的。CFp 中名为 CFP1 的属性和任何在 CFp 的隐式原型链中能找到且不名为 q1、q2、CFP1 的属性都被 cf1、cf2、cf3、cf4、cf5 所共享（但不被 CF 共享）。请注意 CF 和 CFp 之间没有隐式原型链接。 不同于基于类的对象语言，属性可以通过赋值的方式动态添加给对象。也就是说，构造器并不是非要对构造的对象的全部或任何属性命名或赋值。上图中，可以给 CFp 添加新属性值的方式为 cf1、cf2、cf3、cf4、cf5 添加一个新的共享属性。 尽管ECMAScript对象并不是天生就基于类的，但通常可以根据构造函数，原型对象和方法的通用模式来定义“模拟类”抽象。ECMAScript内置对象本身遵循这样的“模拟类”模式。从ECMAScript 2015开始，ECMAScript语言包含了类定义语法，允许程序员简洁的定义符合\"模拟类\"抽象模式的对象，内置对象也采取了这种方式来定义。 4.2.2 ECMAScript严格变体 ECMAScript 语言认为存在部分希望限制语言中某些功能的用户。他们这样做可能是为了安全考虑，规避那些他们认为容易出错的功能，从而获得更强的错误检查，或者其他原因。为了支持这种可能的情况，ECMAScript 定义了语言的严格变体。语言的严格变体，排除了 ECMAScript 语言中某些特定的句法和语义特征，还修改了某些功能的详细语义。严格变体还指定了额外一些必须抛出错误异常报告的错误条件，而在非严格的语言模式下这些条件不属于错误。 ECMAScript 的严格变体通常被称为语言的 严格模式。严格模式选择使用 ECMAScript 严格模式的语法和语义，明确地适用于个别 ECMAScript 代码单元级别。由于严格模式适用于选择的语法代码单元级别，严格模式只会在这个代码单元内施加带有局部效果的限制。严格模式不在语义层面限制或修改任何必须在多个代码单元运行的 ECMAScript 代码。一个 ECMAScript 程序可由严格模式和非严格模式的代码单元组成。在这种情况下，严格的模式只适用于严格模式代码单元内实际执行的代码。 为了符合本规范，ECMAScript的实现必须实现两套，非严格模式ECMAScript语言和ECMAScript语言严格模式变体，作为这份规范的定义。此外，实现必须支持非严格模式和严格模式代码单元组合成一个单独的复合程序。 4.3 术语定义 本文档将使用下列术语和定义。 4.3.1 类型 本规范 第6章 定义数据的集合。 4.3.2 原始值 在本规范的 第6章 定义的 Undefined、Null、Boolean、Number、String 类型之一的成员 注： 原始值可以直接表示语言实现的最底层数据。 4.3.3 对象 对象类型的成员。 注： 对象是属性的集合，并有一个原型对象。原型可以是空值。 4.3.4 构造器 创建和初始化对象的函数对象。 注： 构造器的“prototype”属性值是一个原型对象，它用来实现继承和共享属性。 4.3.5 原型 为其他对象提供共享属性的对象。 注： 当构造器创建一个对象时，为了解决对象的属性引用，该对象会隐式引用构造器的“prototype”属性。通过程序表达式 constructor.prototype 可以引用到构造器的“prototype”属性。并且，添加到对象原型里的属性会通过继承的方式与所有共享此原型的对象共享。另外，可使用 Object.create 内置函数，通过明确指定原型来创建一个新对象。 4.3.6 普通对象 具有所有对象支持的基本内部方法的对象 4.3.7 异类对象 没有一个或多个基本内部默认方法的对象 注：任何对象不是普通对象就是异类对象 4.3.8 标准对象 其语义由本规范定义的对象 4.3.9 内置对象 由ECMAScript的实现指定和提供的对象。 注：标准的内置对象被定义在本规范中。一个ECMAScript实现也许会指定和提供额外的某些内置对象。一个内置构造函数是一个内置对象，同时也是一个构造函数。 4.3.10 undfined 值 说明一个变量没有被分配值的一个原始值。 4.3.11 Undefined 类型 undefined 值是 Undefined 类型绝无仅有的一个值。 4.3.12 null 值 代表对象值故意留空的一个原始值。 4.3.13 Null 类型 null 值是 Null 类型绝无仅有的一个值。 4.3.14 Boolean 值 Boolean 类型的成员。 注： 只有两个 Boolean 值，true 和 false 。 4.3.15 Boolean 类型 由原始值 true 和 false 组成的类型。 4.3.16 Boolean 对象 Object 类型的成员，它是标准内置构造器 Boolean 的实例。 注： 通过使用 new 表达式，以一个 Boolean 值作为参数调用 Boolean 构造器来创建 Boolean 对象。由此产生的对象包含一个值为此 Boolean 值的内部属性。Boolean 对象可以强制转换为 Boolean 值。 4.3.17 String 值 原始值，它是零个或多个16位无符号整数组成的有限有序序列。 注： String 值是 String 类型的成员。通常序列中的每个整数值代表 UTF-16 文本的单个16位单元。然而，对于其值，ECMAScript 只要求必须是16位无符号整数，除此之外没有任何限制或要求。 4.3.18 String 类型 所有可能的 String 值的集合。 4.3.19 String 对象 Object类型的成员，它是标准的内置String构造函数的实例。 注：通过使用 new 表达式，以一个 String 值作为参数调用 String 构造器来创建 String 对象。由此产生的对象包含一个值为此 String 值的内部属性。String 对象可以强制转换为 String 值（21.1.1.1）。 4.3.20 Number 值 原始值，对应一个64位双精度二进制 IEEE 754-2008 值。 注： Number 值是 Number 类型的成员，是一个数字的明确表示法。 4.3.21 Number 类型 所有可能的数字值的集合，包括特殊的“Not-a-Number”(NaN) 值、正无穷、负无穷。 4.3.22 Number 对象 对象类型的成员，它是标准内置构造器 Number 的一个实例。 注： 通过使用 new 表达式，以一个数字值为参数调用 Number 构造器来创建数字对象。由此产生的对象包含一个值为此数字值的内部属性。将 Number 构造器作为一个函数来调用，可将一个 Number 对象强制转换为一个数字值（20.1.1.1）。 4.3.23 Infinity 正无穷 Number 值。 4.3.24 NaN 值为 IEEE 754-2008 “Not-a-Number”的 Number 值。 4.3.25 Symbol 值 原始值，代表一个唯一的，非字符串对象的属性的键（key）。 4.3.26 Symbol 类型 所有可能的Symbol值的集合。 4.3.27 Symbol 对象 对象类型的成员，是标准的内置Symbol构造函数的实例 4.3.28 函数 Object 类型的成员，标准内置构造器 Function 的一个实例，并且可作为子程序被调用。 注： 函数除了拥有命名的属性，还包含可执行代码、状态，用来确定被调用时的行为。函数的代码不限于 ECMAScript。 4.3.29 内置函数 属于函数的内置对象。 注： 如 parseInt 和 Math.exp 就是内置函数。一个实现可以提供本规范没有描述的依赖于实现的内置函数。 4.3.30 属性 是对象的一部分，关联键（要么是一个字符串，要么是一个Symbol值）和值 注： 根据属性形式的不同，其值可以直接表现为一个数据值（原始值、对象、函数对象）或间接地通过一对访问器函数来表现。 4.3.31 方法 作为属性值的函数。 注： 当一个函数被作为一个对象的方法调用时，此对象将作为 this 值传递给函数。 4.3.32 内置方法 属于内置函数的方法。 注： 标准内置方法由本规范定义，一个 ECMAScript 实现可指定，提供其他额外的内置方法。 4.3.33 特性 用于定义属性的一些特征的内部值。 4.3.34 自身属性 对象直接拥有的属性。 4.3.35 继承属性 不是对象的自身属性，但是对象原型的属性（可以是自身或继承的）。 4.4 本规范的章节组织 本规范剩余部分的组织如下: 第5章定义了在本规范中使用的一些符号或者语法的约定。 第6-9章定义了ECMAScript程序操作包含的执行环境。 第10-16章定义了实际的ECMAScript语言，包括它的语法编码以及语言特性的执行语义。 第17-26章定义了ECMAScript标准库。它们包括所有当ECMAScript程序执行时可用的标准对象的定义。 第27章描述了对SharedArrayBuffer支持的内存的访问的内存一致性模型以及Atomics对象的方法。 ECMAScript是一种在宿主环境中执行计算并处理计算对象的面向对象编程语言。这里的ECMAScript 并不是计算性自完备的；事实上，本规范并没有规定外部数据输入和计算结果输出。相反，我们期望ECMAScript程序的计算环境不仅提供本规范中描述的对象和其他设施，还能提供某些特定环境下的宿主对象；除非为了说明宿主对象可能提供某些属性和方法以供ECMAScript程序访问，这些宿主对象描述和行为都超出了本规范的范围。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,ES概述,overview"},"notationalConventions.html":{"url":"notationalConventions.html","title":"5 记法约定","keywords":"","body":"5 记法约定 5.1 句法和文法 5.1.1 上下文无关文法 一个上下文无关文法由一定数量的产生式组成。每个产生式的左边部分是一个被称为非终结符的抽象符号，右边部分是零或多个非终结符和终结符的有序排列。任何文法，它的终结符都来自指定的字母集。 一个链产生式只含有一个非终结符以及零个或多个终结符作为它的右值。 当从一个叫做目标符的特殊非终结符组成的句子起始，那么给出的上下文无关文法就表示语言，即：将产生式右边序列的非终结符当作左边，进行反复替换的结果就成为可能的终结符序列集合（可能无限）。 5.1.2 词法和正则的文法 第11章给出了 ECMAScript 的词法。此文法的终结符字符（Unicode 代码单元）符合第10.1章定义的 SourceCharacter 的规则。它定义了一套产生式，从目标符 InputElementDiv 或 InputElementRegExp 起始，描述了如何将这样的字符序列转换成一个输入元素序列。 空白字符和注释之外的输入元素构成 ECMAScript 句法的终结符，它们被称为 ECMAScript 的 Token。这些 Token 是，ECMAScript 语言的保留字、标识符、字面量、标点符号。此外，行终止符虽然不被视为 Token，但会成为输入元素流的一部分，用于引导处理 自动插入分号（11.9）。空白字符和单行注释会被简单地丢弃，不会出现在句法的输入元素流中。如果一个多行注释（即形式为“/.../”的注释，不管是否跨越多行）不包含行终止符也会简单地丢弃，但如果一个多行注释包含一个或多个行终止符，那么，注释会被替换为一个行终止符，成为句法的输入元素流的一部分。 第21.2.1章 给出了 ECMAScript 的 正则文法。此文法的终结符也由 SourceCharacter 定义。它定义了一套产生式，从目标符 Pattern 起始，描述了如何将这样的字符序列翻译成一个正则表达式模式。 两个冒号“::”作为分隔符分割词法和正则的文法产生式。词法和正则的文法共享某些产生式。 5.1.3 数字字符串文法 用于将字符串转换为数字值的另一种文法。此文法与词法的一部分类似，都与数字字面量有关，并且它有作为终结符的SourceCharacter。此文法出现在 7.1.3.1。 三个冒号“:::”作为分隔符分割数字字符串文法的产生式。 5.1.4 句法 第 11、12、13、14和15 章给出了 ECMAScript 的句法。词法定义的 ECMAScript Token 是此文法的终结符（5.1.2）。它定义了一组起始于 两个可选的目标符 Script 以及 Module 的产生式，描述了怎样的 Token 序列才能形成句法上正确的 ECMAScript 程序。 当一个字符流被解析为 ECMAScript 的脚本或者模块时，它首先通过词法应用程序反复转换为一个输入元素流；然后再用一个句法应用程序解析这个输入元素流。当输入元素流没有更多 Token 时，如果 Token 不能解析为 目标非终结符（脚本或者模块）的单一实例，那么程序在句法上存在错误。 当一个解析成功的时候，它会构造一颗解析树，这颗有根的树每个节点都是一个解析节点。每个解析节点是一个文法中的符号的实例。它代表了一段从这样的符号中派生出来的源代码文本。解析树的根节点代表着整个的源代码文本，是一个解析的目标符号的实例。当一个解析节点是一个非终结符的实例的时候，它也是一个某些将这个非终结符作为左值的产生式的实例。此外，它有零个或多个子节点，产生式右值中的每个符号：每个子节点都是一个是相应符号的实例的解析节点。 每次解析器调用都会实例化新的解析节点，并且即使在相同的源文本的解析之间也不会重用。当且仅当它们代表源文本的相同范围，是相同语法符号的实例且是由相同的解析器调用产生的，解析节点才被视为相同的解析节点。 注意 1：多次分析同一个String会导致不同的解析节点，例如： eval(str); eval(str); 注意 2：解析节点是规范产物，使用类似的数据结构不需要实现。 只用一个冒号“:”作为分隔符分割句法的产生式。 事实上第 11、12、13、14和15章给出的句法，并不能完全说明一个正确的 ECMAScript 脚本或模块能接受的 Token 序列。一些额外的 Token 序列也被接受，即某些特殊位置（如行结束符前）加入分号可以被文法接受。此外，文法描述的某些 Token 序列不被文法接受，如一个行结束符出现在了“尴尬”的位置。 在某些案例中，为了避免歧义，句法使用广义的产生式，允许token序列不形成一个合法的ECMAScript 脚本或者模块。例如，这项技术被用作对象字面量和对象解构模式中。在这样的场景中，更多的限制性的补充的文法被提供，进一步限制了可接受的token序列。通常，如果“ P未覆盖N”，则早期错误规则将定义错误条件，其中P是解析节点（广义生成的实例），而N是补充语法的非终结符。在此，使用N作为目标符号再次解析最初与P匹配的token序列（如果N使用语法参数，则将它们设置为最初解析P时所使用的值）。如果无法将标记序列解析为N的单个实例且没有标记残留，则会发生错误。随后，算法使用形式为“ P覆盖的N”的短语访问解析结果。这将始终是一个解析节点（N的实例，对于给定的P唯一），因为任何解析失败都会被早期的错误规则检测到。 5.1.5 文法标记法 词法、正则表达式文法、字符串数字文法，以及一些其它文法，每当这些文法的终结符被文本直接涉及到时，使用等宽字符来显示，它们都在文法产生式中，并且贯穿这份文档。他们表示程序书写正确。所有以这种方式指定的终结符，都可以理解为 Unicode 字符的完整的 ASCII 范围，不是任何其他乌焉成马的 Unicode 范围字符。 非终结符以斜体显示。一个非终结符的定义由非终结符名称和其后定义的一个或多个冒号给出。（冒号的数量表示产生式所属的文法。）非终结符的右侧有一个或多个替代子紧跟在下一行。 例如，句法定义： WhileStatement : while ( Expression ) Statement 表示这个非终结符 WhileStatement 代表 while Token，其后跟左括号 Token，其后跟 Expression，其后跟右括号 Token，其后跟 Statement。这里出现的 Expression 和 Statement 本身是非终结符。另一个例子，句法定义： ArgumentList : AssignmentExpression ArgumentList , AssignmentExpression 表示这个 ArgumentList 可以代表一个 AssignmentExpression，或 ArgumentList，其后跟一个逗号，其后跟一个 AssignmentExpression。这个 ArgumentList 的定义是递归的，也就是说，它定义它自身。其结果是，一个 ArgumentList 可能包含用逗号隔开的任意正数个参数，每个参数表达式是一个 AssignmentExpression。这样，非终结符共用了递归的定义。 终结符或非终结符可能会出现后缀下标 “opt”，表示它是可选符号。实际上包含可选符号的替代子包含两个右边部分，一个是省略可选元素的，另一个是包含可选元素的。这意味着： VariableDeclaration : Identifier Initialiser opt 是以下的一种缩写： VariableDeclaration: BindingIdentifier BindingIdentifier Initializer 并且： IterationStatement: for(LexicalDeclaration Expression opt ; Expression opt)Statement 是以下的一种缩写： IterationStatement: for(LexicalDeclaration ; Expression opt)Statement for(LexicalDeclaration Expression ; Expression opt)Statement 是以下的一种缩写： IterationStatement: for(LexicalDeclaration ;)Statement for(LexicalDeclaration ; Expression)Statement for(LexicalDeclaration Expression ;)Statement for(LexicalDeclaration Expression ; Expression)Statement 所以，在这个例子中，非终结符IterationStatement实际上有4个可选的右值。 一个产生式也许会通过形如“[parameters]”这样的下标注释被参数化，它们也许会作为后缀出现在产生式定义的非终结符中。“parameters”也许是单独的名称，或者一个逗号分隔的名称列表。一个被参数化的产生式是一系列定义参数名称的所有组合的产生式的缩写，以下划线开头，被追加到参数化的非终结符后面。这就意味着： StatementList[Return]: （注意这里的[Return]是下标） ReturnStatement ExpressionStatement 是下面的缩写： StatementList: ReturnStatement ExpressionStatement StatementList_Return: ReturnStatement ExpressionStatement 再比如： StatementList[Return, In]: ReturnStatement ExpressionStatement 是下面的缩写： StatementList: ReturnStatement ExpressionStatement StatementList_Return: ReturnStatement ExpressionStatement StatementList_In: ReturnStatement ExpressionStatement StatementList_Return_In: ReturnStatement ExpressionStatement 多个参数产生一个组合后的产生式，但是在一个复杂的语法中，并不一定需要引用它们中的全部内容。 在一个产生式的右值中引用非终结符也能被参数化，例如： StatementList: ReturnStatement ExpressionStatement[+In] 再比如： StatementList: ReturnStatement ExpressionStatement[~In] 是下面的缩写： StatementList: ReturnStatement ExpressionStatement 一个非终结符引用也许既有一个参数列表，又有一个“opt”后缀，例如： VariableDeclaration: BindingIdentifier Initializer[+In]opt （注意[+In]和opt都是下标） 是下面的缩写： VariableDeclaration: BindingIdentifier BindingIdentifier Initializer_In 给一个参数在右值的非终结符引用加上前缀“?”使得那个参数依赖于引用当前产生式左值符合的参数名，例如： VariableDeclaration[In]: BindingIdentifier Initializer[?In] 是下面的缩写： VariableDeclaration: BindingIdentifier Initializer VariableDeclaration_In: BindingIdentifier Initializer_In 如果一个右值以“[+parameter]”作为前缀，那么那个可选的只有在命名的参数在引用产生式的非终结符时被使用时才可用。如果一个可选的右值以“[~parameter]”作为前缀，那么那个可选的只有在命名的参数在引用产生式的非终结符时没有被使用时才可用。（译注：即+表示上下的[]必须同时出现，～表示不能同时出现）这意味着： StatementList[Return]: [+Return]ReturnStatement ExpressionStatement 是下面的缩写： StatementList: ExpressionStatement StatementList_Return: ReturnStatement ExpressionStatement 如果文法定义的冒号后面出现文字 “one of”，那么其后一行或多行出现的每个终结符都是一个选择定义。例如，ECMAScript 包含的词法生产器： NonZeroDigit :: one of 1 2 3 4 5 6 7 8 9 这仅仅下面写法的一种缩写： NonZeroDigit :: 1 2 3 4 5 6 7 8 9 如果产生式的右侧是出现 “[empty]”，它表明，生产器的右侧不包含终结符或非终结符。 如果产生式的右侧出现 “[lookahead ∉ set]”，它表明，给定 set 的成员不得成为产生式紧随其后的 Token。这个 set 可以写成一个大括号括起来的终结符列表。为方便起见，set 也可以写成一个非终结符，在这种情况下，它代表了这个非终结符 set 可扩展所有终结符。 如果set由单个终结符组成，则可以使用“ [lookahead≠terminal]”。 例如，给出定义 DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9 DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit 再定义 LookaheadExample :: n [lookahead ∉ {1 , 3 , 5 , 7 , 9}] DecimalDigits DecimalDigit [lookahead ∉ DecimalDigit] 匹配，字母 n 后跟随由偶数起始的一个或多个十进制数字，或一个十进制数字后面跟随一个非十进制数字。 类似地，如果“ [lookahead∈set]”出现在产生式的右侧，则表示仅当紧随其后的输入token序列是给定集的成员时，才可以使用产生式。如果set由单个终结符组成，则可以使用“ [lookahead=terminal]”。 如果产生式的右侧出现 “[no LineTerminator here]”，那么它表示此产生式是个受限的产生式：如果 行终结符（LineTerminator）在输入流的指定位置出现，那么此产生式将不会被适用。例如，产生式： ThrowStatement : throw [no LineTerminator here] Expression ; 表示如果程序中 throw Token 和 Expression 之间的出现行终结符，那么不得使用此产生式。 行终结符除了禁止出现在受限的产生式，可以在输入元素流的任何两个 Token 之间出现任意次数，而不会影响程序的句法验证。 当一个词法产生式或数字字符串文法中出现多字符 Token，它表示此字符序列将注册一个 Token。 使用词组 “but not” 可以指定某些不允许在产生式右侧的扩展，它说明排除这个扩展。例如，产生式： Identifier :: IdentifierName but not ReservedWord 此非终结符 Identifier 可以由可替换成 IdentifierName 的字符序列替换，相同的字符序列不能替换 ReservedWord。 最后，对于实际上不可能列出全部可变元的少量非终结符，我们用普通字体写出描述性的短语来描述它们： SourceCharacter :: any Unicode code unit 5.2 算法约定 此规范通常使用带编号的列表来指定算法的步骤。这些算法是用来精确地指定 ECMAScript 语言结构所需的语义。该算法无意暗示任何具体实现使用的技术。在实践中，也许可用更有效的算法实现一个给定功能。 算法也许被显式的参数化，在这些案例中参数的名称和用法必须作为算法定义的一部分提供。 算法的步骤可细分为有序的子步骤。子步骤被缩进，可以将自身进一步划分为缩进子步骤。大纲编号约定用于识别分步骤，第一层次的子步骤适用小写字母标记，第二层次的子步骤使用小写罗马数字标记。如果需要超过三个层次，则重复这些规则，第四层次使用数字标记。例如： 1.Top-level step a.Substep. b.Substep. i.Subsubstep. 1.Subsubsubstep a.Subsubsubsubstep i.Subsubsubsubsubstep 一个步骤或子步骤可使用谓词“if”作为其子步骤的条件。在这种情况下，当谓词为真时子步骤才适用。如果一个步骤或子步骤由单词“else”开始，那么它也是一个谓词，否定前面的同一层级的谓词“if”。 一个步骤可以指定其子步骤的迭代应用程序。 一个步骤以“Assert:”开始，断言了其算法的不变条件。此类断言用于产生显式的算法不变量，否则它们将是隐式的。这样的断言不增加任何附加的语义要求，因此不需要由实现来检查。它们仅用于阐明算法。 算法步骤可以使用“ “Let x be someValue ”的形式为任何值声明命名别名。这些别名与引用类似，因为x和someValue都引用相同的基础数据，并且对两者的修改都可见。想要避免这种类似引用行为的算法步骤应显式地复制右侧：“ Let x be a copy of someValue ”会创建someValue的浅拷贝。 声明后，别名可以在任何后续步骤中引用，并且一定不能从别名声明之前的步骤中引用。别名也许会通过形如“Set x to someOtherValue”这样的形式被修改。 5.2.1 抽象操作 为了便于在本规范的多个部分中使用它们，某些算法（称为抽象操作）以参数化功能形式进行命名和编写，以便可以从其他算法中按名称进行引用。通常使用功能性应用程序风格（例如OperationName（arg1，arg2））来引用抽象操作。一些抽象操作被视为模拟类规范抽象的多态调度方法。通常使用诸如someValue.OperationName（arg1，arg2）之类的方法应用程序样式来引用类似于方法的抽象操作。 5.2.2 特定语法操作 一个特定的语法操作是一个具有名称的操作，其定义由算法组成，每个算法都与一种ECMAScript语法中的一个或多个生成相关联。具有多个可选定义的产生式通常会对每个可选部分使用不同的算法。当算法与语法产生相关联时，它可以引用产生替代项的结束符和非结束符，就像它们是算法的参数一样。当以这种方式使用时，非终止符号指的是在解析源文本时匹配的实际替代定义。由语法生成匹配的源文本是源文本的一部分，该部分从匹配的第一个终端的开头开始，到匹配的最后一个终端的结尾结束。 当一个算法与一个产生式的可选部分关联的时候，这个可选部分通常不会带上“[ ]” 文法注释。这样的注释只应该影响可选部分的语法识别，不应该对相关的可选部分的语义有影响。 通过使用以下算法中的步骤1、3和4的约定，使用解析节点和（可选）其他参数来调用基于语法的操作： 1. Let `status` be the result of performing SyntaxDirectedOperation of SomeNonTerminal. 2. Let `someParseNode` be the parse of some source text. 3. Perform SyntaxDirectedOperation of `someParseNode`. 4. Perform SyntaxDirectedOperation of `someParseNode` passing \"value\" as the argument. 除非显式地指定，否则，所有相关联的产生式对于每个也许会被应用到这个产生式左值的非终结符的操作都有一个隐式的定义。如果存在的话，这个隐式的定义简单地再次对同样的参数运用这个相同的定义，对于这些相关联的产生式唯一的右值非终结符，随后返回处理结果。例如，假设一些算法有如下形式的步骤：“返回被解析的块的结果（Return the result of evaluating Block）”，并且这里有一个产生式： Block : { StatementList } 但是解析操作并没有关联这个产生式的算法。那么在这样的案例中，解析操作隐式地包含了下面形式的关联： 运行时语义: 解析（Runtime Semantics: Evaluation） Block : { StatementList } 1. Return the result of evaluating StatementList. 5.2.3 运行时语义 必须在运行时被调用的指定语义的算法就叫运行时语义。运行时语义通过抽象操作或者指定语法操作来定义。这样的算法必须返回一个完成记录。 5.2.3.1 隐式完成值 本规范的算法常常隐式地返回一个[[Type]]值为normal的完成记录。除非它是上下文中另外非常明显的部分，一个返回一个值的算法语句，那么这个值将不是一个完成值。例如： Return \"Infinity\". 与下面的是同一个含义： Return NormalCompletion(\"Infinity\"). 然而，如果一个“return”语句的值表达式是一个完成记录构造的字面量，那么完成记录的结果将被返回。如果这个值表达式是一个对抽象操作的调用，那么“return”语句简单地返回这个抽象操作产生的完成记录。 抽象操作完成（完成记录）被用作强调之前计算的完成记录被返回。完成（Completion）这个抽象操作接收一个参数，即完成记录（completionRecord），然后执行下面的步骤： 1. Assert: completionRecord is a Completion Record. 2. Return completionRecord as the Completion Record of this abstract operation. 一个在算法步骤中没有值的“return”语句与下面的是同样的意思： Return NormalCompletion(undefined). 对于任意的在一个上下文中没有显示地需要一个完整的完成记录值的引用，等价于一个显式地对完成记录的[[Value]]字段的引用，除非完成记录是一个打断/中断（abrupt）完成。 5.2.3.2 抛出一个异常 描述抛出一个异常的算法步骤，例如： Throw a TypeError exception 意思就是： Return ThrowCompletion(a newly created TypeError object). 5.2.3.3 如果被打断则返回 算法步骤说明或者等同于： ReturnIfAbrupt(argument). 意思就是： 1. If argument is an abrupt completion, return argument. 2. Else if argument is a Completion Record, let argument be argument.[[Value]]. 算法步骤说明或者等同于： 1. ReturnIfAbrupt(AbstractOperation()). 意思就是： 1. Let hygienicTemp be AbstractOperation(). 2. If hygienicTemp is an abrupt completion, return hygienicTemp. 3. Else if hygienicTemp is a Completion Record, let hygienicTemp be hygienicTemp.[[Value]]. 这里的hygienicTemp是短暂的（临时的），并且只在ReturnIfAbrupt有关的步骤中中可见。 算法步骤说明或者等同于： 1. Let result be AbstractOperation(ReturnIfAbrupt(argument)). 意思就是： 1. If argument is an abrupt completion, return argument. 2. If argument is a Completion Record, let argument be argument.[[Value]]. 3. Let result be AbstractOperation(argument). 5.2.3.4 如果被打断则返回缩写 对抽象操作和以?为前缀的指定语法操作的调用暗示着ReturnIfAbrupt需要被应用到结果的完成记录中。例如，步骤： ? OperationName(). 等价于下面的步骤： ReturnIfAbrupt(OperationName()). 相似的，对于程序方法的风格，步骤： ? someValue.OperationName(). 等价于 ReturnIfAbrupt(someValue.OperationName()). 相似的，前缀！被用作暗示下列的对于抽象或者指定语法操作的调用将不会返回一个打断的（abrupt）完成值，并且作为结果的完成记录的[[Value]]字段应该被用作替换操作的返回值，例如，步骤： Let val be ! OperationName(). 等价于下面的步骤： 1. Let val be OperationName(). 2. Assert: val is never an abrupt completion. 3. If val is a Completion Record, set val to val.[[Value]]. 对于运行时语义的指定语法的操作通过在调用操作前替换！或者？来利用这个缩写。 Perform ! SyntaxDirectedOperation of NonTerminal. 5.2.4 静态语义 上下文无关文法不能足够好的去表达所有定义的规则，不管是一个输入元素的流形成的一个合法的将被解析的ECMAScript脚本（Script）还是模块（Module）。在一些情况中，需要额外的规则通过使用ECMAScript算法约定或者散文要求（prose requirements）来展示。这样的规则总是与一个文法的产生式相关联，被称作产生式的静态语义。 静态语义规则拥有名称，并且通常用一个算法来定义。具有名称的静态语义规则与文法产生式相关联，对于每个可采用的具有名称的静态语义规则，一个包含多个可选部分定义的产生式通常会对每个可选部分定义一个独有的算法。 除非在本规范中其它指定的文法产生式可选部分隐式地包含一个叫做Contains的接收一个值为包含相关产生式的文法的终结符或者非终结符的symbol参数静态语义规则的定义。默认的包含定义为： 1. For each child node child of this Parse Node, do a. If child is an instance of symbol, return true. b. If child is an instance of a nonterminal, then i. Let contained be the result of child Contains symbol. ii. If contained is true, return true. 2. Return false. 上面的定义是显式地重写了规范的产生式。 一个特殊的静态语义规则是早期（提前）错误规则（Early Error Rule）。早期错误规则定了早期错误条件（参见16章），它们与具体的文法产生式相关联。大多数早期错误规则的解析不是在本规范的算法中显式地被调用。一个符合规范的实现必须在第一次解析脚本或者模块之前，验证所有被用作解析脚本或者模块的产生式的早期错误规则。如果违反了任意的早期错误规则，那么脚本或者模块就是不合法的，并且不能被解析执行。 5.2.5 数学操作 除非其它地方特别注明不包括无限并且不包括负0（为了与正0区分），数学操作，例如加，减，否定（逻辑非），乘，除以及随后在条款中定义的数学函数应总是被当作是对于数学中所有真实数字计算出来的准确的结果。本规范算法中的浮点运算包含显式地的步骤，它们对于处理无穷，有符号的0，以及舍入是必要的。如果一个数学操作或者函数被应用在一个浮点数上，那么它必须被当作应用到用浮点数表示的具体的数学值；这样的浮点数必须是有限的，并且如果它是+0或者-0的话，那么相应的数学值就是简简单单的0。 数学函数abx(x)用来计算x的绝对值，如果x是负数（小于0），那么结果就是-x，否则结果就是x本身。 数学函数min(x1, x2, ..., xN)计算从x到xN的最小值。数学函数max(x1, x2, ..., xN)计算从x到xN的最大值。这些数学函数的域（译注：即定义域和值域）以及范围包括+∞和-∞。 符号“x modulo y”（译注：即x模y）（y必须是有限的且是非0的）计算出一个值k，它的符号与y一致（或者是0），这样的k满足abs(k) y)，以及能找到某个整数y，使得x-k = q * y。 The mathematical function floor(x) produces the largest integer (closest to positive infinity) that is not larger than x. 注意 floor(x) = x-(x modulo 1). （译注：即模运算是向0方向舍入） 一个上下文无关文法由一定数量的产生式组成。每个产生式的左边部分是一个被称为非终结符的抽象符号，右边部分是零或多个非终结符和终结符的有序排列。任何文法，它的终结符都来自指定的字母集。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,记法约定,notationalConventions "},"ecmascript-data-types-and-values.html":{"url":"ecmascript-data-types-and-values.html","title":"6 ECMAScript数据类型和值","keywords":"","body":"6 ECMAScript数据类型和值 本规范的算法操作的值每一个都有其相应的类型。 可能的值类型正是本节中定义的值类型。类型又进一步分为ECMAScript语言类型（language types）以及规范类型（specification types）。 在本规范中，符号“Type(x)”用来作为“the type of x”的简写，这里的“type”指向定义在本章中的ECMAScript语言以及规范类型。 当使用“empty”一词来命名值时，等效于说“没有任何类型的值”。 6.1 ECMAScript语言类型 ECMAScript语言类型 对应的是程序员使用 ECMAScript 语言直接操作的值。ECMAScript语言类型 包括 Undefined、Null、Boolean、String、Number、Object。 ECMAScript语言值是一个具有ECMAScript语言类型的值。 6.1.1 Undefined类型 Undefined类型仅仅只有一个值，被称为undefined。任何没有被分配一个值的变量的值就是undefined。 6.1.2 Null类型 Null类型仅仅只有一个值，被称为null。 6.1.3 Boolean类型 Boolean类型代表一个拥有两个值的逻辑的实体，它们被称为true和false。 6.1.4 String类型 字符串类型是所有有限的零个或多个16位无符号整数值（“元素”）的有序序列， 最大的长度是2^53 - 1个元素的长度。在运行的 ECMAScript 程序中，字符串类型常被用于表示文本数据，此时字符串中的每个元素都被视为一个 代码单元。 每个元素都被认为占有此序列中的一个位置，用非负整数索引这些位置。任何时候，第一个元素（若存在）在位置0，下一个元素（若存在）在位置1，依此类推。字符串的长度即其中元素（即16位的值）的个数。空字符串长度为零，因而不包含任何元素。 若一个字符串包含实际的文本数据，每个元素都被认为是一个单独的 UTF-16 代码单元。无论这是不是 String 实际的存储格式，String 中的字符都被当作表示为 UTF-16 来计数。除非特别声明，作用在字符串上的所有操作都视它们为无差别的 16 位无符号整数；这些操作不保证结果字符串仍为正规形式，也不保证语言敏感结果。 不解释字符串内容的ECMAScript操作不会有进一步的语义。解释字符串值的操作将每个元素视为单个UTF-16代码单元。但是，ECMAScript并不限制这些代码单元的值或它们之间的关系，因此将字符串内容进一步解释为以UTF-16编码的Unicode代码点序列的操作必须考虑格式错误的子序列。此类操作会对数字值在0xD800到0xDBFF（由Unicode标准定义为前导代理，或更正式地作为高位代理码元）范围内的每个码元和每个具有数字值的码元进行特殊处理。使用以下规则在0xDC00到0xDFFF（包括后尾代理，或更正式地定义为低位代理码元）的范围内： ​ 一个不是前导代理或尾代理的码元将被解释为具有相同值的码位。 ​ 一个包含两个码元的序列，第一个码元c1在范围0XD800到0XDBFF，第二个码元c2在范围0xDC00到0xDFFF，这样的称为代理对，它们被解释为一个值为（c1 - 0xD800） * 0x400 + （c2 - 0xDC00） + 0x10000的码点（See 10.1.2）。 ​ 一个作为前导代理或尾代理但不属于代理对的代码单元，将被解释为具有相同值的代码点。 函数String.prototype.normalize（请参见21.1.3.12）可用于显式标准化String值。String.prototype.localeCompare（请参见21.1.3.10）内部对字符串进行了规范化，但是没有其他操作隐式对对其进行操作的字符串进行规范化。 只有那些被显式地指定用来处理语言或者对语言环境敏感的操作才会产生语言敏感的结果。 注意 这个设计背后的基本原理是保证Strings的实现尽可能是简单和高效的。如果ECMAScript源文本在规范化的形式C内，那么字符串字面量也应当被认为是规范化的，只要它们不包含任何Unicode转移序列。 在本说明书中，短语“ A，B，...的字符串连接”（其中每个自变量是字符串值，代码单元或代码单元序列）表示该字符串值，其代码单元序列为每个参数（按顺序）的代码单元（按顺序）的串联 6.1.5 Symbol类型 Symbol类型是所有非字符串的也许被用作作为对象的属性的键的集合。 每个可能的Symbol值都是唯一的和不可变的。 每个Symbol值永远地保持一个与之关联的叫做[[Description]]的值，它要么是undefined要么是一个字符串值。 6.1.5.1 常见的Symbol 众所周知的符号是内置符号值，此规范的算法明确引用了这些值。它们通常用作属性的键，其值用作规范算法的扩展点。除非另有说明，否则所有作用域（8.2）都会共享众所周知的符号值。 在本说明书中，使用@@name形式的符号来引用常见的符号，其中“name”是 表1 。 Table 1: 常见Symbols 规格名称 [[Description]] 值与用途 @@asyncIterator \"Symbol.asyncIterator\" 返回对象的默认AsyncIterator的方法。由for-await-of语句的语义调用。 @@hasInstance \"Symbol.hasInstance\" 确定构造函数对象是否将对象识别为构造函数实例之一的方法。 由instanceof运算符的语义调用。 @@isConcatSpreadable \"Symbol.isConcatSpreadable\" 一个布尔值属性，如果为true，则表示一个对象可以通过Array.prototype.concat扁平化到其数组元素。 @@iterator \"Symbol.iterator\" 一种返回对象的默认迭代器的方法。 被称为for语句的语义。 @@match \"Symbol.match\" 与正则表达式匹配字符串的正则表达式方法。 由String.prototype.match方法调用。 @@replace \"Symbol.replace\" 一个正则表达式方法，用于替换字符串的匹配子字符串。 由String.prototype.replace方法调用。 @@search \"Symbol.search\" 一个正则表达式方法，它返回与正则表达式匹配的字符串中的索引。 由String.prototype.search方法调用。 @@species \"Symbol.species\" 一个函数值属性，它是用于创建派生对象的构造函数。 @@split \"Symbol.split\" 一个正则表达式方法，它在与正则表达式匹配的索引处分割字符串。 由String.prototype.split方法调用。 @@toPrimitive \"Symbol.toPrimitive\" 将对象转换为相应的原始值的方法。 由 ToPrimitive 抽象操作调用。 @@toStringTag \"Symbol.toStringTag\" 用于创建对象的默认字符串描述的String值属性。 通过内置方法访问Object.prototype.toString。 @@unscopables \"Symbol.unscopables\" 一个对象值属性，其自有和继承的属性名称是从具有关联对象的with中排除的属性名称。 6.1.6 Number类型 Number类型正好具有18437736874454810627（即2^64-2^53 + 3）个值，表示双精度64位格式的在IEEE标准中关于二进制浮点类型运算的IEEE 754-2008规范的值 ，除了9007199254740990（即2^53-2）与IEEE标准的不同，“ Not-a-Number”值在ECMAScript中表示为单个特殊的NaN值。（请注意，NaN值是由程序表达式NaN产生的。）在某些实现中，外部代码可能能够检测到各种Not-a-Number值之间的差异，但是这种行为取决于实现。对于ECMAScript代码，所有NaN值彼此之间是无法区分的。 注意：在一个Number值已经被存储后，位模式（bit pattern）也许可以通过一个ArrayBuffer或者SharedArrayBuffer观察到，但是这和Number值的内部表示一样，不是ECMAScript的实现所必须的。 这里有两种其它的特殊值，叫做正无穷和负无穷。为了简洁和说明目的，这些值也分别用符号+∞和-∞表示。（注意这两个无穷数由程序表达式+Infinity（或者简单的Infinity）和-Infinity产生） 其它的18437736874454810624个值（即， , 2^64 - 2^53 ）被称作有限数（finite numbers）。其中一半是正数，一半是负数；对于每个有限正数值，这里都有一个相应量级的负数值。 注意这里既有正0也有负0。为了简洁和说明的目的，这些值也分别用符号+0和-0表示。（注意这两个不同的零数字值由程序表达式+0（或者简单的0）和-0产生。） 18437736874454810622（即 2^64 - 2^53 - 2 ）个有限非0值有下面两种类型： 18428729675200069632 (即 2^64 - 2^54) 个值是被规范化了的，它们是下面的形式： s × m × 2^e 这里的s是+1或者-1， m是一个小于2^53但是不小于2^52的正数，e是一个闭区间-1074到971的整数。 剩下的9007199254740990（即2^53 - 2）个值是没有被范式化的，它们是下面的形式： s × m × 2^e 这里的s是+1或者-1，m是一个小于2^52的正数，e是-1074。 请注意，所有大小不大于2^53的正整数和负整数都可以在Number类型中表示（实际上，整数0有两种表示形式，即+0和-0）。 如果是非0的话，一个有限数有一个奇数的尾数那么它就是奇数，整数m用来表示这个尾数（即上面提到的两种形式之一）。否则，它就有一个偶数的尾数。 在本规范中，短语“the Number value for x”里的x刚好代表一个非0值的真实的数学量（也有可能是如π之类的无理数），也意味着一个Number值按照下面的方式被选择出来。首先考虑Number类型中所有的有限数的集合，除去-0，加上两个Number类型无法表示的值，被称为2^1024（即1 × 2^53 2^971 ）以及-2^1024，即-1 × 2^53 2^971)。然后选择这个集合中离x最近的元素。如果有两个值一样接近，那么选择有偶数尾数的那一个。处于为此目的考虑，两个额外的值2^1024和-2^1024被认为是拥有相同的偶数尾数。最后，如果选择的是2^1024，用+∞替换它。如果选择的是-2^1024，用-∞替换它。如果选择的是+0，只在x小于0时才用-0替换它。除了上面提到的这些，任意其它的选择值是不会发生变化的。最后的结果就是x的Number值。（这样就能刚好产生与IEEE 754-2008的“四舍五入到最接近的关系”行为模式相对应的值。） 某些ECMAScript运算符仅处理特定范围内的整数，例如-2^31至2^31-1（含）或0至2^16-1（含）的范围。这些运算符接受Number类型的任何值，但首先将每个此类值转换为期望范围内的整数值。请参阅7.1中的数值转换操作说明。 6.1.7 Object类型 从逻辑上讲，对象是属性的集合。每个属性都是数据属性或访问器属性： 一个数据属性关联一个ECMAScript语言值的key值以及一组Boolean属性的集合。 一个访问器属性关联一个或两个访问器函数的key值，一组Boolean属性的集合。访问器函数被用来存储或者检索与这个属性相关的ECMAScript语言值。 属性是用key值来识别的。一个属性的key值要么是一个ECMAScript String值，要么是一个Symbol值。所有的String和Symbol值，包括空字符串，都是合法的属性key值。当一个属性的key是String值的时候，这个属性的name是这个属性的key。 一个整数索引是一个字符串值的属性键，它是一个规范的数字字符串（参考7.1.16）。它的数字值要么是+0，要么是一个 ≤ 2^53-1的正整数。一个数组索引是一个整数索引，它的数字值i的范围是+0 ≤ i 属性键用于访问属性及其值。属性有两种访问方式：get和set，分别对应于值检索和赋值。通过get和set访问可访问的属性包括作为对象直接一部分的自身属性和由另一个关联对象通过属性继承关系提供的继承属性。继承的属性可以是关联对象的拥有属性或继承的属性。一个对象的每个自己的属性必须各自具有与该对象的其他自己的属性的键值不同的键值。 从逻辑上讲，所有对象都是属性的集合，但是有多种形式的对象在其访问和操作其属性时具有不同的语义。普通对象是对象的最常见形式，并具有默认的对象语义。异类对象其属性语义与默认语义在各个方面都有区别。 6.1.7.1 属性的特性 本规范中的属性被用作定义和解释对象属性的状态。数据属性与表2中列出的属性的key值一一对应。 特性名称 取值范围 描述 [[Value]] 任意的ECMAScript语言类型 访问属性时被检索到的值 [[Writable]] Boolean 如果为false，任何尝试通过[[Set]]去改变这个属性的[[Value]]属性的ECMAScript代码都不会成功。 [[Enumerable]] Boolean 如果为true,这个属性被for-in枚举时将会是可枚举的（参考13.7.5）。否则，这个属性就是不可枚举的。 [[Configurable]] Boolean 如果为false，任何尝试删除这个属性，把这个属性改为访问器属性，或者改变它的除了[[Value]]之外的属性，或者改变它的[[Writable]]为false的操作都会失败。 一个访问器属性accessor property与表3中列出的属性的key值相关联。 特性名称 取值范围 描述 [[Get]] Object\\Undefined 如果这个值是一个对象，那么它必须是一个函数对象。在每次访问这个属性的时候，这个函数的内置[[Call]]方法（下面的表6中）将会被调用，同时会向这个方法传入一个空的arguments。 [[Set]] Object\\Undefined 如果这个值是一个对象，那么它必须是一个函数对象。在每次设置这个属性的时候，这个函数的内置[[Call]]方法（下面的表6中）将会被调用，同时会向这个方法传入包含所赋的值的arguments，作为这个arguments的唯一参数。[[Set]]内置方法也许会对后续的[[Get]]内置方法调用产生的返回值产生影响，但不是必须的。 [[Enumerable]] Boolean 如果为true,这个属性被for-in枚举时将会是可枚举的（参考13.7.5）。否则，这个属性就是不可枚举的。 [[Configurable]] Boolean 如果为false，任何尝试删除这个属性，把这个属性改为数据属性，或者改变它的其它attributes的操作都会失败。 如果一个属性的attributes的初始值没有被本规范显式地指定的时候，那么使用在表4中定义的默认值： 特性名称 默认值 [[Value]] undefined [[Get]] undefined [[Set]] undefined [[Writable]] false [[Enumerable]] false [[Configurable]] false 6.1.7.2 对象的内置方法和内置槽 在ECMAScript中，对象的实际语义是通过算法来调用内置方法指定的。在ECMAScript引擎中的每个对象都与一系列的定义它的运行时行为的内置方法相关联。这些内置方法不属于ECMAScript语言的一部分。通过本规范定义它们的部分仅仅是为了解释和说明的目的。然而，在ECMAScript具体实现中的每个对象必须表现得像这些内置方法与它关联了一样。其中的准确的行为由实现来决定。 内置方法的名称是多种多样的。这意味着当一个常见的内置方法被调用的时候，不同的对象值也许会运行不同的算法。内置方法被调用时实际的对象成为这个调用的“目标”。如果在运行时一个算法的实现尝试去使用一个对象不支持的内置方法，一个TypeError将会被抛出。 内置槽对应相关联对象的内部状态，被ECMAScript规范中不同的算法使用。内置槽不是对象的属性，也不会被继承。根据规范中具体的内置槽，这样的内部状态也许包含任意ECMAScript语言类型的值或者指定的ECMAScript规范类型的值。除非显式地指定，否则内置槽作为创建一个对象的一部分过程被分配，并且也许不能被动态地添加到对象上。除非显式地指定，否则一个内置槽的初始值是undefined。本规范内不同的算法都会创建有内置槽的对象。然而，ECMAScript语言不提供直接的方法去访问一个对象的内置槽。 本规范内的内置方法和内置槽使用闭合的双方括号[[]]来标识。 下方的表5总结了被规范使用的适用于所有对象的创建或者被ECMAScript代码操作的至关重要的内置方法。每个对象对于所有至关重要的算法都必须有相应的算法。然而，所有的对象没有必要对那些方法使用相同的算法。 下面的表5中的 “Signature”列以及其它相似的表格描述了每个内置方法的调用模式。调用模式总是包含一个括起来的描述参数名的列表。如果一个参数名与ECMAScript类型的名字一样，那么代表描述的是参数值需要的类型。如果一个内置方法显式地返回了一个值，它的参数列表随后就会跟着一个“→”符合，以及返回值的类型。在signature中使用的类型的名字指向在第6章中定义的类型，另外还增加了一些下面的名称。“any”代表这个值也许是任意的ECMAScript语言值。一个内置方法会隐式地返回一个完成记录。除了它的参数，一个内置方法还总是会访问这个方法调用的对象的目标（即前面提到的target）。 内部方法 签名 描述 [[GetPrototypeOf]] ( ) → Object \\ Null 确定为这个对象提供继承的属性的对象。一个null值代表没有继承的属性。 [[SetPrototypeOf]] (Object \\ Null) → Boolean 将这个对象与提供继承的属性的对象相关联。传递null表示没有继承的属性。返回true表示操作成功，返回false表示操作失败。 [[IsExtensible]] ( ) → Boolean 决定是否允许添加额外的属性到这个对象上。 [[PreventExtensions]] ( ) → Boolean 控制一个新的属性是否能加到这个对象上。返回true表示操作成功，返回false表示操作失败。 [[GetOwnProperty]] (propertyKey) → Undefined \\ Property Descriptor 返回这个对象的一个自身属性的属性描述符，它的key为propertyKey，或者undefined（如果没有这样的属性存在的话）。 [[DefineOwnProperty]] (propertyKey, PropertyDescriptor) → Boolean 创建或者改变自身属性，它的key为propertyKey，它的状态为PropertyDescriptor。返回true表示属性被成功创建/更新，返回false表示属性不能被创建/更新。 [[HasProperty]] (propertyKey) → Boolean 返回一个Boolean值，代表这个对象是否已经有一个自身的或者继承的key为propertyKey的属性。 [[Get]] (propertyKey, Receiver) → any 返回这个对象里key值为propertyKey的属性的值。如果任何的ECMAScript代码必须被运行来检索这个属性值，Receiver就会作为解析代码时的this值。 [[Set]] (propertyKey, value, Receiver) → Boolean 设置这个对象中的key为propertyKey的属性的值为value。如果任何的ECMAScript代码必须被运行来检索这个属性值，Receiver就会作为解析代码时的this值。返回true表示这个属性能被设置，返回false表示不能被设置。 [[Delete]] (propertyKey) → Boolean 移除这个对象的key值为propertyKey的自身属性。返回false表示这个属性没有被移除，仍然存在。返回true表示已经被移除，不再存在。 [[OwnPropertyKeys]] ( ) → List of propertyKey 返回一个一个List，这个List里的元素都来自这个对象的自身属性的key。 table 6总结了可被称为函数的对象所支持的其他基本内部方法。函数对象是支持[[Call]]内部方法的对象。构造函数是支持[[Construct]]内部方法的对象。每个支持[[Construct]]的对象都必须支持[[Call]]。也就是说，每个构造函数都必须是一个函数对象。因此，构造函数也可以称为构造函数或构造函数对象。 Table 6: 功能对象的附加基本内部方法 内部方法 签名 描述 [[Call]] (any, a List of any) → any 执行与此对象关联的代码。 通过函数表达式调用。 内部方法的参数是一个this值，还有一个包含通过调用表达式传递给函数的参数的列表。 实现此内部方法的对象是可调用的(callable)。 [[Construct]] (a List of any, Object) → Object 创建一个对象。 通过new或super运算符调用。 内部方法的第一个参数是包含运算符的参数的列表。 第二个参数是最初应用new运算符的对象。 实现此内部方法的对象称为构造函数(constructors)。 函数对象不一定是构造函数，而非构造函数对象没有[[Construct]]内部方法。 在第9节中指定了普通对象和标准异类对象的基本内部方法的语义。如果实现不支持对异类对象的内部方法的任何指定使用，则尝试使用该用法时必须抛出TypeError异常。 6.1.7.3 基本内部方法的不变量 ECMAScript引擎中的对象的内置方法必须符合下方指定的不变量列表。普通的ECMAScript对象以及本规范中标准的异类对象维护这些不变量。ECMAScript代理（Proxy）对象通过对[[ProxyHandler]]对象被调用的结果的运行时检查来维护这些不变量。 任何提供异类对象的实现也必须维护这些对象的不变量 。违反这些不变式可能会导致ECMAScript代码具有不可预测的行为并引发安全问题。但是，违反这些不变量绝不能损害实现的内存安全性。 一个实现必须不允许以任何方式规避这些不变量，例如通过提供替代接口来实现基本内部方法的功能而不强制用不变量。 定义： 一个内置方法的target是一个对象，这个对象的对应的内置方法会被调用。 如果一个target被观察到它的[[IsExtensible]]内置方法返回false或者[[PreventExtensions]]返回true，那么它是不可扩展的。 一个不存在的属性是指那些在不可扩展的target的自身属性上不存在的属性。 所有引用SameValue（译注：即判断两个值是否相等）的地方都根据SameValue算法。 [[GetPrototypeOf]] ( ) 返回值的类型必须是Object或者Null。 如果target是不可扩展的，并且[[GetPrototypeOf]]返回了一个值v，那么任何将来的对[[GetPrototypeOf]]的调用都应该返回v的SameValue。 注意1： 一个对象的原型链的长度应该是有限的（也就是说，从任意对象开始，递归地对结果应用[[GetPrototypeOf]]内置方法最终应该得到null）。然而，如果这个原型链包含任意的不使用普通对象的[[GetPrototypeOf]]定义的异类对象，那么作为一个对象的不变量水平，这个要求不是强制的。当访问对象属性的时候，这样的一个环形的原型链也许最终会导致无限循环。 [[SetPrototypeOf]] (V) 返回值的类型必须是Boolean。 如果target是不可扩展的，[[SetPrototypeOf]]必须返回false，除非V是target观察到的[[GetPrototypeOf]]值的SameValue。 [[IsExtensible]] ( ) 返回值的类型必须是Boolean。 如果[[IsExtensible]]返回false，所有将来的在target上的对[[IsExtensible]]的调用都必须返回false。 [[PreventExtensions]] ( ) 返回值的类型必须是Boolean。 如果[[PreventExtensions]]返回false，所有将来的在target上的对[[IsExtensible]]的调用都必须返回false，并且现在开始target被认为是不可扩展的。 [[GetOwnProperty]] ( P ) 返回值的类型必须是Property Descriptor或者Undefined。 如果返回值的类型为Property Descriptor，则返回值必须为完整的属性描述符。 (参考 6.2.5.6). 如果一个属性P被描述为一个含有Desc的数据属性。访问器 的[[Value]]等于v，访问器的[[Writable]]以及[[Configurable]]为false，那么对于访问器的[[Value]]属性，必须返回SameValue。将来对这个属性的[[Value]]属性的调用变成[[GetOwnProperty]] ( P )。 如果P的除了[[Writable]]之外的属性随着时间发生了变化或者这个属性消失了，那么P的[[Configurable]]属性必须变成true。 如果[[Writable]]属性从false变成了true，那么[[Configurable]]属性必须变成true。 如果target是不可扩展的，并且P是不存在的，那么所有将来在target上对[[GetOwnProperty]] (P)的调用必须把P描述为不存在的（即[[GetOwnProperty]] (P)必须返回undefined）。 注意2： 作为第三个不变量的结论，如果一个属性被描述为一个数据属性并且随着时间它返回不同的值，那么访问器的[[Writable]]和[[Configurable]]属性必须是true，即使没有机制去改变通过其它内置方法暴露出来的值。 [[DefineOwnProperty]] ( P, Desc) 返回值的类型必须是Boolean。 如果P之前已经被观察为target的一个不可配置的自身属性，[[DefineOwnProperty]]必须返回false，除非： P是一个不可配置的可写的自身数据属性。一个不可配置的可写数据属性能被改变为一个不可配置的不可写的数据属性。 所有在访问器中的属性都是P的属性的SameValue。 如果target是不可扩展的并且P是一个不存在的自身属性，[[DefineOwnProperty]] (P, Desc)必须返回false。也就是说，一个不可扩展的对象不能扩展新的属性。 [[HasProperty]] ( P ) 返回值的类型必须是Boolean。 如果P之前被观察到是target的一个不可配置的数据或者访问器自身属性，[[HasProperty]]必须返回true。 [[Get]] (P, Receiver) 如果P之前被观察到是target的一个value为v的不可配置且不可写的自身数据属性，那么[[Get]]必须返回SameValue。 如果P之前被观察到是[[Get]]属性是undefined的target的一个不可配置的自身访问器属性，那么[[Get]]操作必须返回undefined。 [[Set]] ( P, V, Receiver) 返回值的类型必须是Boolean。 如果P之前被观察到是target的一个value为v的不可配置且不可写的自身数据属性，那么[[Set]]必须返回false，除非V是P的[[Value]]属性的SameValue。 如果P之前被观察到[[Set]]属性是undefined 的target的是一个不可配置的自身访问器属性，那么[[Set]]操作必须返回undefined。 [[Delete]] ( P ) 返回值的类型必须是Boolean。 如果P之前被观察到是target的一个不可配置的自身数据属性或者访问器属性，[[Delete]]必须返回false。 [[OwnPropertyKeys]] ( ) 返回值必须是一个List。 返回的List中的每个元素的类型要么是String，要么是Symbol。 返回的List必须至少包含之前观察到的所有的不可配置的自身属性。 如果这个对象是不可扩展的，那么返回的List必须只能包含这个对象的所有通过[[GetOwnProperty]]观察到的自身属性的key。 [[Construct]] ( ) 返回值的类型必须是Object。 6.1.7.4 常见的内部对象 常见的内部函数是那些被本规范的算法显式地引用的内置对象，在这些函数中通常拥有基于特定域下的特性。除非另有说明，否则每个内部对象在每个域中都实际对应一个相似对象的集合。 在本规范中，一个像%name%这样的引用就表示关联到当前域的内部对象的对应的name。当前域的确定以及它的内部情况在8.3节中描述。常见的内部对象在下面的表7中列出。 内部名称 全局名称 ECMAScript 语言意义 %Array% Array Array构造函数（参考22.1.1） %ArrayBuffer% ArrayBuffer ArrayBuffer构造函数（参考24.1.2） %ArrayBufferPrototype% ArrayBuffer.prototype %ArrayBuffer%的prototype数据属性的初始值 %ArrayIteratorPrototype% Array迭代器的prototype对象（参考22.1.5） %ArrayPrototype% Array.prototype %Array%的prototype数据属性的初始值（参考22.1.3） %ArrayProto_entries% Array.prototype.entries %ArrayPrototype%的entries数据属性的初始值（22.1.3.4） %ArrayProto_forEach% Array.prototype.forEach %ArrayPrototype%的forEach数据属性的初始值（22.1.3.12） %ArrayProto_keys% Array.prototype.keys %ArrayPrototype%的keys数据属性的初始值（22.1.3.16） %ArrayProto_values% Array.prototype.values %ArrayPrototype%的prototype数据属性的初始值（参考22.1.3.32） %AsyncFromSyncIteratorPrototype% async-from-sync迭代器对象属性 %AsyncFunction% 异步的函数对象（async function ）的构造器（参考25.7.1） %AsyncFunctionPrototype% %AsyncFunction%的prototype数据属性的初始值 %AsyncGenerator% %AsyncGeneratorFunction%的原型属性初始值 %AsyncGeneratorFunction% 异步迭代器随想的构造函数(25.3.1) %AsyncGeneratorPrototype% %AsyncGenerator%的原型属性初始值 %AsyncIteratorPrototype% 所有标准内置异步迭代对象继承自该对象 %Atomics% Atomics Atomic对象（参考24.4） %Boolean% Boolean Boolean构造函数（参考19.3.1） %BooleanPrototype% Boolean.prototype %Boolean%的prototype数据属性的初始值（参考19.3.3） %DataView% DataView DataView构造函数（参考24.3.2） %DataViewPrototype% DataView.prototype %DataView%的prototype数据属性的初始值 %Date% Date Date构造函数（参考20.3.2） %DatePrototype% Date.prototype %Date%的prototype数据属性的初始值 %decodeURI% decodeURI decodeURI函数（参考18.2.6.2） %decodeURIComponent% decodeURIComponent decodeURIComponent函数（参考18.2.6.3） %encodeURI% encodeURI encodeURI函数（参考18.2.6.4） %encodeURIComponent% encodeURIComponent encodeURIComponent函数（参考18.2.6.5） %Error% Error Error构造函数（参考19.5.1） %ErrorPrototype% Error.prototype %DataView%的prototype数据属性的初始值 %eval% eval eval函数（参考18.2.1） %EvalError% EvalError EvalError构造函数（参考19.5.5.1） %EvalErrorPrototype% EvalError.prototype %EvalError%的prototype数据属性的初始值 %Float32Array% Float32Array Float32Array构造函数（参考22.2） %Float32ArrayPrototype% Float32Array.prototype %Float32Array%的prototype数据属性的初始值 %Float64Array% Float64Array Float64Array构造函数（参考22.2） %Float64ArrayPrototype% Float64Array.prototype %Float64Array%的prototype数据属性的初始值 %Function% Function Function构造函数（参考19.2.1） %FunctionPrototype% Function.prototype %Function%的prototype数据属性的初始值 %Generator% %Generator%的prototype数据属性的初始值 %GeneratorFunction% generator对象的构造函数（参考25.2.1） %GeneratorPrototype% %Generator%的prototype数据属性的初始值 %Int8Array% Int8Array Int8Array构造函数（参考22.2） %Int8ArrayPrototype% Int8Array.prototype %Int8Array%的prototype数据属性的初始值 %Int16Array% Int16Array Int16Array构造函数（参考22.2） %Int16ArrayPrototype% Int16Array.prototype %Int16Array%的prototype数据属性的初始值 %Int32Array% Int32Array Int32Array构造函数（参考22.2） %Int32ArrayPrototype% Int32Array.prototype %Int32Array%的prototype数据属性的初始值 %isFinite% isFinite isFinite函数（参考18.2.2） %isNaN% isNaN isNaN函数（参考18.2.3） %IteratorPrototype% 一个对象，所有的内置对象的迭代器对象间接地都从这个对象继承而来。 %JSON% JSON JSON对象（参考24.5） %JSONParse% JSON.parse %JSON%的parse数据属性的初始值 %JSONStringify% JSON.stringify %JSON%的stringify数据属性的初始值 %Map% Map Map构造函数（参考23.1.1） %MapIteratorPrototype% Map迭代器对象的原型（参考23.1.5） %MapPrototype% Map.prototype %Map%的prototype数据属性的初始值 %Math% Math JSON对象（参考20.2） %Number% Number Number构造函数（参考20.1.1） %NumberPrototype% Number.prototype %Number%的prototype数据属性的初始值 %Object% Object Object构造函数（参考19.1.1） %ObjectPrototype% Object.prototype %Object%的prototype数据属性的初始值（参考19.1.3） %ObjProto_toString% Object.prototype.toString %Object%的toString数据属性的初始值（参考19.1.3.6） %ObjProto_valueOf% Object.prototype.valueOf %Object%的valueOf数据属性的初始值（参考19.1.3.7） %parseFloat% parseFloat parseFloat函数（参考18.2.4） %parseInt% parseInt parseInt函数（参考18.2.5） %Promise% Promise Promise构造函数（参考25.4.3） %PromisePrototype% Promise.prototype %Promise%的prototype数据属性的初始值 %PromiseProto_then% Promise.prototype.then %PromisePrototype%的then数据属性的初始值 %Promise_all% Promise.all %Promise%的all数据属性的初始值 %Promise_reject% Promise.reject %Promise%的reject数据属性的初始值 %Promise_resolve% Promise.resolve %Promise%的resolve数据属性的初始值 %Proxy% Proxy Proxy构造函数（参考26.2.1） %RangeError% RangeError RangeError构造函数（参考19.5.2.2） %RangeErrorPrototype% RangeError.prototype %RangeError%的prototype数据属性的初始值 %ReferenceError% ReferenceError ReferenceError构造函数（参考19.5.5.3） %ReferenceErrorPrototype% ReferenceError.prototype %ReferenceError%的prototype数据属性的初始值 %Reflect% Reflect Reflect对象（参考26.1） %RegExp% RegExp RegExp构造函数（参考21.2.3） %RegExpPrototype% RegExp.prototype %RegExp%的prototype数据属性的初始值 %Set% Set Set构造函数（参考23.2.1） %SetIteratorPrototype% Set迭代器对象的prototype（参考23.2.5） %SetPrototype% Set.prototype %Set%的prototype数据属性的初始值 %SharedArrayBuffer% SharedArrayBuffer SharedArrayBuffer构造函数（参考24.2.2） %SharedArrayBufferPrototype% SharedArrayBuffer.prototype %SharedArrayBuffer%的prototype数据属性的初始值 %String% String String构造函数（参考21.1.1） %StringIteratorPrototype% String迭代器对象的prototype（参考21.1.5） %StringPrototype% String.prototype %String%的prototype数据属性的初始值 %Symbol% Symbol Symbol构造函数（参考19.4.1） %SymbolPrototype% Symbol.prototype %Symbol%的prototype数据属性的初始值（参考19.4.3） %SyntaxError% SyntaxError SyntaxError构造函数（参考19.5.5.4） %SyntaxErrorPrototype% SyntaxError.prototype %SyntaxError%的prototype数据属性的初始值 %ThrowTypeError% 一个函数对象，无条件的抛出一个%TypeError%的实例 %TypedArray% 所有的typed Array构造函数的父类（参考22.2.1） %TypedArrayPrototype% %TypedArray%的prototype数据属性的初始值 %TypeError% TypeError TypeError构造函数（参考19.5.5.5） %TypeErrorPrototype% TypeError.prototype %TypeError%的prototype数据属性的初始值 %Uint8Array% Uint8Array Uint8Array构造函数（参考22.2） %Uint8ArrayPrototype% Uint8Array.prototype %Uint8Array%的prototype数据属性的初始值 %Uint8ClampedArray% Uint8ClampedArray Uint8ClampedArray构造函数（参考22.2） %Uint8ClampedArrayPrototype% Uint8ClampedArray.prototype %Uint8ClampedArray%的prototype数据属性的初始值 %Uint16Array% Uint16Array Uint16Array构造函数（参考22.2） %Uint16ArrayPrototype% Uint16Array.prototype %Uint16Array%的prototype数据属性的初始值 %Uint32Array% Uint32Array Uint32Array构造函数（参考22.2） %Uint32ArrayPrototype% Uint32Array.prototype %Uint32Array%的prototype数据属性的初始值 %URIError% URIError URIError构造函数（参考19.5.5.6） %URIErrorPrototype% URIError.prototype %URIError%的prototype数据属性的初始值 %WeakMap% WeakMap WeakMap构造函数（参考23.3.1） %WeakMapPrototype% WeakMap.prototype %WeakMap%的prototype数据属性的初始值 %WeakSet% WeakSet WeakSet构造函数（参考23.4.1） %WeakSetPrototype% WeakSet.prototype %WeakSet%的prototype数据属性的初始值 6.2 ECMAScript规范类型 规范类型对应于算法中用于描述ECMAScript语言构造和ECMAScript语言类型的语义的元值。规范类型包括，Reference, List, Completion, Property Descriptor, Lexical Environment, Environment Record以及Data Block。规范类型的值是规范里才有的，在ECMAScript实现中没有必要与任何具体的实体相对应。规范类型的值也许被用来描述ECMAScript表达式解析后的中间结果，但是这样的值不能被存储作为ECMAScript语言变量的对象属性或值的一部分。 6.2.1 List和Record规范类型 List类型被用来解释在new表达式中对于argument lists（参考12.3.6）的解析，以及在函数调用中，或者在其它需要一个简单的有序的值的list的算法的地方。List类型的值是简单的包含各自list元素的有序序列。这些序列可能是任意的长度。一个list中的元素可以通过0到某个区间内的索引来随机访问。为了记数方便，一个类数组语法可以被用来访问List的元素。例如，arguments[2]是arguments List中第三个元素的简写。 为了本规范的记法方便，可以用一个字面量语法来表示一个新的List值。例如，« 1, 2 »定义了一个有2个元素的List值，每个元素都被实例化为了一个具体的值。一个新的空的List可以用« »表示。 Record类型被用来描述在本规范算法内的数据的聚合。一个Record类型的值包含一个或者多个命名的字段。每个字段的值要么是一个ECMAScript值，要么是一个用一个关联Record类型的名称表示的抽象值。字段名总是双方括号闭合的，例如[[Value]]。 为了本规范的方便，一个类似对象字面量的语法被用来表示一个Record值。例如，{[[Field1]]: 42, [[Field2]]: false, [[Field3]]: empty}定义了一个包含3个字段的Record值，其中的每一个都被实例化为了一个具体的值。字段名的顺序是不重要的。任何没有被显式地列出的字段都被认为是不存在的。 在规范的文本和算法中，点符号也许会被用来指向一个具体的一个Record值的某个特定字段。例如，如果R是一个在之前的段落中出现的record，那么R.[[Field2]]代表“R中名称叫[[Field2]]的字段”的简写。 可以命名常用记录字段组合的模式，并且该名称可以用作文字记录值的前缀，以标识所描述的特定聚合类型。例如： PropertyDescriptor {[[Value]]: 42, [[Writable]]: false, [[Configurable]]: true}。 6.2.2 Set和关系规范类型 Set类型被用来解释在内存模型中无序元素的集合。Set类型的值是简单的元素的集合，其中没有任何元素出现一次以上。 元素可以添加到集合中或从集合中删除。集可以有交集，并集和补集。 关系类型用于解释对集合的约束。关系类型的值是其值域中的有序值对的集合。例如，事件关联是一组有序的事件对。对于一个关系R以及在R的值域中的两个值a和b，a R b是有序对(a, b)是R的成员的简写。 满足这些条件的最小关系。 严格的偏序关系，即是满足以下条件的关系值R。 ​ 对于在R的域中所有a,b,c： ​ 1、不存在 a R a， ​ 2、如果 a R b，并且 b R c，所以 a R c 注1：以上两个特性依次称为反自反性和传递性。 严格的全序关系，即是满足以下条件的关系值R。 ​ 对于在R的域中所有a,b,c： ​ 1、a等于b或 a R b 或 b R a ​ 2、不存在 a R a ​ 3、如果 a R b，并且 b R c，所以 a R c 注2：以上三个特性依次称为总体性，反自反性和传递性。 6.2.3 完成记录规范类型 完成类型是一个记录，用于解释某些执行非外部控制转移语句（例如break, continue, return, throw）运行时值和控制流的传播。 完成类型的值是记录值，它们的字段定义在表8中。这样的值被称为完成记录。 域名 值 含义 [[Type]] normal, break, continue, return, throw其中的一个 完成值的类型 [[Value]] 一个ECMAScript语言值或者空值 产生的值 [[Target]] 任意ECMAScript字符串或者空值 指定的控制转移的目标标签/元素 6.2.3.1 Await 算法步骤如下 ​ 1、把 Await(value)设为completion 意思是： 1. 令 asyncContext 成为运行时执行上下文 1. 令 promise 成为 ? PromiseResolve(%Promise%, « value »). 2. 令 stepsFulfilled 成为 Await Fulfilled Functions 中定义的算法步骤 3. 令 onFulfilled 成为 CreateBuiltinFunction(stepsFulfilled, « [[AsyncContext]] »). 4. 设置 onFulfilled。设置 asyncContext 的 [[AsyncContext]] 。 5. 令 stepRejected 成为 Await Rejected Functions 中定义的算法步骤。 6. 令 onRejected 成为 CreateBuiltinFunction(stepsRejected, « [[AsyncContext]] ») 7. 设置 onRejected。设置 asyncContext 的 [[AsyncContext]] 。 8. 执行 ! PerformPromiseThen(promise, onFulfilled, onRejected). 9. 从执行上下文堆栈中删除 asyncContext，并将位于执行上下文堆栈顶部的执行上下文恢复为正在运行的执行上下文。 10. 设置asyncContext的代码求值状态，以使求值在完成完成后恢复时，将执行调用Await的算法的以下步骤，并提供完成功能。 11. 返回。 12. 注意：这将返回到对操作进行评估的操作，该操作之前已恢复对asyncContext的求值。 其中上述步骤中除完成之外的所有变量都是短暂的，并且仅在与Await有关的步骤中可见。 注意 Await可以与 ? 和 ! 前缀组合起来，例如 令 result 成为 ? Await(value). 意思是： 令 result 成为 Await(value). ReturnIfAbrupt(result). 6.2.3.1.1 Await Fulfilled 函数 Await Fulfilled 是一个匿名内置函数，用作await规范的一部分，以将promise完成值作为正常完成传递给调用方。每个Await Fulfilled函数都有一个[[AsyncContext]]内部插槽。 当使用参数值调用Await Fulfilled 的函数时，将执行以下步骤： 1. 令 F 为活动函数对象。 2. 令 asyncContext 成为 F.[[AsyncContext]]. 3. 令 prevContext 成为运行时执行上下文. 4. 挂起 prevContext. 5. 将asyncContext推送到执行上下文堆栈；现在asyncContext是正在运行的执行上下文。 6. 使用 NormalCompletion(value) 作为暂停 asyncContext 的操作的结果，恢复其暂停的求值。 7. 断言：到达此步骤时，asyncContext已经从执行上下文堆栈中删除，并且prevContext是当前正在运行的执行上下文。 8. 返回 undefined Await fulfilled 函数的“长度”属性为1。 6.2.3.1.2 Await Rejected 函数 Await Rejected 函数是一个匿名内置函数，用作 Await 规范设备的一部分，以将Promise拒绝原因作为突然抛出完成传递给调用方。每个Await Rejected 的函数都有一个[[AsyncContext]]内部插槽。 当使用参数reason调用Await Rejected 函数时，将执行以下步骤： 令 F 为活动函数对象。 令 asyncContext 成为 F.[[AsyncContext]]. 令 prevContext 成为运行时执行上下文. 挂起 prevContext. 将asyncContext推送到执行上下文堆栈；现在asyncContext是正在运行的执行上下文。 使用 ThrowCompletion(reason) 作为暂停 asyncContext 的操作的结果，恢复其暂停的求值。 断言：到达此步骤时，asyncContext已经从执行上下文堆栈中删除，并且prevContext是当前正在运行的执行上下文。 返回 undefined Await Rejected 函数的“长度”属性为1。 6.2.3.2 NormalCompletion 抽象操作NormalCompletion具有单个参数，例如： 返回 NormalCompletion(argument) 是一种缩写，定义如下： Return Completion { [[Type]]: normal, [[Value]]: argument, [[Target]]: empty } 6.2.3.3 ThrowCompletion 抽象操作ThrowCompletion具有单个参数，例如： 返回 ThrowCompletion(argument) 是一种缩写，定义如下： Return Completion { [[Type]]: throw, [[Value]]: argument, [[Target]]: empty } 6.2.3.4 UpdateEmpty ( completionRecord, value ) 抽象操作UpdateEmpty（带有参数completeRecord和value）执行以下步骤： 断言: 如果 completionRecord.[[Type]] 既不是 return 也不是 throw, 同时 completionRecord.[[Value]] 不是 空. 如果 completionRecord.[[Value]] 不为空, 返回 Completion(completionRecord). 返回 Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord. [[Target]] }. 6.2.4 引用规范类型 注意：引用类型被用来解释像delete，typeof，赋值等操作符以及super关键字，以及其它语言特性的行为。例如，赋值操作左值应该是一个引用。 一个引用是一个解析后的名称或者属性绑定。一个引用包含三个组成部分，即基值，引用名称，以及严格引用标志（布尔值）。基础值的组件是undefined，Object，Boolean，String，Symbol，Number，或者一个环境记录。 基值是 undefined 表示此引用不可以解析为一个绑定。引用名称是一个字符串或Symbol值。 一个super引用是一个被用来表示一个用super关键字表示的名称绑定的引用。一个super引用有额外的thisValue组件，它的基础值组件将永远不能是一个环境记录。 super引用是一种引用，用于表示使用super关键字表示的名称绑定。super引用具有附加的thisValue组件，其基础值组件永远不会是环境记录。 在本规范中，以下抽象操作用于对引用进行操作： 6.2.4.1 GetBase ( V ) 断言: Type(V) 是一个引用。 返回 V 的基值。 6.2.4.2 GetReferencedName ( V ) 断言：Type(V) 是一个引用。 返回 V 的引用名称。 6.2.4.3 IsStrictReference ( V ) 断言：Type(V) 是一个引用。 返回 V 的严格引用标志。 6.2.4.4 HasPrimitiveBase ( V ) 断言：Type(V) 是一个引用。 如果Type（V的基值）是 Boolean、String、Symbol或Number，那么返回 true；否则返回false。 6.2.4.5 IsPropertyReference ( V ) 断言：Type(V) 是一个引用。 如果基值是个 Object 或 HasPrimitiveBase(V) 是 true，那么返回 true；否则返回 false。 6.2.4.6 IsUnresolvableReference ( V ) 断言：Type(V) 是一个引用。 如果基值是Undefined，那么返回true；否则返回false 6.2.4.7 IsSuperReference ( V ) 断言：Type(V) 是一个引用。 如果 V 有 thisValue，则返回 true；否则返回false。 6.2.4.8 GetValue ( V ) ReturnIfAbrupt(V)。 如果Type(V)不是引用，返回V。 令base为GetBase(V)。 如果IsUnresolveableReference(V)是true，抛出一个ReferenceError异常。 如果 IsPropertyReference(V)是 true，那么 如果 HasPrimitiveBase(V) 是 true，那么 断言：在此情况下，base不可能是 undefined 或 null 设定 base 为 ! ToObject(base) 返回 ? base.[Get]\\, GetThisValue(V)). 否则，base 必须是一个环境记录项， 返回 ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (参见 8.1.1) 注意 在上述抽象操作和普通对象[[Get]]内部方法之外，无法访问在步骤5.1.2中创建的对象。实现可能要选择避免实际创建对象。 6.2.4.9 PutValue ( V, W ) ReturnIfAbrupt(V)。 ReturnIfAbrupt(W)。 如果Type(V)不是引用，抛出一个ReferenceError异常。 令base为GetBase(V)。 如果IsUnresolvableReference(V)是 true，那么 如果 IsStrictReference(V) 是 true，那么 抛出 ReferenceError 异常。 令 globalObj 为 GetGlobalObject()。 返回 ? Set(globalObj, GetReferencedName(V), W, false)。 否则如果 IsPropertyReference(V)，那么 如果 HasPrimitiveBase(V) 是 false，那么 在此情况下，base不可能是 undefined 或 null 设定 base 为 ! ToObject(base) 令 succeeded 为 ? base.[Set], W, GetThisValue(V))。 如果 successded 是 false，同时 IsStrictReference(V) 是 true，抛出 TypeError 异常。 返回。 否则，base必须是一个环境记录项， 返回 ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (参见8.1.1)。 注意 在上述抽象操作和普通对象[[Get]]内部方法之外，无法访问在步骤5.1.2中创建的对象。实现可能要选择避免实际创建对象。 6.2.4.10 GetThisValue ( V ) 断言: IsPropertyReference(V) 是 true。 如果 IsSuperReference(V) 是true，则 返回引用 V 的 thisValue 值。 返回 GetBase(V)。 6.2.4.11 InitializeReferencedBinding ( V, W ) ReturnIfAbrupt(V)。 ReturnIfAbrupt(W)。 断言：Type(V)是引用。 断言：IsUnresolvableReference(V) 是 false。 令 base 为 GetBase(V)。 断言：base是一个环境记录项。 返回 base.InitializeBinding(GetReferencedName(V), W)。 6.2.5 属性描述符规范类型 属性描述符类型是用来解释命名属性具体操作的特性集。属性描述符类型的值是记录项，由命名字段组成，每个字段的名称是一个特性名并且它的值是一个相应的特性值，这些特性指定在6.1.7.1。此外，任何字段都可能存在或不存在。 根据是否存在或使用了某些字段，属性描述符的值可进一步划分为数据属性描述符和访问器属性描述符。一个数据属性描述符里包括叫做 [[Value]] 或 [[Writable]]的字段。一个访问器属性描述符里包括叫做 [[Get]]或 [[Set]]的字段。任何属性描述都可能有名为 [[Enumerable]] 和 [[Configurable]] 的字段。一个属性描述符不能同时是数据属性描述符和访问器属性描述符；但是，它可能二者都不是。一个通用属性描述符是，既不是数据属性描述符也不是访问器属性描述符的属性描述符值。一个完全填充属性描述符是访问器属性描述符或数据属性描述符，并且拥有 表2 或 表2 里定义的所有属性特性对应的字段。 在本规范中，以下抽象操作用于对属性描述符值进行操作： 6.2.5.1 IsAccessorDescriptor ( Desc ) 使用属性描述符Desc调用抽象操作IsAccessorDescriptor时，将执行以下步骤： 如果 Desc 是 undefined，返回 false。 如果Desc.[[Get]] 和 Desc.[[Set]] 都不存在，则返回 false。 返回 true。 6.2.5.2 IsDataDescriptor ( Desc ) 使用属性描述符Desc调用抽象操作IsDataDescriptor时，将执行以下步骤： 如果 Desc 是 undefined，那么返回 false。 如果 Desc.[[Value]] 和 Desc.[[Writable]] 都不存在，则返回 false。 返回 true。 6.2.5.3 IsGenericDescriptor ( Desc ) 当用属性描述符 Desc 调用抽象操作 IsGenericDescriptor，采用以下步骤： 如果 Desc 是 undefined，那么返回 false。 如果 IsAccessorDescriptor(Desc) 和 IsDataDescriptor(Desc) 都是 false，则返回 true。 返回 false。 6.2.5.4 FromPropertyDescriptor ( Desc ) 当用属性描述符 Desc 调用抽象操作 FromPropertyDescriptor，采用以下步骤： 如果 Desc 是 undefined，那么返回 undefined。 令 obj 为 ObjectCreate(%ObjectPrototype%)。 断言：obj是没有自己属性的可扩展普通对象。 如果 Desc 有[[ Writable ]]字段，那么 执行 CreateDataProperty(obj, \"value\", Desc.[[Value]])。 如果 Desc 有[[ Writable ]]字段，那么 执行 CreateDataProperty(obj, \" Writable \", Desc.[[Value]])。 如果 Desc 有[[ Get ]]字段，那么 执行 CreateDataProperty(obj, \"Get\", Desc.[[Value]])。 如果 Desc 有[[ Set ]]字段，那么 执行 CreateDataProperty(obj, \" Set \", Desc.[[Value]])。 如果 Desc 有[[ Enumerable ]]字段，那么 执行 CreateDataProperty(obj, \" Enumerable \", Desc.[[Value]])。 如果 Desc 有[[ Configurable ]]字段，那么 执行 CreateDataProperty(obj, \" Configurable \", Desc.[[Value]])。 断言：以上所有 CreateDataProperty 操作返回 true 返回 obj 6.2.5.5 ToPropertyDescriptor ( Obj ) 如果 Type(Obj) 不是对象, 抛出TypeError异常。 令desc为一个新的属性描述符，该属性描述符最初没有字段。 令hasEnumerable为 ? HasProperty(Obj, \"enumerable\")。 如果hasEnumerable是true，那么 令enumerable为ToBoolean(? Get(Obj, \"enumerable\"))。 将 desc.[[Enumerable]] 设置为 enumerable。 令 hasConfigurable 为 ? HasProperty(Obj, \" configurable \")。 如果 hasConfigurable 是true，那么 令 configurable 为ToBoolean(? Get(Obj, \" configurable \"))。 将 desc.[[ Configurable ]] 设置为 configurable . 令 hasValue 为 ? HasProperty(Obj, \"value\")。 如果 hasValue 是true，那么 令 value 为 ? Get(Obj, \"value\")。 将 desc.[[ Value ]] 设置为 Value。 令 hasWritable 为 ? HasProperty(Obj, \" writable \")。 如果 hasWritable 是true，那么 令 writable 为ToBoolean(? Get(Obj, \" writable \"))。 将 desc.[[ Writable ]] 设置为 writable 。 令 hasGet 为 ? HasProperty(Obj, \" get \")。 如果 hasGet 是true，那么 令 getter 为 Get (? Get(Obj, \" get \"))。 如果 IsCallable(getter) 是 false 同时 getter 不是 undefined, 抛出 TypeError 异常. 将 desc.[[ Get ]] 设置为 getter 。 令 hasSet 为 ? HasProperty(Obj, \" set \")。 如果hasGet 是true，那么 令 setter 为 ? Get(Obj, \"set\")。 如果 IsCallable( setter ) 是 false 同时 setter 不是 undefined, 抛出 TypeError 异常. 将 desc.[[ Set ]] 设置为 setter 。 如果有 desc.[[Get]] 或者有 desc.[[Set]]，那么 如果有 desc.[[Value]] 或者有 desc.[[Writable]], 抛出 TypeError 异常. 返回 desc 6.2.5.6 CompletePropertyDescriptor ( Desc ) 当用属性描述符 Desc 调用抽象操作 CompletePropertyDescriptor，采用以下步骤： 断言：Desc 是属性描述符。 令 like 为 Record { [[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false }. 如果 IsGenericDescriptor(Desc) 为 true 或者 IsDataDescriptor(Desc) 为 true，那么 如果 Desc 没有 [[Value]] 字段, 将 Desc.[[Value]] 设置为 like.[[Value]]。 如果 Desc 没有 [[Writable]] 字段, 将 Desc.[[Writable]] 设置为 like.[[Writable]]。 否则。 如果 Desc 没有 [[ Get ]] 字段, 将 Desc.[[ Get ]] 设置为 like.[[ Get ]]。 如果 Desc 没有 [[ Set ]] 字段, 将 Desc.[[ Set ]] 设置为 like.[[ Set ]]。 如果 Desc 没有 [[ Enumerable ]] 字段, 将 Desc.[[ Enumerable ]] 设置为 like.[[ Enumerable ]]。 如果 Desc 没有 [[ Configurable ]] 字段, 将 Desc.[[ Configurable ]] 设置为 like.[[ Configurable ]]。 返回 Desc 6.2.6 词法环境和环境记录项规范类型 词法环境和环境记录项类型用于说明在嵌套的函数或块中的名称解析行为。这些类型和他们的操作定义在第 8.1 章 6.2.7 数据块 数据块规范类型用于描述一个独特的且不可变的基于字节（8bit）数字值序列。使用固定数量的字节创建数据块值，每个字节的初始值均为0。 为方便起见，在本规范中，类似数组的语法可用于访问数据块值的各个字节。该表示法将数据块值表示为起源于0的整数索引字节序列。例如，如果db是5字节的数据块值，则db[2]可用于访问其第3个字节。 可以同时从多个代理引用的驻留在内存中的数据块称为共享数据块。共享数据块的标识（为了进行相等性测试共享数据块值）是无地址的：它不绑定到该块在任何进程中映射到的虚拟地址，而是绑定到内存中的位置集代表该块。仅当两个数据块所包含的位置集合相等时，它们才相等。否则，它们不相等，并且它们包含的位置集的交集为空。最后，可以将共享数据块与数据块区分开。 内存模型使用共享数据块事件定义共享数据块的语义。下面的抽象操作介绍了共享数据块事件， 以及在内存模型上解析语义和事件语义的接口的行为 。事件形成候选执行，内存模型在该候选执行上充当过滤器。请查阅内存模型以获取完整的语义。 共享数据块事件由记录建模，该记录在内存模型中定义。 在本规范中，以下抽象操作用于对数据块值进行操作： 6.2.7.1 CreateByteDataBlock ( size ) 当用整数size参数调用抽象操作 CreateByteDataBlock ，采用以下步骤： 断言：size ≥ 0。 令db为一个由 size 字节组成的新数据块值。如果不可能创建这样的数据块，抛出 RangeError 异常。 将所有db 的字节大小设为0。 返回 db。 6.2.7.2 CreateSharedByteDataBlock ( size ) 当用整数size参数调用抽象操作 CreateSharedByteDataBlock ，采用以下步骤： 断言：size ≥ 0。 令db为一个由 size 字节组成的新共享数据块值。如果不可能创建这样的共享数据块，抛出 RangeError 异常。 令 execution 成为当前代理记录项的 [[CandidateExecution]] 字段 令 eventList 成为 execution 中元素的 [[EventList]] 字段。 [[AgentSignifier]]是AgentSignifier()的[[EventsRecords]]。 令 zero 为 « 0 »。 对于db的每个索引i，执行 添加 WriteSharedMemory { [[Order]]: \"Init\", [[NoTear]]: true, [[Block]]: db, [[ByteIndex]]: i, [[ElementSize]]: 1, [[Payload]]: zero } 到 eventList 返回 db。 6.2.7.3 CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count ) 当调用抽象操作 CreateSharedByteDataBlock ，采用以下步骤： 断言：fromBlock和toBlock是不同的数据块或共享数据块值。 断言：fromIndex，toIndex和count是≥0的整数 令fromSize为fromBlock中的字节数。 断言：fromIndex + count ≤ fromSize。 令 toSize 为 toBlock 中的字节数。 断言： toIndex + count ≤ toSize。 当 count > 0 重复 如果 fromBlock 是共享数据块，那么 令 execution 成为当前代理记录项的 [[CandidateExecution]] 字段。 令 eventList 成为 execution 中元素的 [[EventList]] 字段。 [[AgentSignifier]]是AgentSignifier()的[[EventsRecords]]。 令 bytes 为长度为1的 List，包含不确定地选择的字节值。 注意：在实现中，bytes 是基础硬件上非原子读取指令的结果。非确定性是内存模型的语义规定，用于描述具有弱一致性的硬件的可观察行为。 令 readEvent 为 ReadSharedMemory { [[Order]]: \"Unordered\", [[NoTear]]: true, [[Block]]: fromBlock, [[ByteIndex]]: fromIndex, [[ElementSize]]: 1 }。 添加 readEvent 到 eventList。 添加 Chosen Value Record { [[Event]]: readEvent, [[ChosenValue]]: bytes } 到 execution。 如果 toBlock 是共享数据块，那么 添加 WriteSharedMemory { [[Order]]: \"Unordered\", [[NoTear]]: true, [[Block]]: toBlock, [[ByteIndex]]: toIndex, [[ElementSize]]: 1, [[Payload]]: bytes } 到 eventList。 或者 将 toBlock[toIndex] 设置为 bytes[0] 否则， 断言： toBlock 不是共享数据块。 将toBlock [toIndex]设置为fromBlock [fromIndex]。 将toIndex和fromIndex分别增加1。 count递减1. 返回 NormalCompletion(empty)。 本规范的算法操作的值每一个都有其相应的类型。 可能的值类型正是本节中定义的值类型。类型又进一步分为ECMAScript语言类型（language types）以及规范类型（specification types）。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,ECMAScript数据类型和值,ecmascript-data-types-and-values "},"abstract-operations.html":{"url":"abstract-operations.html","title":"7 抽象操作","keywords":"","body":"7 抽象操作 这些抽象操作不是语言本身的一部分；它们被定义在这里是为了协助语言的语义规范。 在本规范中定义了其他更专门的抽象操作。 7.1 类型转换 ECMAScript运行环境会在需要时执行自动类型转换。定义一套关于转换的抽象操作有助于阐明某些结构的语义。这些关于转换的抽象操作是多态的，它们可以接受任何ECMAScript语言类型，但不能接受规范类型。 7.1.1 ToPrimitive ( input [ , PreferredType ] ) ToPrimitive 抽象操作接受一个值，和一个可选的期望类型作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原语类型，可以使用可选的期望类型来暗示那个类型。根据下面的算法完成转换： 断言：input是一个ECMAScript语言值。 如果 Type(input) 是对象，那么 如果当前没有 PreferredType ，令 hint 为\" default \"。 否则如果 PreferredType 是提示字符串，令 hint 为 \"string\"。 否则 PreferredType 是提示数字，令 hint 为 \"number\"。 令 exoticToPrim 为 ? GetMethod(input, @@toPrimitive) 。 如果 exoticToPrim 不是 undefined，那么 令 result 为 ? Call(exoticToPrim, input, « hint ») 。 如果 Type(result) 不是对象，返回 result。 抛出 TypeError 异常。 返回 input 注意 当不带提示地调用ToPrimitive时，通常它的行为就像提示是Number。但是，对象可以通过定义@@ toPrimitive方法来替代此行为。在本规范中定义的对象中，只有日期对象（请参见20.3.4.45）和符号对象（请参见19.4.3.5）会覆盖默认的ToPrimitive行为。日期对象不将提示视为字符串。 7.1.1.1 OrdinaryToPrimitive ( O, hint ) 当使用参数O和hint调用抽象操作OrdinaryToPrimitive时，将执行以下步骤： 断言：Type(O) 是对象。 断言：Type(hint) 是字符串，同时它的值既不是\"string\"也不是\"number\"。 如果 hint 是 \"string\"，那么 令 methodNames 为 « \"toString\", \"valueOf\" »。 否则， 令 methodNames 为 « \"valueOf\", \"toString\" »。 对于methodNames中按List顺序的每个名称，请执行 令 method 为 ? Get(O, name)。 如果 IsCallable(method) 是 true，那么 令 result 为 ? Call(method, O)。 如果 Type(result) 不是 Object，返回 reuslt。 抛出一个 TypeError 异常 7.1.2 ToBoolean ( argument ) 根据表9，抽象操作ToBoolean将参数转换为Boolean类型的值： 输入类型 结果 未定义 false 空值 false 布尔值 结果等于输入的参数（不转换）。 数值 如果参数是 +0, -0, 或 NaN，结果为 false ；否则结果为 true。 字符串 如果参数是空字符串（其长度为零），结果为 false，否则结果为 true。 Symbol true 对象 true 7.1.3 ToNumber ( argument ) 根据表10，抽象操作ToNumber将参数转换为Number类型的值： 输入类型 结果 未定义 NaN 空值 +0 布尔值 如果参数是 true，结果为 1。如果参数是 false，此结果为 +0。 数字 结果等于输入的参数（不转换）。 字符串 参见下文的文法和注释。 Symbol 抛出TypeError异常 对象 应用下列步骤：1. 令primValue为 ToPrimitive(输入参数, 暗示数值类型)。2. 返回 ? ToNumber(primValue)。 7.1.3.1 对字符串类型应用 ToNumber 对字符串应用 ToNumber 时，对输入字符串应用如下文法。输入的String解释为一系列UTF-16编码的代码点。如果此文法无法将字符串解释为 StringNumericLiteral 的扩展，那么 ToNumber 的结果为 NaN。 注意 1 该语法的结尾符号全部由Unicode基本多语言平面（BMP）中的字符组成。因此，如果字符串包含任何成对或不成对的前导或尾随替代代码单元，则ToNumber的结果将为NaN。 StringNumericLiteral ::: StrWhiteSpaceopt StrWhiteSpaceopt StringNumericLiteralopt StrWhiteSpaceopt StrWhiteSpace ::: StrWhiteSpaceChar StrWhiteSpaceopt StrWhiteSpaceChar ::: WhiteSpace LineTerminator StrNumericLiteral ::: StrDecimalLiteral BinaryIntegerLiteral OctalIntegerLiteral HexIntegerLiteral StrDecimalLiteral ::: StrUnsignedDecimalLiteral + StrUnsignedDecimalLiteral - StrUnsignedDecimalLiteral StrUnsignedDecimalLiteral ::: Infinity DecimalDigits . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalDigits ExponentPartopt 上面未明确定义的所有语法符号都具有在词法语法中用于数字词法的定义 注意 2 需要注意到 StringNumericLiteral 和 NumericLiteral 语法上的不同： StringNumericLiteral 的前后可以有若干的空白字符或行终止符。 十进制的 StringNumericLiteral 可有任意位数的 0 在前头。 十进制的 StringNumericLiteral 可有指示其符号的 + 或 - 前缀。 空的，或只包含空白的 StringNumericLiteral 會被转换为 +0。 Infinity 和 -Infinity 会被识别为 StringNumericLiteral 而不是 NumericLiteral. 7.1.3.1.1 运行时语义: MV 字符串到数字值的转换，大体上类似于判定 NumericLiteral 的数字值（参见 11.8.3），不过有些细节上的不同，所以，这里给出了把 StringNumericLiteral 转换为数值类型的值的全部过程。这个值分两步来判定：首先，从 StringNumericLiteral 中导出数学值；第二步，以下面所描述的方式对该数学值进行舍入。下文未提供的任何语法符号上的MV是11.8.3.1中定义的该符号的MV StringNumericLiteral ::: [empty] 的数学值是 0。 StringNumericLiteral ::: StrWhiteSpace 的数学值是 0。 StringNumericLiteral ::: StrWhiteSpaceopt StringNumericLiteral StrWhiteSpaceopt 的数学值是里面的 StringNumericLiteral 部分，无论前后是否存在空白。 StrNumericLiteral ::: StrDecimalLiteral 的数学值是 StrDecimalLiteral 的数学值。 StrNumericLiteral ::: BinaryIntegerLiteral 的数学值是 BinaryIntegerLiteral 的数学值。 StrNumericLiteral ::: OctalIntegerLiteral 的数学值是 OctalIntegerLiteral 的数学值。 StrNumericLiteral ::: HexIntegerLiteral 的数学值是 HexIntegerLiteral 的数学值。 StrDecimalLiteral ::: StrUnsignedDecimalLiteral 的数学值是 StrUnsignedDecimalLiteral 的数学值。 StrDecimalLiteral ::: + StrUnsignedDecimalLiteral 的数学值是 StrUnsignedDecimalLiteral 的数学值。 StrDecimalLiteral ::: - StrUnsignedDecimalLiteral 的数学值是 StrUnsignedDecimalLiteral 的数学值的负数。 （需要注意的是，如果 StrUnsignedDecimalLiteral 的数学值是 0, 其负数也是 0。下面中描述的舍入规则会合适地处理小于数学零到浮点数 +0 或 -0 的变换。） StrUnsignedDecimalLiteral ::: Infinity 的数学值是 10^10000（一个大到会舍入为 +∞ 的值）。 StrUnsignedDecimalLiteral ::: DecimalDigits . 的数学值是 DecimalDigits 的数学值。 StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits 的数学值是第一个 DecimalDigits 的数学值加（第二个 DecimalDigits 的数学值乘以 10^-n），这里的 n 是第二个 DecimalDigits 的字符数量。 StrUnsignedDecimalLiteral ::: DecimalDigits . ExponentPart 的数学值是 DecimalDigits 的数学值乘以 10^e, 这里的 e 是 ExponentPart 的数学值。 StrUnsignedDecimalLiteral ::: DecimalDigits . DecimalDigits ExponentPart 的数学值是（第一个 DecimalDigits 的数学值加（第二个 DecimalDigits 的数学值乘以 10^-n））乘以 10^e，这里的 n 是 第二个 DecimalDigits 中的字符个数，e 是 ExponentPart 的数学值。 StrUnsignedDecimalLiteral ::: . DecimalDigits 的数学值是 DecimalDigits 的数学值乘以 10^-n，这里的 n 是 DecimalDigits 中的字符个数。 StrUnsignedDecimalLiteral ::: . DecimalDigits ExponentPart 的数学值是 DecimalDigits 的数学值乘以 10^e-n，这里的 n 是 DecimalDigits 中的字符个数，e 是 ExponentPart 的数学值。 StrUnsignedDecimalLiteral ::: DecimalDigits 的数学值是 DecimalDigits 的数学值。 StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart 的数学值是 DecimalDigits 的数学值乘以 10^e，这里的 e 是 ExponentPart 的数学值。 一旦字符串数值常量的数学值被精确地确定，接下来就会被舍入为数值类型的一个值。如果数学值是 0，那么舍入值为 +0，否则如果字符串数值常量中第一个非空白字符是 ‘-’，舍入值为 -0。对于其它情况，舍入后的值必须是其数学值的数字值（6.1.6定义）。如果该字面量包含一个 StrUnsignedDecimalLiteral 且该字面量大于 20 位有效数字，则此数字的值是下面两种之一：一是将其 20 位之后的每个数位用 0 替换，产生此字符串解析出的数学值的数字值；二是将其 20 位之后的每个数位用 0 替换，并在第 20 位有效数字加一，产生此字符串解析出的数学值的数字值。判断一个数位是否为有效数位，首先它不能是 ExponentPart 的一部分，且 它不是 0；或 它的左边是一个非零值，右边是一个不在 ExponentPart 中的非零值。 7.1.4 ToInteger ( argument ) ToInteger 抽象操作将其参数转换为整数值，此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN 则返回 +0。 如果 number 是 +0、 -0、 +∞ 或 -∞ 则返回 number。 令 int 符号与 number 相同，大小为 floor(abs(number))。 7.1.5 ToInt32 ( argument ) ToInt32 抽象操作将其参数转换为 在 -2^31 到 2^31-1 闭区间内的 2^32 个整数中的任意一个。 此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN、 +0、 -0、 +∞ 或 -∞ 则返回 +0。 令 int 符号与 number 相同，大小为 floor(abs(number))。 令 int32bit 为 int modulo 2^32。 如果 int32bit ≥ 2^31 则返回 int32bit-2^32 否则返回 int32bit。 注意：上面对 ToInt32 ToInt32 抽象操作是幂等的：对同一个值调用一次和调用两次这个操作会得到同样的结果。 对于任意的 x 值，ToInt32(ToUint32(x)) 总是等价于 ToInt32(x)。（它延续了后者将 +∞ 和 -∞ 映射到 +0 的性质） ToInt32 会将 -0 映射到 +0。 7.1.6 ToUint32 ( argument ) ToUint32 抽象操作将其参数转换为 在 0 到 2^32-1 闭区间内的 2^32 个整数中的任意一个。 此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN、 +0、 -0、 +∞ 或 -∞ 则返回 +0。 令 int 符号与 number 相同，大小为 floor(abs(number))。 令 int32bit 为 int modulo 2^32。 返回 int32bit。 注：上面对 ToUint32 ToUint32 与 ToInt32 之间唯有 第5步 不同。 ToUint32 抽象操作是幂等的：对同一个值调用一次和调用两次这个操作会得到同样的结果。 对于任意的 x 值，ToUint32(ToInt32(x)) 总是等价于 ToUint32(x)。（它延续了后者将 +∞ 和 -∞ 映射到 +0 的性质） ToUint32 会将 -0 映射到 +0。 7.1.7 ToInt16 ( argument ) ToInt16 抽象操作将其参数转换为 在 -32768 到 32767 闭区间内的 2^16 个整数中的任意一个。 此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN、 +0、 -0、 +∞ 或 -∞ 则返回 +0。 令 int 符号与 number 相同，大小为 floor(abs(number))。 令 int16bit 为 int modulo 2^16； 如果 int16bit ≥ 2^16 则返回 int16bit-2^16 否则返回 int16bit。 7.1.8 ToUint16 ( argument ) ToUint16 抽象操作将其参数转换为 在 0 到 2^16-1 闭区间内的 2^16 个整数中的任意一个。 此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN、 +0、 -0、 +∞ 或 -∞ 则返回 +0。 令 int 符号与 number 相同，大小为 floor(abs(number))。 令 int16bit 为 int modulo 2^16。 返回 int16bit。 注意：上面对于ToUint16 ToUnit32与ToUinit16唯有第4步用2^16代替2^32不同 ToUinit16会将 -0 映射到 +0 7.1.9 ToInt8 ( argument ) ToInt8 抽象操作将其参数转换为 在 -128 到 127 闭区间内的 2^8 个整数中的任意一个。 此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN、 +0、 -0、 +∞ 或 -∞ 则返回 +0。 令 int 符号与 number 相同，大小为 floor(abs(number))。 令 int8bit 为 int modulo 2^8； 如果 int8bit ≥ 2^7 则返回 int8bit-2^8 否则返回 int8bit。 7.1.10 ToUint8 ( argument ) ToUint16 抽象操作将其参数转换为 在 0 到 255 闭区间内的 **2^8 个整数中的任意一个。 此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN、 +0、 -0、 +∞ 或 -∞ 则返回 +0。 令 int 符号与 number 相同，大小为 floor(abs(number))。 令 int8bit 为 int modulo 2^8。 返回 int8bit。 7.1.11 ToUint8Clamp ( argument ) ToUint16 抽象操作将其参数转换为 在 0 到 255 闭区间内的 **2^8 个整数中的任意一个。 此运算符功能如下所示： 令 number 为 ? ToNumber(argument)。 如果 number 是 NaN、 +0、 -0、 +∞ 或 -∞ 则返回 +0。 如果 number ≤ 0，返回 +0。 如果 number ≥ 255，返回 255 令 f 为 floor(number) 如果 f + 0.5 如果 number 如果 f 是 奇数, 返回 f + 1。 返回 f 7.1.12 ToString ( argument ) ToString 运算符根据下表将其参数转换为字符串类型的值： 输入类型 结果 未定义 \"undefined\" 空值 \"null\" 布尔值 如果参数是 true，那么结果为 \"true\"。如果参数是 false，那么结果为 \"false\"。 数值 返回 NumberToString(argument) 字符串 返回输入的参数（不转换）。 A 抛出一个TypeError异常 对象 应用下列步骤：1. 令 primValue 为 ? ToPrimitive(argument, hint String)。2. 返回 ? ToString(primValue)。 7.1.12.1 NumberToString ( m ) ToString 抽象操作将数字 m 转换为字符串格式的给出如下所示： 果 m 是 NaN，返回字符串 \"NaN\"。 如果 m 是 +0 或 -0，返回字符串 \"0\"。 如果 m 小于零，返回连接 \"-\" 和 ! NumberToString(-m) 。 如果 m 无限大，返回字符串 \"Infinity\"。 否则，令 n、k 和 s 皆为整数，且满足 k ≥ 1 且 10^(k-1) ≤ s 10^k 、 s×10(n-k) 的数字值为 m 且 k 足够小。注意 k 是 s 的十进制位数。s 不能被 10 整除，且 s 的至少要求的有效数字位数不一定要被这些标准唯一确定。 如果 k ≤ n ≤ 21，返回以下字符串连接： 由 k 个 s 在十进制表示中的数字组成的字符串（有序的，开头没有零） n-k 个 码元为0x0030（数字\"0\"）字符。 如果 0 21，返回以下字符串连接： 由 s 在十进制表示中的、最多 n 个有效数字组成的字符串 一个码元为0x002E（小数点 \".\"） 余下的 k-n 个 s 在十进制表示中的数字。 如果 -6 0，返回以下字符串连接： 一个码元为0x0030（数字\"0\"）， 一个码元为0x002E（小数点 \".\"）， -n 个码元为0x0030（数字\"0\"）字符， k 个 s 在十进制表示中的数字。 否则，如果 k = 1，返回以下字符串连接： 由单个数字 s 组成的码元， 码元为0x002E(小写字母 \"e\")， 根据 n-1 是正或负，码元为0x002B（加号 \"+\" ）或码元为0x002D（减号 \"-\" ）， 整数 abs(n-1) 的十进制表示（没有前置的零）。 返回以下字符串连接： 由 s 在十进制表示中的、最多的有效数字组成的字符串， 一个码元为0x002E（小数点 \".\"）， 余下的是 k-1 个 s 在十进制表示中的数字， 码元为0x002E(小写字母 \"e\")， 根据 n-1 是正或负，码元为0x002B（加号 \"+\" ）或码元为0x002D（减号 \"-\" ）， 整数 abs(n-1) 的十进制表示（没有前置的零）。 注1：下面的评语可能对指导实现有用，但不是本标准的常规要求。 如果 x 是除 -0 以外的任一数字值，那么 ToNumber(ToString(x)) 与 x 是完全相同的数字值。 s 至少要求的有效数字位数并非总是由 第5步 中所列的要求唯一确定。 注：对于那些提供了比上面的规则所要求的更精确的转换的实现，我们推荐下面这个步骤 5 的可选版本，作为指导： 否则，令 n, k, 和 s 是整数，使得 k ≥ 1, 10^(k-1) ≤ s 10^k，s×10^(n-k) 的数字值是 m，且 k 足够小。如果有数倍于 s 的可能性，选择 s × 10^(n-k) 最接近于 m 的值作为 s 的值。如果 s 有两个这样可能的值，选择是偶数的那个。要注意的是，k 是 s 在十进制表示中的数字的个数，且 s 不被 10 整除。 注2：ECMAScript 的实现者们可能会发现，David M 所写的关于浮点数进行二进制到十进制转换方面的文章和代码很有用： Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis Manuscript 90-10. AT&T Bell Laboratories (Murray Hill, New Jersey). November 30, 1990. 在这里取得 http://ampl.com/REFS/abstracts.html#rounding 。有关的代码在这里 http://netlib.sandia.gov/fp/dtoa.c 还有 http://netlib.sandia.gov/fp/g_fmt.c 。这些都可在众多的 netlib 镜像站点上找到。 7.1.13 ToObject ( argument ) ToObject 抽象操作根据下表将其参数转换为对象类型的值： 输入类型 结果 未定义 抛出 TypeError 异常。 空值 抛出 TypeError 异常。 布尔值 创建一个新的 Boolean 对象，其 [[BooleanData]] 内部插槽被设为该参数的值。 数值 创建一个新的 Number 对象，其 [[NumberData]] 内部插槽被设为该参数的值。 字符串 创建一个新的 String 对象，其 [[StringData]] 内部插槽被设为该参数的值。 Symbol 创建一个新的 Symbol对象，其 [[SymbolData]] 内部插槽被设为该参数的值 对象 结果是输入的参数（不转换）。 7.1.14 ToPropertyKey ( argument ) 抽象操作ToPropertyKey将参数转换为可用作属性键的值。执行以下步骤： 令 key 成为 ? ToPrimitive(argument, hint String)。 如果 Type(key) 是 Symbol，那么 返回 key。 返回 ! ToString(key) 7.1.15 ToLength ( argument ) 抽象操作ToLength将参数转换为适合用作数组对象长度的整数。执行以下步骤： 令 len 成为 ? ToInterger(argument)。 如果 len ≤ +0, 返回 +0. 返回 ! min(len, 2^53 - 1) 7.1.16 CanonicalNumericIndexString ( argument ) 如果它是由 ToString 生成或字符串\"-0\"，抽象操作CanonicalNumericIndexString将argument转换为数值。 否则，它返回it returns undefined。 该抽象操作的功能如下: 断言：Type(argument)是字符串。 如果 argument 是 \"-0\"， 返回 -0。 令 n 为 ! ToNumber(argument) 。 如果 SameValue( ! ToString(n), argument) 是 false, 返回 undefined。 返回 n。 规范数字字符串是CanonicalNumericIndexString抽象操作不会返回undefined的任何String值。 7.1.17 ToIndex ( value ) 如果ToIndex是有效的整数索引值，则抽象操作ToIndex返回转换为数字值的value参数。此抽象操作的功能如下： 如果 value 是 undfined ，那么 令 index 为 0。 否则 令 integerIndex 为 ? ToInteger(value) 。 如果 integerIndex 令 index 为 ! ToLength(integerIndex) 。 如果 SameValueZero(integerIndex, index) 是 false, 抛出 RangeError 异常。 返回 index。 7.2 测试和比较操作 7.2.1 RequireObjectCoercible ( argument ) 如果参数是无法使用ToObject转换为Object的值，则抽象操作RequireObjectCoercible会引发错误。由表13定义： 输入类型 结果 未定义 抛出一个 TypeError 异常 空值 抛出一个 TypeError 异常 布尔值 返回 argument 数值 返回 argument 字符串 返回 argument 对象 返回 argument 7.2.2 IsArray ( argument ) 抽象操作IsArray采用一个实参作为参数，并执行以下步骤： 如果 Type(argument)不是对象，返回 false。 如果 argument 是一个数组异类对象，返回 true。 如果 argument 是一个代理异类对象，那么 如果 argument.[[ProxyHandler]] 是 null，抛出TypeError异常。 令 target 为 argument.[[ProxyTarget]] 返回 ? IsArray(target). 4， 返回 false。 7.2.3 IsCallable ( argument ) 抽象操作IsCallable，用于确定ECMAScript语言值的参数是否是具有[[Call]]内部方法的可调用函数。 如果 Type(argument) 不是Object，返回 false。 如果 argument 有 [[Call]] 内部方法，返回 true。 返回 false。 7.2.4 IsConstructor ( argument ) 抽象操作IsConstructor，用于确定ECMAScript语言值的参数是否是具有[[Construct]]内部方法的函数对象。 如果 Type(argument) 不是对象，返回 false。 如果 argument 有 [[Construct]] 内部方法，返回 true。 返回 false 7.2.5 IsExtensible ( O ) 抽象操作IsExtensible，用于确定是否可以将其他属性添加到O对象。返回一个布尔值。此抽象操作执行以下步骤： 断言：Type(O)是对象。 返回 ? O.[IsExtensible]\\ 7.2.6 IsInteger ( argument ) 抽象操作IsInteger，用于确定参数是否为有限整数。 如果 Type(argument) ，返回 false。 如果 argument 是 NaN, +∞, or -∞, 返回 false。 如果 floor(abs(argument)) ≠ abs(argument)，返回 false 7.2.7 IsPropertyKey ( argument ) 抽象操作IsPropertyKey，用于确定必须为ECMAScript语言值的参数是否可以用作属性键的值。 如果 Type(argument) 是字符串，返回 true。 如果 Type(argument) 是Symbol，返回 true。 返回 false。 7.2.8 IsRegExp ( argument ) 带参数arguments的抽象操作IsRegExp执行以下步骤： 如果 Type(argument) 不是对象，返回 false。 令 matcher 成为 ? Get(argument, @@match)。 如果 matcher 不是 undefined，返回 ToBoolean(matcher)。 如果 argument 有 [[RegExpMatcher]] 内部插槽，返回 true。 返回 false 7.2.9 IsStringPrefix ( p, q ) 抽象操作IsStringPrefix，确定字符串 p 是否为字符串 q 的前缀。 断言：Type(p)是字符串。 断言：Type(q)是字符串。 如果q可以是p和其他一些字符串r的字符串串联，则返回true。否则，返回false。 注意：任何字符串都是其自身的前缀，因为r可能是空字符串。 7.2.10 SameValue ( x, y ) 内部比较抽象操作 SameValue ( x , y )（其中x和y是ECMAScript语言值）产生true或false。这样的比较执行如下： 如果 Type(x) 不同于 Type(y)，返回 false。 如果 Type(x) 是数字，那么 如果 x 是 NaN，并且 y 是 NaN，返回 true。 如果 x 是 +0，并且 y 是 -0，返回 false。 如果 x 是 -0，并且 y 是 +0，返回 false。 如果 x 与 y 相同的 Number 值，返回 true。 返回 false 返回 SameValueNonNumber(x, y)。 注：该算法与严格平等比较算法的区别在于对有符号零和NaN的处理。 7.2.11 SameValueZero ( x, y ) 内部比较抽象操作SameValueZero（x，y）（其中x和y是ECMAScript语言值）产生true或false。这样的比较执行如下： 如果 Type(x) 不同于 Type(y)，返回 false。 如果 Type(x) 是数字，那么 如果 x 是 NaN，并且 y 是 NaN，返回 true。 如果 x 是 +0，并且 y 是 -0，返回 true。 如果 x 是 -0，并且 y 是 +0，返回 true。 如果 x 与 y 相同的 Number 值，返回 true。 返回 false 返回 SameValueNonNumber(x, y)。 注： SameValueZero 与 SameValue 的区别在于 +0 and -0 的处理。 7.2.12 SameValueNonNumber ( x, y ) 内部比较抽象操作SameValueNonNumber（x，y）（其中x和y都不是Number值）产生true或false。这样的比较执行如下： 断言：Type(x)不是 Number。 断言：Type(x)和Type(y)相同。 如果 Type(x) 是 Undefined，返回 true。 如果 Type(x) 是 Null，返回 true。 如果 Type(x) 是 String，那么 如果x和y是完全相同的码元序列（在相同的索引处具有相同的长度和相同的码元），则返回true；否则，返回false 如果 Type(x) 是 Boolean，那么 如果 x 和 y 都是 true，或者都是 false，返回 true；否则，返回 false。 如果 Type(x) 是Symbol，那么 如果 x 和 y 是一样的Symbol值，返回 true；否则，返回 false。 如果 x 和 y 是一样的 Object 值，返回 true；否则，返回 false。 7.2.13 抽象关系比较 比较 x 如果 LeftFirst 标志为 true，那么 令 px 为 ? ToPrimitive(x, hint Number) 。 令 py 为 ? ToPrimitive(y, hint Number) 。 否则，左到右的执行顺序需要反转， 令 py 为 ? ToPrimitive(y, hint Number) 。 令 px 为 ? ToPrimitive(x, hint Number) 。 如果 Type(px) 是 String，同时 Type(py) 是 String，那么 如果 IsStringPrefix(py, px) 是 true，返回 false。 如果 IsStringPrefix(px, py) 是 true，返回 true。 令 k 为最小的非负整数，使得 px 内索引k处的码元与 py 内索引k处的码元不同。（必须有一个k，因为 String 都不是另一个的前缀。） 令 m 为整数，它是 px 中的索引 k 处的码元的数值。 令 n 为整数，它是 py 中索引 k 处的代码单元的数值。 如果 m 否则， 注：因为px和py是原始值，所以执行顺序并不重要。 令 nx 为 ? ToNumber(px)。 令 ny 为 ? ToNumber(py)。 若 nx 是 NaN, 返回 undefined. 若 ny 是 NaN, 返回 undefined. 若 nx 和 ny 是同一个 Number 值, 返回 false. 若 nx 是 +0 并且 ny 也是 -0, 返回 false. 若 nx 是 -0 并且 ny 也是 +0, 返回 false. 若 nx 是 +∞, 返回 false. 若 ny 是 +∞, 返回 true. 若 ny 是 -∞, 返回 false. 若 nx 是 -∞, 返回 true. 如果 nx 的数学值小于 ny 的数学值（请注意，这些数学值都是有限的且不都是零），则返回 true。否则，返回 false 注 1：第3步与第7步的区别在于，加法运算符+（12.8.3）的算法使用逻辑和运算而不是逻辑或运算。 注 2：字符串使用简单的码元值序列字典顺序来做比较。规范没有使用更复杂的，面向语义的字符或字符串相等性定义以及Unicode规范中定义的整理顺序。因此，根据Unicode标准规范相等的字符串值可以验证为不相等。实际上，该算法假定两个字符串都已经处于规范化形式。此外，请注意，对于包含补充字符的字符串，UTF-16码元序列的字典顺序与码点序列的字典顺序不同。 7.2.14 抽象相等比较 比较x == y（其中x和y是值）产生true或false。这样的比较执行如下： 如果 Type(x) 与 Type(y) 相等，那么 返回执行严格相等比较x === y的结果。 如果 x 是 null，同时 y 是 undefined，返回 true。 如果 x 是 undefined，同时 y 是 null，返回 true。 如果 Type(x) 是 Number 同时 Type(y) 是 String, 返回 x == ! ToNumber(y) 的比较结果。 如果 Type(x) 是 String 同时 Type(y) 是 Number, 返回 ! ToNumber(x) == y 的比较结果。 如果 Type(x) 是 Boolean，返回 ! ToNumber(x) == y 的比较结果。 如果 Type(x) 是 Boolean，返回 x == ! ToNumber(y) 的比较结果。 如果 Type(x) 是 String，Number，或者Symbol，并且 Type(y) 是Object，返回 x == ToPrimitive(y) 的比较结果。 如果 Type(x) 是 Object，同时Type(y) 是 String，Number，或者Symbol，返回 ToPrimitive(x) == y 的比较结果 返回 false。 7.2.15 严格相等比较 比较x === y（其中x和y是值）会产生true或false。这样的比较执行如下： 如果 Type(x) 与 Type(y) 不同，返回 false。 如果 Type(x) 是 Number，那么 如果 x 是 NaN，返回 false。 如果 y 是 NaN，返回 false。 如果 x 与 y Number值相同，返回 true。 如果 x 是 +0 同时 y 是 -0，返回 true。 如果 x 是 -0 同时 y 是 +0，返回 true。 返回 false。 返回 SameValueNonNumber(x, y) 注：该算法与Same Value算法的区别在于对有符号零和NaN的处理。 7.3 对象的操作 7.3.1 Get ( O, P ) 抽象操作Get用于检索对象的特定属性的值。使用参数O和P调用该操作，其中O是对象，P是属性键。此抽象操作执行以下步骤： 断言：Type(O) 是 Object。 断言：IsPropertyKey(P) 是 true。 返回 O.[[Get]](P, O)。 7.3.2 GetV ( V, P ) 抽象操作GetV用于检索ECMAScript语言值的特定属性的值。如果该值不是对象，则使用适合该值类型的包装对象执行属性查找。使用参数V和P调用该操作，其中V是值，P是属性键。此抽象操作执行以下步骤： 断言：IsPropertyKey(P) 是 true。 令 O 为 ? ToObject(V) 。 返回 O.[[Get]](P, V)。 7.3.3 Set ( O, P, V, Throw ) 抽象操作Set用于设置对象的特定属性的值。使用参数O，P，V和Throw调用该操作，其中O是对象，P是属性键，V是该属性的新值，并且Throw是布尔值标志。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 断言: Type(Throw) 是 Boolean. 令 success 为 ? O.[[Set]](P, V, O). 如果 success 是 false 同时 Throw 是 true, 抛出 TypeError 异常. 返回 success. 7.3.4 CreateDataProperty ( O, P, V ) 抽象操作CreateDataProperty用于创建对象的新自身属性。使用参数O，P和V调用该操作，其中O是对象，P是属性键，V是属性的值。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 令 newDesc 为 the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}. 返回 ? O.[[DefineOwnProperty]](P, newDesc). 注：此抽象操作将创建一个属性，该属性的属性设置为与ECMAScript语言赋值运算符创建的属性所使用的默认值相同的默认值。通常，该属性将不存在。如果它确实存在并且不可配置，或者O不可扩展，则[[DefineOwnProperty]]将返回false。 7.3.5 CreateMethodProperty ( O, P, V ) 抽象操作CreateMethodProperty用于创建对象的新自身属性。使用参数O，P和V调用该操作，其中O是对象，P是属性键，V是属性的值。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 令 newDesc 为 PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}. 返回 ? O.[[DefineOwnProperty]](P, newDesc). 注：此抽象操作创建一个属性，该属性的属性设置为与内置方法和使用类声明语法定义的方法相同的默认值。通常，该属性将不存在。如果它确实存在并且不可配置，或者O不可扩展，则[[DefineOwnProperty]]将返回false。 7.3.6 CreateDataPropertyOrThrow ( O, P, V ) 抽象操作CreateDataPropertyOrThrow用于创建对象的新自身属性。如果无法执行请求的属性更新，则会引发TypeError异常。使用参数O，P和V调用该操作，其中O是对象，P是属性键，V是属性的值。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 令 success 为 ? CreateDataProperty(O, P, V). 如果 success 是 false, 抛出 TypeError 异常. 返回 success. 注：此抽象操作将创建一个属性，该属性的属性设置为与ECMAScript语言赋值运算符创建的属性所使用的默认值相同的默认值。通常，该属性将不存在。如果确实存在并且不可配置，或者O不可扩展，则[[DefineOwnProperty]]将返回false，导致此操作引发TypeError异常。 7.3.7 DefinePropertyOrThrow ( O, P, desc ) 抽象操作DefinePropertyOrThrow用于以某种方式调用对象的[[DefineOwnProperty]]内部方法，如果无法执行请求的属性更新，该方式将引发TypeError异常。使用参数O，P和desc调用该操作，其中O是对象，P是属性键，而desc是该属性的属性描述符。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 令 success 为 ? O.[[DefineOwnProperty]](P, desc). 如果 success 是 false, 抛出 TypeError 异常. 返回 success. 7.3.8 DeletePropertyOrThrow ( O, P ) 抽象操作DeletePropertyOrThrow用于删除对象的特定自身属性。如果该属性不可配置，它将引发异常。使用参数O和P调用该操作，其中O是对象，P是属性键。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 令 success 为 ? O.[[Delete]](P). 如果 success 是 false, 抛出 TypeError 异常. 返回 success. 7.3.9 GetMethod ( V, P ) 当期望该属性的值是一个函数时，抽象操作GetMethod用于获取ECMAScript语言值的特定属性的值。使用参数V和P调用该操作，其中V是ECMAScript语言值，P是属性键。此抽象操作执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 func 为 ? GetV(V, P). 如果 func 是 undefined 或 null, 返回 undefined. 如果 IsCallable(func) 是 false, 抛出 TypeError 异常. 返回 func. 7.3.10 HasProperty ( O, P ) 抽象操作HasProperty用于确定对象是否具有具有指定属性键的属性。该属性可以是自己的或继承的。返回一个布尔值。使用参数O和P调用该操作，其中O是对象，P是属性键。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 返回 ? O.[[HasProperty]](P). 7.3.11 HasOwnProperty ( O, P ) 抽象操作HasOwnProperty用于确定对象是否具有带有指定属性键的自己的属性。返回一个布尔值。使用参数O和P调用该操作，其中O是对象，P是属性键。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: IsPropertyKey(P) 是 true. 令 desc 为 ? O.[[GetOwnProperty]](P). 如果 desc 是 undefined, 返回 false. 返回 true. 7.3.12 Call ( F, V [ , argumentsList ] ) 抽象操作Call用于调用函数对象的[[Call]]内部方法，使用参数F，V和可选的argumentsList调用该操作，其中F是函数对象，V是ECMAScript语言值，它是[[Call]]的this值，argumentsList是传递给对应的参数的值内部方法。如果argumentsList不存在，则将新的空List用作其值。此抽象操作执行以下步骤： 如果 argumentsList 不存在, 令 argumentsList 为 一个新的空数组. 如果 IsCallable(F) 是 false, 抛出 TypeError 异常. 返回 ? F.[[Call]](V, argumentsList). 7.3.13 Construct ( F [ , argumentsList [ , newTarget ] ] ) 抽象操作Construct用于调用函数对象的[[Construct]]内部方法。该操作使用参数F以及可选的argumentsList和newTarget调用，其中F是函数对象。argumentsList和newTarget是要作为内部方法的相应参数传递的值。如果argumentsList不存在，则将新的空List用作其值。如果newTarget不存在，则F用作其值。此抽象操作执行以下步骤： 如果 newTarget was 不存在, 令 newTarget 为 F. 如果 argumentsList 不存在, 令 argumentsList 为 一个新的空数组. 断言: IsConstructor(F) 是 true. 断言: IsConstructor(newTarget) 是 true. 返回 ? F.[[Construct]](argumentsList, newTarget). 注：如果不存在newTarget，则此操作等效于：new F（... argumentsList） 7.3.14 SetIntegrityLevel ( O, level ) 抽象操作SetIntegrityLevel用于修复对象自身属性的集合。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: level 是 \"sealed\" 或者 \"frozen\". 令 status 为 ? O.[[PreventExtensions]](). 如果 status 是 false, 返回 false. 令 keys 为 ? O.[[OwnPropertyKeys]](). 如果 level 是 \"sealed\", 那么 对于每一个keys的k 执行 ? DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false}). 否则，level 是 \"frozen\", 对于所有keys的k 令 currentDesc 为 ? O.[[GetOwnProperty]](k). 如果 currentDesc 不是 undefined, 那么 如果 IsAccessorDescriptor(currentDesc) 是 true, 那么 令 desc 为 PropertyDescriptor{[[Configurable]]: false}. 否则, 令 desc 为 the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }. 执行 ? DefinePropertyOrThrow(O, k, desc) 返回 true. 7.3.15 TestIntegrityLevel ( O, level ) 抽象操作TestIntegrityLevel用于确定对象自身属性的集合是否固定。此抽象操作执行以下步骤： 断言: Type(O) 是 Object. 断言: level 是 \"sealed\" 或者 \"frozen\". 令 status 为 ? IsExtensible(O). 如果 status 是 true, 返回 false. 注意：如果对象是可扩展的，则不会检查其任何属性。 令 keys 为 ? O.[[OwnPropertyKeys]](). 对于每一个keys的k 令 currentDesc 为 ? O.[[GetOwnProperty]](k) . 如果 currentDesc 不是 undefined, 那么 如果 currentDesc.[[Configurable]] 是 true, 返回 false 如果 level 是 \"frozen\" 并且 IsDataDescriptor(currentDesc) 是 true, 那么 如果 currentDesc.[[Writable]] 是 true, 返回 false. 返回 true. 7.3.16 CreateArrayFromList ( elements ) 抽象操作CreateArrayFromList用于创建一个Array对象，其元素由List提供。此抽象操作执行以下步骤： 断言: elements是一个List，其元素均为ECMAScript语言值。 令 array 为 ! ArrayCreate(0). 令 n 为 0. 对于elements 的每一个 e 令 status 为 CreateDataProperty(array, ! ToString(n), e). 断言: status 是 true. n 增加 1. 返回 array. 7.3.17 CreateListFromArrayLike ( obj [ , elementTypes ] ) 抽象操作CreateListFromArrayLike用于创建一个List值，其值由类似数组的对象 obj 的索引属性提供。可选参数elementTypes 是一个 List，其中包含所创建 List 的元素值所允许的ECMAScript语言类型的名称。此抽象操作执行以下步骤： 如果 elementTypes 不存在, 令 elementTypes 为 « Undefined, Null, Boolean, String, Symbol, Number, Object ». 如果 Type(obj) 不是 Object, 抛出 TypeError 异常. 令 len 为 ? ToLength(? Get(obj, \"length\")). 令 list 为 一个空的List. 令 index 为 0. 重复，直到 index 令 indexName 为 ! ToString(index). 令 next 为 ? Get(obj, indexName). 如果 Type(next) 是 不是 elementTypes 元素, 抛出 TypeError 异常. 将next附加到列表的最后一个元素。 index增加1 返回 list. 7.3.18 Invoke ( V, P [ , argumentsList ] ) 抽象操作Invoke用于调用ECMAScript语言值的method属性。使用参数V，P和可选的argumentsList调用该操作，其中V既用作属性的查找点，又用作调用的this值，P是属性键，而argumentsList是传递给方法的参数值的列表。如果argumentsList不存在，则将新的空List用作其值。此抽象操作执行以下步骤： 断言: IsPropertyKey(P) 是 true. 如果 argumentsList 不存在，把 argumentsList 设为 新的空. 令 func 为 ? GetV(V, P). 返回 ? Call(func, V, argumentsList). 7.3.19 OrdinaryHasInstance ( C, O ) 抽象操作OrdinaryHasInstance实现用于确定对象O是否从构造函数C提供的实例对象继承路径继承的默认算法。该抽象操作执行以下步骤： 如果 IsCallable(C) 是 false, 返回 false. 如果 C 有 [[BoundTargetFunction]] 内置插槽, 那么 令 BC 为 C 的 [[BoundTargetFunction]] 内置插槽值。 返回 ? InstanceofOperator(O, BC). 如果 Type(O) 不是 Object, 返回 false. 令 P 为 ? Get(C, \"prototype\"). 如果 Type(P) 不是 Object, 抛出 TypeError 异常. 重复 令 O 为 ? O.[[GetPrototypeOf]](). 如果 O 是 null, 返回 false. 如果 SameValue(P, O) 是 true, 返回 true. 7.3.20 SpeciesConstructor ( O, defaultConstructor ) 抽象操作SpeciesConstructor用于检索应用于创建从参数对象O派生的新对象的构造函数。defaultConstructor参数是在从O开头找不到构造函数@@ species属性时要使用的构造函数。抽象操作执行以下步骤： 断言: Type(O) 是 Object. 令 C 为 ? Get(O, \"constructor\"). 如果 C 是 undefined, 返回 defaultConstructor. 如果 Type(C) 不是 Object, 抛出 TypeError 异常. 令 S 为 ? Get(C, @@species). 如果 S 是 undefined 或 null, 返回 defaultConstructor. 如果 IsConstructor(S) 是 true, 返回 S. 抛出 TypeError 异常. 7.3.21 EnumerableOwnPropertyNames ( O, kind ) 当使用对象O和字符串类型调用抽象操作EnumerableOwnPropertyNames时，将执行以下步骤： 断言: Type(O) 是 Object. 令 ownKeys 为 ? O.[[OwnPropertyKeys]](). 令 properties 为一个新的空数组. 对于List顺序中ownKeys的每个key元素 如果 Type(key) 是 String, 那么 令 desc 为 ? O.[[GetOwnProperty]](key). 如果 desc 不是 undefined 同时 desc.[[Enumerable]] 是 true , 那么 如果 kind 是 \"key\"，添加 key 到 properties。 否则， 令 value 为 ? Get(O, key)。 如果 kind 是 \"key\"，添加 value 到 properties。 否则， 断言：kind 是 \"key+value\"。 令 entry 为 CreateArrayFromList(« key, value »). 添加 entry 到 properties。 对属性的元素进行排序，以使它们与Iterator产生的相对顺序相同，如果使用O调用EnumerateObjectProperties内部方法，则返回的迭代器相同。 返回 properties . 7.3.22 GetFunctionRealm ( obj ) 参数为obj的抽象操作GetFunctionRealm执行以下步骤： 断言: obj 是一个可被调用的对象. 如果 obj 有 [[Realm]] 内部插槽, 那么 返回 obj 的 [[Realm]] 内部插槽. 如果 obj 是绑定函数的异类对象, 那么 令 target 为 obj.[[BoundTargetFunction]]. 返回 ? GetFunctionRealm(target). 如果 obj 是一个代理异类对象, 那么 如果 obj.[[ProxyHandler]]是 null, 抛出 TypeError 异常. 令 proxyTarget 为 obj.[[ProxyTarget]]. 返回 ? GetFunctionRealm(proxyTarget). 返回当前的Realm记录。 注：仅当obj是不具有[[Realm]]内部插槽的非标准函数异类对象时，才可以执行步骤5。 7.3.23 CopyDataProperties ( target, source, excludedItems ) 当使用目标，源和排除项目参数调用抽象操作CopyDataProperties时，将执行以下步骤： 断言: Type(target) 是 Object. 断言: excludedItems 是属性键列表. 如果 source 是 undefined 或 null, 返回 target. 令 from 为 ! ToObject(source). 令 keys 为 ? from.[[OwnPropertyKeys]](). 对于按List顺序的keys的每个元素nextKey，执行 令 excluded 为 false. 对于按List顺序的excludedItems的每个元素e，执行 如果 SameValue(e, nextKey) 是 true, 那么 设置 excluded 为 true. 如果 excluded 是 false, 那么 令 desc 为 ? from.[[GetOwnProperty]](nextKey). 如果 desc 不是 undefined 同时 desc.[[Enumerable]] 是 true, 那么 令 propValue 为 ? Get(from, nextKey). 执行 ! CreateDataProperty(target, nextKey, propValue). 返回 target。 注：传入的目标始终是新创建的对象，如果抛出错误，则不能直接访问该对象 7.4 迭代器对象的操作 请参见通用迭代接口（25.1）。 7.4.1 GetIterator ( obj [ , hint [ , method ] ] ) 具有参数obj和可选参数hint和method的抽象操作GetIterator执行以下步骤： 如果 hint 不存在, 设置 hint 为 sync. 断言: hint 是 sync 或 async. 如果 method 不存在, 那么 如果 hint 是 async, 那么 设置 method 为 ? GetMethod(obj, @@asyncIterator). 如果 method 是 undefined, 那么 令 syncMethod 为 ? GetMethod(obj, @@iterator). 令 syncIteratorRecord 为 ? GetIterator(obj, sync, syncMethod). 返回 ? CreateAsyncFromSyncIterator(syncIteratorRecord). 否则，设置 method 为 ? GetMethod(obj, @@iterator). 令 iterator 为 ? Call(method, obj). 如果 Type(iterator) 不是 Object, 抛出 TypeError 异常. 令 nextMethod 为 ? GetV(iterator, \"next\"). 令 iteratorRecord 为 Record { [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }. 返回 iteratorRecord. 7.4.2 IteratorNext ( iteratorRecord [ , value ] ) 具有参数iteratorRecord和可选参数值的抽象操作IteratorNext执行以下步骤： 如果 value 不存在, 那么 令 result 为 ? Invoke(iterator, \"next\", « »). 否则, 令 result 为 ? Invoke(iterator, \"next\", « value »). 如果 Type(result) 不是 Object, 抛出 TypeError 异常. 返回 result. 7.4.3 IteratorComplete ( iterResult ) 参数为iterResult的抽象操作IteratorComplete执行以下步骤： 断言: Type(iterResult) 是 Object. 返回 ToBoolean(? Get(iterResult, \"done\")). 7.4.4 IteratorValue ( iterResult ) 具有参数iterResult的抽象操作IteratorValue执行以下步骤： 断言: Type(iterResult) 是 Object. 返回 ? Get(iterResult, \"value\"). 7.4.5 IteratorStep ( iteratorRecord ) 参数为iteratorRecord的抽象操作IteratorStep通过调用iteratorRecord.[[NextMethod]]从iteratorRecord.[[Iterator]]请求下一个值。返回false指示迭代器已到达末尾，或者返回IteratorResult对象（如果有下一个值）。IteratorStep执行以下步骤： 令 result 为 ? IteratorNext(iterator). 令 done 为 ? IteratorComplete(result). 如果 done 是 true, 返回 false. 返回 result. 7.4.6 IteratorClose ( iteratorRecord, completion ) 带有参数iteratorRecord和complete的抽象操作IteratorClose用于通知迭代器它应该执行在达到其完成状态时通常应执行的任何操作： 断言: Type(iterator) 是 Object. 断言: completion 是一个完成状态记录. 令 iterator 为 iteratorRecord.[[Iterator]]. 令 return 为 ? GetMethod(iterator, \"return\"). 如果 return 是 undefined, 返回 Completion(completion). 令 innerResult 为 Call(返回, iterator, « »). 如果 completion.[[Type]] 是 throw, 返回 Completion(completion). 如果 innerResult.[[Type]] 是 throw, 返回 Completion(innerResult). 如果 Type(innerResult.[[Value]]) 不是 Object, 抛出 TypeError 异常. 返回 Completion(completion). 7.4.7 AsyncIteratorClose ( iteratorRecord, completion ) 带有参数iteratorRecord和complete的抽象操作AsyncIteratorClose用来通知异步迭代器它应该执行在达到其完成状态时通常应执行的任何操作： 断言: Type(iteratorRecord.[[Iterator]]) 是 Object. 断言: completion 是一个完成记录. 令 iterator 为 iteratorRecord.[[Iterator]]. 令 return 为 ? GetMethod(iterator, \"return\"). 如果 return 是 undefined, 返回 Completion(completion). 令 innerResult 为 Call(返回, iterator, « »). 如果 innerResult.[[Type]] 是 normal, 设置 innerResult 为 Await(innerResult.[[Value]]). 如果 completion.[[Type]] 是 throw, 返回 Completion(completion). 如果 innerResult.[[Type]] 是 throw, 返回 Completion(innerResult). 如果 Type(innerResult.[[Value]]) 不是 Object, 抛出 TypeError 异常. 返回 Completion(completion). 7.4.8 CreateIterResultObject ( value, done ) 通过执行以下步骤，将抽象操作CreateIterResultObject与参数value和done一起创建一个支持IteratorResult接口的对象： 断言: Type(done) 为 Boolean. 令 obj 为 ObjectCreate(%ObjectPrototype%). 执行 CreateDataProperty(obj, \"value\", value). 执行 CreateDataProperty(obj, \"done\", done). 返回 obj. 7.4.9 CreateListIteratorRecord ( list ) 具有参数列表的抽象操作CreateListIteratorRecord创建一个Iterator（25.1.1.2）对象记录，其下一个方法返回list的连续元素。它执行以下步骤： 让 iterator 为 ObjectCreate（％IteratorPrototype％，«[[IteratedList]]，[[ListIteratorNextIndex]]»）。 设置 iterator.[[IteratedList]] 为 list. 设置 iterator.[[ListIteratorNextIndex]] 为 0. 令 steps 为 定义在 迭代器 next (7.4.9.1) 的算法步骤. 令 next 为 CreateBuiltinFunction(steps, « »). 返回 Record { [[Iterator]]: iterator, [[NextMethod]]: next, [[Done]]: false } 注：迭代器列表对象永远不能直接由ECMAScript代码访问。 7.4.9.1 ListIterator next ( ) ListIterator next方法是一个标准的内置函数对象（第17节），该对象执行以下步骤： 令 O 为 this 值。 断言：Type(O) 是 Object。 断言：O 有一个 [[IteratorNext]] 内置插槽。 令 list 为 O.[[IteratedList]] 令 index 为 O.[[ListIteratorNextIndex]]. 令 len 为 list的元素个数. 如果 index ≥ len, 那么 返回 CreateIterResultObject(undefined, true). 设置 O.[[ListIteratorNextIndex]] 为 index+1. 返回 CreateIterResultObject(list[index], false). 这些抽象操作不是语言本身的一部分；它们被定义在这里是为了协助语言的语义规范。 在本规范中定义了其他更专门的抽象操作。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,抽象操作,abstract-operations "},"executable-code-and-execution-contexts.html":{"url":"executable-code-and-execution-contexts.html","title":"8 可执行代码和可执行上下文","keywords":"","body":"8 可执行代码和可执行上下文 8.1 词法环境 词法环境是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个环境记录项和可能为空的外部词法环境引用构成。通常词法环境会与 ECMAScript 代码诸如 FunctionDeclaration、WithStatement 或者 TryStatement 的 Catch 块这样的特定句法结构相联系，且类似代码每次执行都会有一个新的词法环境被创建出来。 环境记录记录了在其关联词法环境范围内创建的标识符绑定。它被称为词法环境的环境记录项。 外部词法环境引用用于表示词法环境的逻辑嵌套关系模型。（内部）词法环境的外部引用是逻辑上包含内部词法环境的词法环境。外部词法环境当然可以具有自己的外部词法环境。词法环境可以用作多个内部词法环境的外部环境。例如，如果一个 FunctionDeclaration 包含两个嵌套的 FunctionDeclaration，那么每个内嵌函数的词法环境都是外部函数本次执行所产生的词法环境。 全局环境是没有外部环境的词法环境。全局环境的外部环境引用为null。全局环境的环境记录项可能预填充了标识符绑定，并包括一个关联的全局对象，该对象的属性提供了某些全局环境的标识符绑定。在执行ECMAScript代码时，可以将其他属性添加到全局对象，并且可以修改初始属性。 模块环境是一个词法环境，其中包含模块顶级声明的绑定。它还包含模块显式导入的绑定。模块环境的外部环境是全局环境。 函数环境是一个词法环境，它与ECMAScript函数对象的调用相对应。一个function环境可以建立一个新的this绑定。函数环境还捕获支持super方法调用所需的状态。 词法环境和环境记录的值纯粹是规范机制，不需要与任何具体的ECMAScript实现相对应。ECMAScript程序无法直接访问或操纵这些值。 8.1.1 环境记录 在本标准中，共有两类环境记录项：声明式环境记录项和对象式环境记录项。声明式环境记录项用于定义那些将标识符与语言值直接绑定的 ECMA 脚本语法元素，例如 FunctionDeclaration、VariableDeclaration 以及 Catch 语句。对象式环境记录项用于定义那些将标识符与具体对象的属性绑定的 ECMA 脚本元素，例如 WithStatement 表达式。全局环境记录和函数环境记录是专门用于Script全局声明和函数内顶级声明的规范化。 出于规范目的，环境记录值是记录(Record)规范类型的值，可以认为是存在于简单的面向对象的层次结构中，其中环境记录是具有三个具体子类的抽象类，即声明性环境记录，对象环境记录和全局环境记录。功能环境记录和模块环境记录是声明性环境记录的子类。抽象类包括表14中定义的抽象规范方法。这些抽象方法针对每个具体子类具有不同的具体算法。 方法 作用 HasBinding(N) 确定环境记录是否具有字符串 N 的绑定。 如果没有，请返回 true ，否则为 false CreateMutableBinding(N, D) 在环境记录中创建一个新的但未初始化的可变绑定。 字符串 N 是绑定名称的文本。 如果布尔参数 D 是 true ，则绑定可能随后被删除. CreateImmutableBinding(N, S) 在环境记录中创建一个新的但未初始化的不可变绑定。 字符串 N 是绑定名称的文本。 如果 S 是 true ，那么无论严格模式是否设置，对于该绑定，在初始化之前访问绑定的值，或者在初始化之后对其进行设置将引发异常. InitializeBinding(N, V) 在环境记录中设置已存在但未初始化的绑定的值。 字符串 N 是绑定名称的文本。 V 是绑定的值，是任何ECMAScript语言类型 . SetMutableBinding(N, V, S) 在环境记录中设置已经存在的可变绑定的值。 字符串 N 是绑定名称的文本。 V 是绑定的值，可以是任何ECMAScript语言类型 。 S 是一个布尔标志。 如果 S 是 true ，并且绑定不能设置，则抛出一个 TypeError 异常. GetBindingValue(N, S) 从环境记录中返回已经存在的绑定的值。 字符串 N 是绑定名称的文本。 S 用于标识源自严格模式代码(strict mode code)，否则需要严格的模式引用语义。 如果 S 是 true ，绑定不存在则引发一个 ReferenceError 异常。 如果绑定存在但未初始化，不管 S 的值，都会抛出 ReferenceError DeleteBinding(N) 从环境记录中删除绑定。 字符串 N 是绑定名称的文本。 如果存在 N 的绑定，则删除绑定并返回 true 。 如果绑定存在但不能被删除返回 false 。 如果绑定不存在返回 true . HasThisBinding() 确定环境记录是否建立了一个this绑定。 如果是，则返回true；否则，则返回false HasSuperBinding() 确定环境记录是否建立了一个super方法绑定。 如果是，则返回true；否则，则返回false WithBaseObject() 如果此环境记录与with语句相关联，则返回with对象。 否则返回 undefined . 8.1.1.1 声明环境记录 每个声明性环境记录都与包含变量，常量，let，class, module, import，与或函数声明的ECMAScript程序范围相关联。声明式环境记录项用于绑定作用域内定义的一系列标识符。 声明性环境记录的具体规范方法的行为由以下算法定义。 8.1.1.1.1 HasBinding ( N ) 声明式环境记录项的 HasBinding 具体方法用于简单地判断作为参数的标识符是否是当前对象绑定的标识符之一： 令 envRec 为函数调用时对应的声明式环境记录项。 如果 envRec 有一个名称为 N 的绑定，返回 true。 如果没有该绑定，返回 false。 8.1.1.1.2 CreateMutableBinding ( N, D ) 声明式环境记录项的 CreateMutableBinding 具体方法会创建一个名称为 N 的绑定，并初始化其值为 undefined。方法调用时，当前环境记录项中不能存在 N 的绑定。如果调用时提供了布尔类型的参数 D 且其值为 true，则新建的绑定被标记为可删除。 令 envRec 为函数调用时对应的声明式环境记录项。 断言：envRec 没有 N 的绑定。 在 envRec 中为 N 创建一个可变绑定，并将绑定的值设置为 undefined。如果 D 为 true 则新创建的绑定可在后续操作中通过调用 DeleteBinding 删除。 返回 NormalCompletion(empty) 8.1.1.1.3 CreateImmutableBinding ( N, S ) 声明性环境记录的具体环境记录方法CreateImmutableBinding为未初始化的名称N创建一个新的不可变绑定。N的此环境记录中必须没有绑定。如果布尔参数S的值为true，则将新绑定标记为严格绑定。 令 envRec 为函数调用时对应的声明式环境记录项。 断言：envRec 不存在 N 的绑定。 在 envRec 中为 N 创建一个不可变绑定，并记录为未初始化。如果S为true，则记录新创建的绑定是严格绑定 返回 NormalCompletion(empty) 8.1.1.1.4 InitializeBinding ( N, V ) 声明性环境记录的具体环境记录方法InitializeBinding用于将名称为参数N的值的标识符的当前绑定的绑定值设置为参数V的值。N的未初始化绑定必须已经存在。 令 envRec 为函数调用时对应的声明式环境记录项。 断言: envRec 必须具有N的未初始化绑定。 将envRec中N的绑定值设置为V 。 记录envRec中已初始化的N的绑定。 返回 NormalCompletion(empty). 8.1.1.1.5 SetMutableBinding ( N, V, S ) 用于声明性环境记录的具体环境记录方法SetMutableBinding试图将名称为参数N的值的标识符的当前绑定的绑定值更改为参数V的值。N的绑定通常已经存在，但很少见情况可能并非如此。如果绑定是不可变的绑定，则在S为true时引发TypeError。 令 envRec 为函数调用时对应的声明式环境记录项。 若 envRec 不存在 N 的绑定, 那么 若 S 是 true, 抛出 ReferenceError 异常. 执行 envRec.CreateMutableBinding(N, true). 执行 envRec.InitializeBinding(N, V). 返回 NormalCompletion(empty). 若 envRec中N的绑定是严格绑定, 设置 S 为 true. 若 envRec中N的绑定未被初始化, 抛出 ReferenceError 异常. 否则 若 envRec中N的绑定是易变的绑定, 将绑定值改为 V. 否则, 断言: 尝试更改不可变绑定的值. 若 S 是 true, 抛出 TypeError 异常. 返回 NormalCompletion(empty). 注：导致步骤2缺少绑定的ECMAScript代码示例为： function f(){eval(\"var x; x = (delete x, 0);\")} 8.1.1.1.6 GetBindingValue ( N, S ) 声明性环境记录的具体环境记录方法GetBindingValue只是返回其绑定标识符的值，该标识符的名称是参数N的值。如果绑定存在但未初始化，则无论S的值如何，都会引发ReferenceError。 令 envRec 为函数调用时对应的声明式环境记录项. 断言: envRec 具有N的绑定. 若 envRec中的N绑定是未初始化的绑定, 抛出 ReferenceError 异常. 返回 envRec 中的N的当前绑定值 8.1.1.1.7 DeleteBinding ( N ) 声明性环境记录的具体环境记录方法DeleteBinding只能删除已明确指定要删除的绑定。 令 envRec 为函数调用时对应的声明式环境记录项. 断言: envRec绑定的名称是N的值。 若 envRec中N不能被删除, 返回 false. 从envRec中删除N的绑定. 返回 true. 8.1.1.1.8 HasThisBinding ( ) 常规的声明性环境记录不提供this绑定。 返回 false. 8.1.1.1.9 HasSuperBinding ( ) 常规的声明性环境记录不提供super绑定。 返回 false. 8.1.1.1.10 WithBaseObject ( ) 声明性环境记录始终返回 undefined 作为 WithBaseObject。 返回 undefined. 8.1.1.2 对象环境记录 每一个对象式环境记录项都有一个关联的对象，这个对象被称作绑定对象 。对象式环境记录项直接将一系列标识符与其绑定对象的属性名称建立一一对应关系。不符合 IdentifierName 的属性名不会作为绑定的标识符使用。无论是对象自身的，还是继承的属性都会作为绑定，无论该属性的 [[Enumerable]] 特性的值是什么。由于对象的属性可以动态的增减，因此对象式环境记录项所绑定的标识符集合也会隐匿地变化，这是增减绑定对象的属性而产生的副作用。通过以上描述的副作用而建立的绑定，均被视为可变绑定，即使该绑定对应的属性的 [[Writable]] 特性的值为 false。对象式环境记录项没有不可变绑定。 为with语句（13.11）创建的对象环境记录可以提供其绑定对象作为此值的隐式供函数调用使用。该功能由与每个对象环境记录关联的withEnvironment布尔值控制。默认情况下，任何对象环境记录的withEnvironment的值为false。 对象环境记录的具体规范方法的行为由以下算法定义。 8.1.1.2.1 HasBinding ( N ) 对象式环境记录项的 HasBinding 具体方法判断其关联的绑定对象是否有名为 N 的属性： 令 envRec 为函数调用时对应的声明式环境记录项. 令 bindings 为 envRec的绑定对象. 令 foundBinding 为 ? HasProperty(bindings, N). 若 foundBinding 是 false, 返回 false. 若 envRec 的 withEnvironment 标识是 false, 返回 true. 令 unscopables 为 ? Get(bindings, @@unscopables). 若 Type(unscopables) 是 Object, 那么 令 blocked 为 ToBoolean(? Get(unscopables, N)). 若 blocked 是 true, 返回 false. 返回 true 8.1.1.1.2 CreateMutableBinding ( N, D ) 对象式环境记录项的 CreateMutableBinding具体方法会在其关联的绑定对象上创建一个名称为 N 的属性，并初始化其值为 undefined。调用方法时，绑定对象不得包含名称为 N 的属性。如果调用方法时提供了布尔类型的参数 D 且其值为 true，则设置新创建的属性的 [[Configurable]] 特性的值为 true，否则设置为 false。 令 envRec 为函数调用时对应的声明式环境记录项。 令 bindings 为 envRec的绑定对象. 返回 ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }). 注：通常，envRec没有N的绑定，但是如果绑定N，则DefinePropertyOrThrow的语义可能会导致现有绑定被替换或隐藏或导致突然完成返回。 8.1.1.2.3 CreateImmutableBinding ( N, S ) 具体的环境记录方法CreateImmutableBinding从未在此规范中与对象环境记录关联使用。 8.1.1.2.4 InitializeBinding ( N, V ) 对象环境记录的具体环境记录方法InitializeBinding用于将名称为参数N的值的标识符的当前绑定的绑定值设置为参数V的值。N的未初始化绑定必须已经存在。 令 envRec 为函数调用时对应的声明式环境记录项. 断言: envRec 必须具有N的未初始化绑定。 记录envRec中已初始化的N的绑定 返回 ? envRec.SetMutableBinding(N, V, false). 注：在此规范中，对对象环境记录的CreateMutableBinding的所有使用都将紧随其后的是对具有相同名称的InitializeBinding的调用。因此，实现无需显式跟踪单个对象环境记录绑定的初始化状态。 8.1.1.2.5 SetMutableBinding ( N, V, S ) 对象式环境记录项的 SetMutableBinding 具体方法会尝试设置其关联的绑定对象中名为 N 的属性的值为 V。方法调用时，绑定对象中应当存在该属性，如果该属性不存在或属性不可写，则根据 S 参数的值来执行错误处理。 令 envRec 为函数调用时对应的声明式环境记录项。 令 bindings 为 envRec 的绑定对象 返回 ? 设置(bindings, N, V, S). 8.1.1.2.6 GetBindingValue ( N, S ) 对象式环境记录项的 GetBindingValue 具体方法返回其关联的绑定对象中名为 N 的属性的值。方法调用时，绑定对象中应当存在该属性，如果该属性不存在，则方法的返回值由 S 参数决定： 令 envRec 为函数调用时对应的声明式环境记录项。 令 bindings 为 envRec 的绑定对象 令 value 为 ? HasProperty(bindings, N). 若 value 是 false, 那么 若 S 是 false, 返回 undefined 值; 否则，抛出 ReferenceError 异常. 返回 ? Get(bindings, N). 8.1.1.2.7 DeleteBinding ( N ) 对象式环境记录项的 DeleteBinding 具体方法只能用于删除其关联的绑定对象上 [[Configurable]] 特性的值为 true 的属性所对应的绑定。 令 envRec 为函数调用时对应的声明式环境记录项。 令 bindings 为 envRec 的绑定对象 返回 ? bindings.[[Delete]](N). 8.1.1.2.8 HasThisBinding ( ) 常规对象环境记录不提供this绑定。 返回 false. 8.1.1.2.9 HasSuperBinding ( ) 常规对象环境记录不提供super绑定。 返回 false. 8.1.1.2.10 WithBaseObject ( ) 除非其withEnvironment标志为true，否则对象环境记录将返回undefined作为其WithBaseObject。 令 envRec 为函数调用时对应的声明式环境记录项。 若 envRec 的 withEnviroment 标志 是 true, 返回 envRec 的绑定对象. 否则, 返回 undefined. 8.1.1.3 函数环境记录 函数环境记录是声明性环境记录，用于表示函数的顶级作用域，如果函数不是箭头函数，则提供此绑定。如果一个函数不是ArrowFunction函数，并且引用了super，则其函数环境记录项也包含用于从函数内部执行super方法调用的状态。 函数环境记录具有表15中列出的其他状态字段。 字段名 值 含义 [[ThisValue]] 任意值 这是用于此函数调用的this值. [[ThisBindingStatus]] \"lexical\" \\ \"initialized\" \\ \"uninitialized\" 如果值为\"lexical\"，这是一个箭头函数，没有本地this值。 [[FunctionObject]] Object 函数对象被调用导致这个环境记录项被创建。 [[HomeObject]] Object \\ undefined 如果相关函数具有super属性访问，并且不是箭头函数，[[HomeObject ]]是函数绑定到一个方法的对象。 [[HomeObject]]的默认值为 undefined 。 [[NewTarget]] Object \\ undefined 如果这个环境记录项是由[[Construct] ]内部方法创建，[[NewTarget]]是[[Construct]] newTarget 参数的值。 否则，其值为 undefined 。 函数环境记录支持表14中列出的所有声明性环境记录方法，并且对所有这些方法共享相同的规范，但HasThisBinding和HasSuperBinding除外。另外，函数环境记录项支持表16中列出的方法： 方法 目的 BindThisValue(V) 设置[[ThisValue]]并记录它已被初始化。 GetThisBinding() 返回此环境记录项的this绑定。 如果this绑定尚未初始化，则抛出 ReferenceError 异常。 GetSuperBase() 返回在环境记录项中作为super属性访问绑定的基础的对象。该对象源于此环境及记录的[[ HomeObject]]字段。 undefined值表示super属性访问将产生运行时错误. 环境环境记录的其他具体规范方法的行为由以下算法定义： 8.1.1.3.1 BindThisValue ( V ) 令 envRec 为函数调用时对应的声明式环境记录项. 断言: envRec.[[ThisBindingStatus]] 不是 \"lexical\". 若 envRec.[[ThisBindingStatus]] 是 \"initialized\", 抛出 ReferenceError 异常. 设置 envRec.[[ThisValue]] 为 V. 设置 envRec.[[ThisBindingStatus]] 为 \"initialized\". 返回 V 8.1.1.3.2 HasThisBinding ( ) 令 envRec 为函数调用时对应的声明式环境记录项. 若 envRec.[[ThisBindingStatus]] 是 \"lexical\", 返回 false; 否则, 返回 true. 8.1.1.3.3 HasSuperBinding ( ) 令 envRec 为函数调用时对应的声明式环境记录项. 若 envRec.[[ThisBindingStatus]] 是 \"lexical\", 返回 false. 若 envRec.[[HomeObject]] has the value undefined, 返回 false; 否则, 返回 true 8.1.1.3.4 GetThisBinding ( ) 令 envRec 为函数调用时对应的声明式环境记录项. 断言: envRec.[[ThisBindingStatus]] 不是 \"lexical\". 若 envRec.[[ThisBindingStatus]] 是 \"uninitialized\", 抛出 ReferenceError 异常. 返回 envRec.[[ThisValue]]. 8.1.1.3.5 GetSuperBase ( ) 令 envRec 为函数调用时对应的声明式环境记录项. 令 home 为 envRec.[[HomeObject]]. 若 home has the value undefined, 返回 undefined. 断言: Type(home) 是 Object. 返回 ? home.[[GetPrototypeOf]](). 8.1.1.4 全局环境记录 全局环境记录用于表示在共同作用域中处理的所有ECMAScript脚本元素共享的最外部作用域。全局环境记录为内置全局变量（第18节），全局对象的属性以及脚本中发生的所有顶级声明（13.2.8、13.2.10）提供了绑定。 逻辑上，全局环境记录是单个记录，但是它被指定为封装对象的复合记录环境记录和声明性环境记录。对象环境记录的基本对象是相关作用域记录的全局对象。此全局对象是全局环境返回的值记录的GetThisBinding具体方法。全局环境记录的对象环境记录组件包含所有内置全局变量的绑定（第18节）以及FunctionDeclaration引入的所有绑定，包含在其中的GeneratorDeclaration，AsyncFunctionDeclaration，AsyncGeneratorDeclaration或VariableStatement全局代码。全局代码中所有其他ECMAScript声明的绑定包含在全局环境记录的声明性环境记录组件中。 可以直接在全局对象上创建属性。因此，全局环境记录的对象环境记录组件可能包含由FunctionDeclaration，GeneratorDeclaration，AsyncFunctionDeclaration，AsyncGeneratorDeclaration或VariableDeclaration声明显式创建的绑定，以及隐式创建为全局对象属性的绑定。为了识别使用声明显式创建的绑定，全局环境记录使用其CreateGlobalVarBinding和CreateGlobalFunctionBinding具体方法维护绑定名称的列表。 全球环境记录具有表17中列出的其他字段和表18中列出的其他方法。 字段名 值 含义 [[ObjectRecord]] Object Environment Record 绑定对象是global object。 它包含全局内置绑定以及FunctionDeclaration, GeneratorDeclaration, and VariableDeclaration在全局代码中绑定 相关联的作用域(realm). [[GlobalThisValue]] Object 在全局范围内返回的值。 主机(hosts)可以提供任何ECMAScript对象值。 [[DeclarativeRecord]] Declarative Environment Record 包含除了FunctionDeclaration，GeneratorDeclaration和VariableDeclaration绑定之外的关联作用域代码的全局代码中的所有声明的绑定. [[VarNames]] List of String 由相关作用域的全局代码中的FunctionDeclaration，GeneratorDeclaration和VariableDeclaration声明绑定的字符串名称。 方法 目的 GetThisBinding() 返回此环境记录的this绑定的值。 HasVarDeclaration (N) 确定参数标识符是否在此环境记录中使用VariableDeclaration，FunctionDeclaration或GeneratorDeclaration创建的绑定。 HasLexicalDeclaration (N) 确定参数标识符是否在此环境记录中使用词法声明（如LexicalDeclaration或ClassDeclaration）创建的绑定。 HasRestrictedGlobalProperty (N) 确定参数是否是全局对象属性的名称，该属性可能不被全局词法绑定所遮蔽。 CanDeclareGlobalVar (N) 确定相应的CreateGlobalVarBinding调用是否成功，如果调用相同的参数N. CanDeclareGlobalFunction (N) 确定如果相同的参数N被调用，相应的CreateGlobalFunctionBinding调用将成功。 CreateGlobalVarBinding(N, D) 用于在全局环境记录的[[ObjectRecord]]组件中创建和初始化未定义的全局变量绑定。 绑定将是一个可变绑定。 相应的全局对象属性将具有适用于var的属性值。 字符串值N是绑定名称。 如果D为真，绑定可能会被删除。 逻辑上等同于CreateMutableBinding，后跟SetMutableBinding，但它允许var声明接受特殊处理。 CreateGlobalFunctionBinding(N, V, D) 在全局环境记录的[[ObjectRecord]]组件中创建并初始化全局函数绑定。 绑定将是一个可变绑定。 相应的全局对象属性将具有适用于某个函数的属性值。 字符串值N是绑定名称。 V是初始化值。 如果布尔参数D为真，绑定可能会被删除。 逻辑上等同于CreateMutableBinding，后跟SetMutableBinding，但它允许函数声明接受特殊处理。 全局环境记录的具体规范方法的行为由以下算法定义。 8.1.1.4.1 HasBinding ( N ) 全局环境记录的具体环境记录方法HasBinding仅确定参数标识符是否是记录绑定的标识符之一： 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 若 DclRec.HasBinding(N) 是 true, 返回 true. 令 ObjRec 为 envRec.[[ObjectRecord]]. 返回 ? ObjRec.HasBinding(N). 8.1.1.4.2 CreateMutableBinding ( N, D ) 全局环境记录的具体环境记录方法CreateMutableBinding为未初始化的名称N创建新的可变绑定。绑定在关联的DeclarativeRecord中创建。N的绑定必须在DeclarativeRecord中不存在。如果布尔参数D的值为true，则将新绑定标记为要删除。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 若 DclRec.HasBinding(N) 是 true, 抛出 TypeError 异常. 返回 DclRec.CreateMutableBinding(N, D). 8.1.1.4.3 CreateImmutableBinding ( N, S ) 用于全局环境记录的具体环境记录方法CreateImmutableBinding创建一个新的未初始化的名称N的不可变绑定。N的此环境记录中必须没有绑定。如果布尔参数S的值为true，则将新绑定标记为严格绑定。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 若 DclRec.HasBinding(N) 是 true, 抛出 TypeError 异常. 返回 DclRec.CreateImmutableBinding(N, S). 8.1.1.4.4 InitializeBinding ( N, V ) 用于全局环境记录的具体环境记录方法InitializeBinding用于将名称为自变量N的名称的标识符的当前绑定的绑定值设置为自变量V的值。N的未初始化绑定必须已经存在。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 若 DclRec.HasBinding(N) 是 true, 那么 返回 DclRec.InitializeBinding(N, V). 断言: 若存在绑定, 必须为对象环境记录项. 令 ObjRec 为 envRec.[[ObjectRecord]]. 返回 ? ObjRec.InitializeBinding(N, V). 8.1.1.4.5 SetMutableBinding ( N, V, S ) 全局环境记录的具体环境记录方法SetMutableBinding尝试将名称为参数N的值的标识符的当前绑定的绑定值更改为参数V的值。如果绑定是不可变的绑定，则TypeError为如果S为真，则抛出该异常。通常存在一个名为N的属性，但是如果该属性不存在或当前不可写，则错误处理由布尔参数S的值确定。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 若 DclRec.HasBinding(N) 是 true, 那么 s返回 DclRec.SetMutableBinding(N, V, S). 令 ObjRec 为 envRec.[[ObjectRecord]]. 返回 ? ObjRec.SetMutableBinding(N, V, S). 8.1.1.4.6 GetBindingValue ( N, S ) 全局环境记录的具体环境记录方法GetBindingValue返回其绑定标识符的值，该标识符的名称为参数N的值。如果绑定是未初始化的绑定，则抛出ReferenceError异常。通常存在一个名为N的属性，但是如果该属性不存在或当前不可写，则错误处理由布尔参数S的值确定。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 若 DclRec.HasBinding(N) 是 true, 那么 返回 DclRec.GetBindingValue(N, S). 令 ObjRec 为 envRec.[[ObjectRecord]]. 返回 ? ObjRec.GetBindingValue(N, S). 8.1.1.4.7 DeleteBinding ( N ) 全局环境记录的具体环境记录方法DeleteBinding仅可以删除已明确指定要删除的绑定。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 若 DclRec.HasBinding(N) 是 true, 那么 返回 DclRec.DeleteBinding(N). 令 ObjRec 为 envRec.[[ObjectRecord]]. 令 globalObject 为 ObjRec 的绑定对象. 令 existingProp 为 ? HasOwnProperty(globalObject, N). 若 existingProp 是 true, 那么 令 status 为 ? ObjRec.DeleteBinding(N). 若 status 是 true, 那么 令 varNames 为 envRec.[[VarNames]]. 若 N 是 varNames中的元素, 移除 varNames 中的元素. 返回 status. 返回 true. 8.1.1.4.8 HasThisBinding ( ) 返回 true. 8.1.1.4.9 HasSuperBinding ( ) 返回 false. 8.1.1.4.10 WithBaseObject ( ) 全局环境记录的WithBaseObject始终返回undefined。 返回 undefined. 8.1.1.4.11 GetThisBinding ( ) 令 envRec 为 为函数调用时对应的全局式环境记录项. 返回 envRec.[[GlobalThisValue]]. 8.1.1.4.12 HasVarDeclaration ( N ) 全局环境记录的具体环境记录方法HasVarDeclaration确定在此记录中参数变量是否具有使用VariableStatement或FunctionDeclaration创建的绑定： 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 varDeclaredNames 为 envRec.[[VarNames]]. 若 varDeclaredNames contains N, 返回 true. 返回 false. 8.1.1.4.13 HasLexicalDeclaration ( N ) 全局环境记录的具体环境记录方法HasLexicalDeclaration确定在此记录中参数标识符是否具有绑定，该绑定是使用词法声明（例如LexicalDeclaration或ClassDeclaration）创建的： 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 DclRec 为 envRec.[[DeclarativeRecord]]. 返回 DclRec.HasBinding(N). 8.1.1.4.14 HasRestrictedGlobalProperty ( N ) 全局环境记录的具体环境记录方法HasRestrictedGlobalProperty确定参数标识符是否为全局对象的属性名称，该属性不能被全局词法绑定所遮盖： 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 ObjRec 为 envRec.[[ObjectRecord]]. 令 globalObject 为 ObjRec 的绑定对象. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N). 若 existingProp 是 undefined, 返回 false. 若 existingProp.[[Configurable]] 是 true, 返回 false. 返回 true. 注：属性可能存在于直接创建的全局对象上，而不是使用var或function声明来声明。可能不会创建与全局对象的不可配置属性同名的全局词法绑定。未定义的全局属性是此类属性的示例。 8.1.1.4.15 CanDeclareGlobalVar ( N ) 全局环境记录的具体环境记录方法CanDeclareGlobalVar确定是否对相同的参数N调用相应的CreateGlobalVarBinding调用是否将成功。允许冗余的var声明和用于预先存在的全局对象属性的var声明。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 ObjRec 为 envRec.[[ObjectRecord]]. 令 globalObject 为 ObjRec 的绑定对象. 令 hasProperty 为 ? HasOwnProperty(globalObject, N). 若 hasProperty 是 true, 返回 true. 返回 ? IsExtensible(globalObject). 8.1.1.4.16 CanDeclareGlobalFunction ( N ) 全局环境记录的具体环境记录方法CanDeclareGlobalFunction确定如果对相同的参数N进行调用，相应的CreateGlobalFunctionBinding调用是否将成功。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 ObjRec 为 envRec.[[ObjectRecord]]. 令 globalObject 为 ObjRec的绑定对象. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N). 若 existingProp 是 undefined, 返回 ? IsExtensible(globalObject). 若 existingProp.[[Configurable]] 是 true, 返回 true. 若 IsDataDescriptor(existingProp) 是 true 同时 existingProp 是 { [[Writable]]: true, [[Enumerable]]: true } 的属性值, 返回 true. 返回 false 8.1.1.4.17 CreateGlobalVarBinding ( N, D ) 全局环境记录的具体环境记录方法CreateGlobalVarBinding创建并初始化关联对象环境记录中的可变绑定，并将绑定名称记录在关联的[[VarNames]]列表中。如果绑定已经存在，则将重用它并假定已初始化。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 ObjRec 为 envRec.[[ObjectRecord]]. 令 globalObject 为 ObjRec的绑定对象. 令 hasProperty 为 ? HasOwnProperty(globalObject, N). 令 extensible 为 ? IsExtensible(globalObject). 若 hasProperty 是 false 同时 extensible 是 true, 那么 执行 ? ObjRec.CreateMutableBinding(N, D). 执行 ? ObjRec.InitializeBinding(N, undefined). 令 varDeclaredNames 为 envRec.[[VarNames]]. 若 varDeclaredNames 不包含 N, 那么 Append N 为 varDeclaredNames. 返回 NormalCompletion(empty). 8.1.1.4.18 CreateGlobalFunctionBinding ( N, V, D ) 全局环境记录的具体环境记录方法CreateGlobalFunctionBinding创建并初始化关联对象环境记录中的可变绑定，并将绑定名称记录在关联的[[VarNames]]列表中。如果绑定已经存在，则将其替换。 令 envRec 为 为函数调用时对应的全局式环境记录项. 令 ObjRec 为 envRec.[[ObjectRecord]]. 令 globalObject 为 ObjRec的绑定对象. 令 existingProp 为 ? globalObject.[[GetOwnProperty]](N). 若 existingProp 是 undefined 或者 existingProp.[[Configurable]] 是 true, 那么 令 desc 为 the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }. 否则, 令 desc 为 the PropertyDescriptor { [[Value]]: V }. 执行 ? DefinePropertyOrThrow(globalObject, N, desc). 记录 ObjRec 中 N 的绑定已被初始化. 执行 ? 设置(globalObject, N, V, false). 令 varDeclaredNames 为 envRec.[[VarNames]]. 若 varDeclaredNames 不包含 N, 那么 Append N 为 varDeclaredNames. 返回 NormalCompletion(empty). 注：全局函数声明始终表示为全局对象的自身属性。如果可能，将现有的自己的属性重新配置为具有一组标准的属性值。步骤8-9等效于调用InitializeBinding具体方法将执行的操作，并且如果globalObject是Proxy，将产生相同的Proxy trap调用序列。 8.1.1.5 模块环境记录 模块环境记录是声明性环境记录，用于表示ECMAScript模块的外部范围。除了正常的可变和不可变绑定之外，模块环境记录还提供不可变导入绑定，这些导入绑定提供了对另一个环境记录中存在的目标绑定的间接访问。 模块环境记录支持表14中列出的所有声明性环境记录方法，并且对所有这些方法都具有相同的规范，但GetBindingValue，DeleteBinding，HasThisBinding和GetThisBinding除外。此外，模块环境记录支持表19中列出的方法： 方法 目的 CreateImportBinding(N, M, N2) 在模块环境记录中创建不可变的间接绑定。 字符串值N是绑定名称的文本。 M是模块记录，N2是M的模块环境记录中存在的绑定。 GetThisBinding() 返回此环境记录的this绑定的值。 模块环境记录的其他具体规范方法的行为由以下算法定义： 8.1.1.5.1 GetBindingValue ( N, S ) 模块环境记录的具体环境记录方法GetBindingValue只是返回其绑定标识符的值，该标识符的名称为参数N的值。但是，如果绑定是间接绑定，则返回目标绑定的值。如果绑定存在但未初始化，则抛出ReferenceError。 断言: S 是 true. 令 envRec 为 为函数调用时对应的模块环境记录项. 断言: envRec 有 N 的绑定. 若 N 的绑定是间接绑定, 那么 a. 令M和N2为创建N的绑定时提供的间接值 b. 令 targetEnv 为 M.[[Environment]]. c. 若 targetEnv 是 undefined, 抛出 ReferenceError 异常. d. 令 targetER 为 targetEnv's 环境记录项. e. 返回 ? targetER.GetBindingValue(N2, true). 若 envRec中N的绑定是未初始化绑定, 抛出 ReferenceError 异常. 返回envRec中当前绑定到N的值。 注：因为模块始终是严格模式代码，所以S始终为true。 8.1.1.5.2 DeleteBinding ( N ) 模块环境记录的具体环境记录方法DeleteBinding拒绝删除绑定。 断言: 此方法不会被调用. See 12.5.3.1. 注：模块环境记录仅在严格的代码内使用，并且早期错误规则可防止在严格的代码中将delete运算符应用于将解析为模块环境记录绑定的引用。见12.5.3.1。 8.1.1.5.3 HasThisBinding ( ) 模块环境记录提供this绑定。 返回 true. 8.1.1.5.4 GetThisBinding ( ) 返回 undefined. 8.1.1.5.5 CreateImportBinding ( N, M, N2 ) 模块环境记录的具体环境记录方法CreateImportBinding为名称N创建一个新的初始化的不可变间接绑定。此环境记录中对于N的绑定必须已经不存在。M是模块记录，而N2是该绑定的名称存在于M的模块环境记录中。访问新绑定的值将间接访问目标绑定的绑定值。 令 envRec 为 为函数调用时对应的模块环境记录项. 断言: envRec 当前没有N的绑定. 断言: M 是 模块记录项. 断言: 实例化M。[[Environment]]时，它将直接绑定N2。 在envRec中为N创建一个不变的间接绑定，该间接绑定引用M和N2作为其目标绑定，并记录该绑定已初始化。 返回 NormalCompletion(empty). 8.1.2 词法环境操作 本规范中使用以下抽象操作在词汇环境上进行操作： 8.1.2.1 GetIdentifierReference ( lex, name, strict ) 抽象操作GetIdentifierReference用词法环境lex，字符串name和布尔标志strict调用。lex的值可以为null。调用时，将执行以下步骤： 若 lex 的值为 null, 那么 返回类型为Reference的值，其基值部分为undefined，其引用名称部分为name，其严格引用标志为strict。 令 envRec 为 lex 的环境记录项. 令 exists 为 ? envRec.HasBinding(name). 若 exists 是 true, 那么 返回类型为Reference的值，其基值部分为envRec，其引用名称部分为name，其严格引用标志为strict。 否则, 令 outer 为 lex 的外部环境引用的值. 返回 ? GetIdentifierReference(outer, name, strict). 8.1.2.2 NewDeclarativeEnvironment ( E ) 当使用词法环境作为参数E调用抽象操作NewDeclarativeEnvironment时，将执行以下步骤： 令 env 为 新的词法环境 令 envRec 为 a new declarative Environment Record containing no bindings. 设置 env's 环境记录项 为 envRec. 设置 env的外部词法环境引用 为 E. 返回 env. 8.1.2.3 NewObjectEnvironment ( O, E ) 以对象O和词法环境E作为参数调用抽象操作NewObjectEnvironment时，将执行以下步骤： 令 env 为新的词法环境. 令 envRec 为新对象环境记录项，其中包含O作为绑定对象 设置 env's 环境记录项为 envRec. 设置 env 的外部词法环境引用为 E. 返回 env. 8.1.2.4 NewFunctionEnvironment ( F, newTarget ) 当使用参数F和newTarget调用抽象操作NewFunctionEnvironment时，将执行以下步骤： 断言: F 是 ECMAScript 函数. 断言: Type(newTarget) 是 Undefined 或 Object. 令 env 为新的词法环境. 令 envRec 为 没有绑定的新函数环境记录项. 设置 envRec.[[FunctionObject]] 为 F. 若 F.[[ThisMode]] 是 lexical, 设置 envRec.[[ThisBindingStatus]] 为 \"lexical\". 否则, 设置 envRec.[[ThisBindingStatus]] 为 \"uninitialized\". 令 home 为 F.[[HomeObject]]. 设置 envRec.[[HomeObject]] 为 home. 设置 envRec.[[NewTarget]] 为 newTarget. 设置 env's 环境记录项为 envRec. 设置 env 的外部词法环境记录项为 F.[[Environment]]. 返回 env. 8.1.2.5 NewGlobalEnvironment ( G, thisValue ) 当使用参数G和thisValue调用抽象操作NewGlobalEnvironment时，将执行以下步骤： 令 env 为新的词法环境. 令 objRec 为包含G作为绑定对象的新对象环境记录项. 令dclRec为不包含绑定的新的声明性环境记录。 令 globalRec 为新的全局环境记录项 设置 globalRec.[[ObjectRecord]] 为 objRec. 设置 globalRec.[[GlobalThisValue]] 为 thisValue. 设置 globalRec.[[DeclarativeRecord]] 为 dclRec. 设置 globalRec.[[VarNames]] 为空数组 设置 env's 环境记录项为 globalRec. 设置 env 的外部词法环境引用为 null. 返回 env. 8.1.2.6 NewModuleEnvironment ( E ) 当使用词法环境参数E调用抽象操作NewModuleEnvironment时，将执行以下步骤： 令 env 为新的词法环境. 令 envRec 为不包含绑定的新模块环境记录项。 设置 env's 环境记录项 为 envRec. 设置 env的外部词法环境引用为 E. 返回 env. 8.2 作用域 在执行之前，必须将所有ECMAScript代码与一个作用域相关联。从概念上讲，作用域由一组内部对象，一个ECMAScript全局环境，在该全局环境范围内加载的所有ECMAScript代码以及其他关联的状态和资源组成。 在本规范中，作用域以表20中指定的字段表示为作用域记录： 字段名 值 含义 [[Intrinsics]] 记录其字段名称是内在键且其值是对象的记录 与该作用域相关联的代码使用的内在值 [[GlobalObject]] Object 此作用域的全局对象 [[GlobalEnv]] 词法环境 这个作用域的全局环境 [[TemplateMap]] 一组 Record { [[Site]]: Parse Node, [[Array]]: Object }. 使用其作用域记录的[[TemplateMap]]为每个作用域分别规范化模板对象。每个[[Site]]值都是作为TemplateLiteral的解析节点。关联的[[Array]]值是传递给标签函数的相应模板对象。注：一旦解析节点变得不可访问，相应的[[Array]]也将不可访问，并且如果实现从[[TemplateMap]]列表中删除该对，则将不可观察。 [[HostDefined]] 任何，默认值是不确定的。 保留该字段供需要将其他信息与作用域记录项关联的主机环境使用。 8.2.1 CreateRealm ( ) 不带参数的抽象操作CreateRealm执行以下步骤： 令 realmRec 为新的作用域记录项. 执行 CreateIntrinsics(realmRec). 设置 realmRec.[[GlobalObject]] 为 undefined.d 设置 realmRec.[[GlobalEnv]] 为 undefined. 设置 realmRec.[[TemplateMap]] 为新的空数组. 返回 realmRec 8.2.2 CreateIntrinsics ( realmRec ) 具有参数realmRec的抽象操作CreateIntrinsics执行以下步骤： 令 intrinsics 为新的记录项. 设置 realmRec.[[Intrinsics]] 为 intrinsics. 令 objProto 为 ObjectCreate(null). 设置 intrinsics.[[%ObjectPrototype%]] 为 objProto. 令throwerSteps为9.2.9.1中为％ThrowTypeError％函数指定的算法步骤。 令 thrower 为 CreateBuiltinFunction(throwerSteps, « », realmRec, null). 设置 intrinsics.[[%ThrowTypeError%]] 为 thrower. 令 noSteps 为空的算法步骤序列。 令 funcProto 为 CreateBuiltinFunction(noSteps, « », realmRec, objProto). 设置 intrinsics.[[%FunctionPrototype%]] 为 funcProto. 调用 thrower.[[SetPrototypeOf]](funcProto). 执行 AddRestrictedFunctionProperties(funcProto, realmRec). 使用表7中列出的尚未设置的内部值设置内部字段。字段名称是表第一列中列出的名称。每个字段的值是一个新的对象值，该对象值完全并递归地填充有第18-26节中每个对象的规范所定义的属性值。所有对象属性值都是新创建的对象值。通过执行CreateBuiltinFunction（\\，\\，realmRec，\\）创建所有内置函数对象的值，其中\\是此规范提供的该函数的定义，\\是列表函数的指定内部插槽的名称（如果有的话）的名称，\\是函数的[[Prototype]]内部插槽的指定值。必须对内部函数及其属性的创建进行排序，以避免依赖于尚未创建的对象。 返回 intrinsics. 8.2.3 SetRealmGlobalObject ( realmRec, globalObj, thisValue ) 具有参数realmRec，globalObj和thisValue的抽象操作SetRealmGlobalObject执行以下步骤： 若 globalObj 是 undefined, 那么 令 intrinsics 为 realmRec.[[Intrinsics]]. 设置 globalObj 为 ObjectCreate(intrinsics.[[%ObjectPrototype%]]). 断言: Type(globalObj) 是 Object. 若 thisValue is undefined, 设置 thisValue 为 globalObj. 设置 realmRec.[[GlobalObject]] 为 globalObj. 令 newGlobalEnv 为 NewGlobalEnvironment(globalObj, thisValue). 设置 realmRec.[[GlobalEnv]] 为 newGlobalEnv. 返回 realmRec. 8.2.4 SetDefaultGlobalBindings ( realmRec ) 具有参数realmRec的抽象操作SetDefaultGlobalBindings执行以下步骤： 令 global 为 realmRec.[[GlobalObject]]. 对于第18条中指定的全局对象的每个属性，执行 令 name 为属性名的String值。 令desc为该属性的完全填充的数据属性描述符，其中包含该属性的指定属性。对于在18.2、18.3或18.4中列出的属性，[[Value]]属性的值是realmRec中对应的固有对象。 执行 ? DefinePropertyOrThrow(global, name, desc). 返回 global. 8.3 可执行上下文 执行上下文是一种规范，用于追踪ECMAScript规范的运行时代码。在任何时间点，每个实际执行代码的代理程序最多有一个执行上下文。这称为代理的运行执行上下文。本规范中对运行中执行上下文的所有引用均表示周围代理的运行中执行上下文。 执行上下文堆栈用于跟踪执行上下文。运行中的执行上下文始终是此堆栈的顶部元素。每当控制权从与当前正在运行的执行上下文关联的可执行代码转移到与该执行上下文不关联的可执行代码时，都会创建一个新的执行上下文。新创建的执行上下文被压入堆栈，并成为正在运行的执行上下文。 执行上下文包含跟踪其关联代码的执行进度所需的任何特定于实现的状态。每个执行上下文至少具有表21中列出的状态组件。 组件 目的 code evaluation state 执行，暂停和恢复与该执行上下文相关联的代码的执行所需的任何状态。 Function 如果这个执行环境正在执行函数对象的代码，那么这个组件的值就是该函数对象。 如果上下文执行脚本或模块的代码，则该值为null。 Realm 相关代码访问ECMAScript资源的作用域记录项。 ScriptOrModule 关联代码源自的模块记录或脚本记录。 如果没有原始脚本或模块，那么在 InitializeHostDefinedRealm，值为null 通过运行的执行上下文对代码的评估可以在本规范中定义的各个点暂停。一旦正在运行的执行上下文已被挂起，则其他执行上下文可能会成为正在运行的执行上下文并开始评估其代码。在稍后的某个时间，挂起的执行上下文可能会再次变为运行中的执行上下文，并在先前被挂起的位置继续评估其代码。执行上下文之间正在运行的执行上下文状态的转换通常以类似堆栈的后进先出方式发生。但是，某些ECMAScript功能要求正在运行的执行上下文进行非LIFO转换。 正在运行的执行上下文的作用域组件的值也称为当前作用域记录。正在运行的执行上下文的Function组件的值也称为活动函数对象。 ECMAScript代码的执行上下文具有表22中列出的其他状态组件。 组件 目的 LexicalEnvironment 标识用于解析在此执行上下文中由代码创建的标识符引用的词汇环境。 VariableEnvironment 标识其环境记录项保存由VariableStatements在此执行上下文中创建的绑定的词汇环境。 执行上下文的LexicalEnvironment和VariableEnvironment组件始终是词法环境 表示生成器对象评估的执行上下文具有表23中列出的其他状态组件。 组件 目的 Generator 该执行上下文正在执行的GeneratorObject。 在大多数情况下，仅运行中的执行上下文（执行上下文堆栈的顶部）由该规范中的算法直接操作。因此，当使用术语“ LexicalEnvironment”和“ VariableEnvironment”而没有限定条件时，它们是指正在运行的执行上下文的那些组件。 执行上下文纯粹是一种规范机制，不需要与ECMAScript实现的任何特定工件相对应。ECMAScript代码不可能直接访问或观察执行上下文。 8.3.1 GetActiveScriptOrModule ( ) GetActiveScriptOrModule抽象操作用于根据运行的执行上下文确定运行的脚本或模块。GetActiveScriptOrModule执行以下步骤： 若执行上下文堆栈为空, 返回 null. 令 ec 为 ScriptOrModule 组件不为 null 的执行上下文堆栈上的最高执行上下文。 若不存在这样的执行上下文, 返回 null. Otherwise, 返回 ec的 ScriptOrModule 组件. 8.3.2 ResolveBinding ( name [ , env ]) ResolveBinding抽象操作用于确定作为字符串值传递的名称的绑定。可选参数env可用于显式提供要搜索绑定的词法环境。在执行ECMAScript代码期间，使用以下算法执行ResolveBinding： 若 env 不存在或者 env 是 undefined, 那么 设置 env 为运行时执行上下文的词法环境 断言: env 是一个词法环境 如果在严格模式代码中包含与要评估的语法产生匹配的代码，则令strict为true，否则令strict为false。 返回 ? GetIdentifierReference(env, name, strict). 注：ResolveBinding的结果始终是一个Reference值，其引用的名称分量等于name参数。 8.3.3 GetThisEnvironment ( ) 抽象操作GetThisEnvironment查找当前提供关键字this绑定的环境记录。GetThisEnvironment执行以下步骤： 令 lex 为 运行时执行上下文的词法环境 重复, 令 envRec 为 lex的环境记录项. 令 exists 为 envRec.HasThisBinding(). 若 exists is true, 返回 envRec. 令 outer 为 lex的外部环境引用的值 断言: outer 不是null 设置 lex 为 outer. 注：步骤2中的循环将始终终止，因为环境列表始终以具有this绑定的全局环境结尾 8.3.4 ResolveThisBinding ( ) 抽象操作ResolveThisBinding使用正在运行的执行上下文的LexicalEnvironment确定关键字this的绑定。ResolveThisBinding执行以下步骤： 令 envRec 为 GetThisEnvironment(). 返回 ? envRec.GetThisBinding(). 8.3.5 GetNewTarget ( ) 抽象操作GetNewTarget使用正在运行的执行上下文的LexicalEnvironment确定NewTarget值。GetNewTarget执行以下步骤： 令 envRec 为 GetThisEnvironment(). 断言: envRec 有 [[NewTarget]] 字段. 返回 envRec.[[NewTarget]]. 8.3.6 GetGlobalObject ( ) 抽象操作GetGlobalObject返回当前运行的执行上下文使用的全局对象。GetGlobalObject执行以下步骤： 令 ctx 为运行时执行上下文 令 currentRealm 为 ctx's 作用域. 返回 currentRealm.[[GlobalObject]]. 8.4 任务和任务队列 Job是抽象操作，当目前没有其他ECMAScript计算正在进行时，它将启动ECMAScript计算。可以将任务抽象操作定义为接受任意一组任务参数。 仅当没有正在运行的执行上下文并且执行上下文堆栈为空时，才能启动任务的执行。PendingJob是对将来执行任务的请求。PendingJob是内部记录，其字段在表24中指定。启动任务的执行后，任务将始终执行到完成。当前正在运行的任务完成之前，无法启动其他任务。但是，当前正在运行的任务或外部事件可能会导致其他PendingJob排队，这些任务可能在当前正在运行的任务完成后的某个时间启动。 字段名 值 含义 [[Job]] 任务抽象操作的名称 这是在启动此PendingJob的执行时执行的抽象操作。 任务是使用NextJob而不是返回表示它们已经完成的抽象操作。 [[Arguments]] 一个数组 激活时要传递给[[Job]]的参数值列表。 [[Realm]] 一个 作用域 记录 当此PendingJob启动时，用于初始执行上下文的作用域记录。 [[ScriptOrModule]] 脚本记录或者模块记录 当此PendingJob启动时，用于初始执行上下文的脚本或模块。 [[HostDefined]] 任意，默认值为 undefined 字段保留供主要环境使用，需要将附加信息与挂起的任务相关联。 任务队列是PendingJob记录的FIFO队列。每个任务队列都有一个名称，并且可用的任务队列的完整集合由ECMAScript实现定义。每个ECMAScript实现都至少具有表25中定义的任务队列。 每个代理都有其自己的一组命名任务队列。本规范中对命名任务队列的所有引用均表示周围代理的命名任务队列。 名称 目的 ScriptJobs 验证和执行ECMAScript脚本和模块源文本的作业。 见第10和15章节。 PromiseJobs 解决承诺(Promise)的作业（见25.4）。 通过在任务队列上使包含任务抽象操作名称和任何必要参数值的PendingJob记录入队，来请求将来执行任务。当没有正在运行的执行上下文并且执行上下文堆栈为空时，ECMAScript实现将从任务队列中删除第一个PendingJob并使用其中包含的信息来创建执行上下文并开始执行关联的Job抽象操作 来自单个任务队列的PendingJob记录始终以FIFO顺序启动。该规范未定义服务多个任务队列的顺序。ECMAScript实现可以将任务队列的PendingJob记录的FIFO评估与一个或多个其他任务队列的PendingJob记录的评估交织在一起。一个实现必须定义在没有运行的执行上下文并且所有任务队列为空时会发生什么 注：通常，ECMAScript实现将使用至少一个PendingJob预先初始化其任务队列，并且其中一个任务将是第一个要执行的任务。如果当前任务完成并且所有任务队列为空，则实现可以选择释放所有资源并终止。或者，它可以选择等待某些特定于实现的代理或机制来排队新的PendingJob请求。 以下抽象操作用于创建和管理任务和任务队列： 8.4.1 EnqueueJob ( queueName, job, arguments ) EnqueueJob抽象操作需要三个参数：queueName，job和arguments。它执行以下步骤： 断言: Type(queueName) 为String，其值为该实现识别的任务队列的名称。 断言: job 是任务的名称. 断言: arguments是一个List，其元素数与job所需的参数数相同。 令 callerContext 为运行时执行上下文. 令 callerRealm 为 callerContext's 作用域. 令 callerScriptOrModule 为 callerContext's ScriptOrModule. 令 pending 为 PendingJob { [[Job]]: job, [[Arguments]]: arguments, [[Realm]]: callerRealm, [[ScriptOrModule]]: callerScriptOrModule, [[HostDefined]]: undefined }. 执行任何实现或宿主环境定义的pending处理。这可能包括修改[[HostDefined]]字段或任何其他未决字段。 在由queueName命名的任务队列的后面添加pending 返回 NormalCompletion(empty). 8.5 InitializeHostDefinedRealm ( ) 抽象操作InitializeHostDefinedRealm执行以下步骤： 令 realm 为 CreateRealm(). 令 newContext 为新的执行上下文. 设置 newContext 的函数为 null. 设置 newContext 的作用域为 realm. 设置 the ScriptOrModule of newContext 为 null. 将newContext推入执行上下文堆栈；newContext现在是运行中的执行上下文 如果宿主要求使用异类对象作为作用域的全局对象，则将global设为以实现定义的方式创建的对象。否则，请使global为undefined，表示应将普通对象创建为全局对象 如果宿主要求作用域的全局范围中的this绑定返回除全局对象之外的对象，则使thisValue为以实现定义的方式创建的此类对象。否则，请使thisValue处于未定义状态，指示作用域的全局this绑定应为全局对象。 执行 SetRealmGlobalObject(realm, global, thisValue). 令 globalObj 为 ? SetDefaultGlobalBindings(realm). 在globalObj上创建任何实现定义的全局对象属性。 返回 NormalCompletion(empty). 8.6 RunJobs ( ) 抽象操作RunJobs执行以下步骤： 执行 ? InitializeHostDefinedRealm(). 以依赖于实现的方式，获取ECMAScript源文本（请参见第10节）以及零个或多个ECMAScript脚本和/或ECMAScript模块的任何主机定义的关联值。对于每个这样的sourceText和hostDefined，执行 若 sourceText 是脚本的源码，那么 执行 EnqueueJob(\"ScriptJobs\", ScriptEvaluationJob, « sourceText, hostDefined »). Else sourceText 是模块的源码 执行 EnqueueJob(\"ScriptJobs\", TopLevelModuleEvaluationJob, « sourceText, hostDefined »). 重复, 挂起正在运行的执行上下文，并将其从执行上下文堆栈中删除。 断言: 执行上下文堆栈现在为空。 令nextQueue为以实现定义的方式选择的非空任务队列。如果所有任务队列都为空，则结果是实现定义的。 令nextPending为nextQueue前面的PendingJob记录。从nextQueue中删除该记录。 令 newContext 为新的执行上下文. 设置 newContext's Function 为 null. 设置 newContext's Realm 为 nextPending.[[Realm]]. 设置 newContext's ScriptOrModule 为 nextPending.[[ScriptOrModule]]. 将newContext推入执行上下文堆栈；newContext现在是运行中的执行上下文。 使用nextPending执行任何实现或宿主环境定义的任务初始化 令result为使用nextPending。[[Arguments]]的元素作为其参数执行nextPending。[[Job]]命名的抽象操作的结果。 若 result 是 abrupt completion, 执行 HostReportErrors(« result.[[Value]] ») 8.7 代理 代理包括一组ECMAScript执行上下文，一个执行上下文堆栈，一个正在运行的执行上下文，一组命名任务队列，一个代理记录和一个执行线程。除执行线程外，代理的组成部分完全属于该代理。 代理程序的执行线程独立于其他代理程序在代理程序的执行上下文上执行该代理程序的工作队列中的任务，除非多个线程可以将一个执行线程用作执行线程，前提是共享该线程的所有代理都不具有代理程序记录其[[CanBlock]]属性为true。 注：例如，某些Web浏览器跨浏览器窗口的多个不相关的选项卡共享一个执行线程。 当代理的执行线程执行代理任务队列中的任务时，该代理是这些任务中代码的周围代理。该代码使用周围的代理访问该代理内保存的规范级别执行对象：正在运行的执行上下文，执行上下文堆栈，命名的任务队列和代理记录的字段。 字段名 值 含义 [[LittleEndian]] Boolean 算法GetValueFromBuffer和SetValueInBuffer在需要时为isLittleEndian参数计算的默认值。选择取决于实现，并且应该是对实现最有效的选择。一旦观察到该值，就无法更改。 [[CanBlock]] Boolean 确定代理是否可以阻止。 [[Signifier]] 任何全局唯一值 在其代理群集中唯一标识代理。 [[IsLockFree1]] Boolean 如果对一字节值的原子操作是无锁的，则为true，否则为false。 [[IsLockFree2]] Boolean 如果对一字节值的原子操作是无锁的，则为true，否则为false。 [[CandidateExecution]] 候选执行记录 请参阅内存模型。 一旦代理群集中的任何代理观察到[[Signifier]]，[[IsLockFree1]]和[[IsLockFree2]]的值，它们就无法更改。 注2：[[IsLockFree1]]和[[IsLockFree2]]的值不一定由硬件确定，但也可能反映了实现选择，这些选择会随着时间的推移以及ECMAScript实现之间的变化而变化。 没有[[IsLockFree4]]属性：4字节原子操作始终是无锁的。 实际上，如果用任何类型的锁来实现原子操作，则该操作不是无锁的。无锁并不意味着无等待：完成无锁原子操作可能需要多少机器步骤没有上限。 大小为n的原子访问是无锁的，并不意味着有关大小为n的非原子访问的（感知）原子性，特别是，非原子访问仍可以作为几个单独的内存访问的序列来执行。有关详细信息，请参见ReadSharedMemory和WriteSharedMemory。 注3：代理是一种规范机制，不需要与ECMAScript实现的任何特定工件相对应。 8.7.1 AgentSignifier ( ) 抽象操作AgentSignifier不接受任何参数。它执行以下步骤： 令 AR 为周围代理的代理记录项 返回 AR.[[Signifier]]. 8.7.2 AgentCanSuspend ( ) 抽象操作AgentCanSuspend不接受任何参数。它执行以下步骤： 注：在某些环境中，暂停给定的代理可能并不合理。例如，在Web浏览器环境中，禁止挂起文档的主事件处理线程，同时仍然允许工作者的事件处理线程挂起，可能是合理的。 8.8 代理集群 代理群集是可以通过在共享内存上进行操作进行通信的最大代理集。 注1：不同代理中的程序可能通过未指定的方式共享内存。至少，可以在群集中的代理之间共享SharedArrayBuffer对象的后备内存。 可能有一些代理可以通过消息传递进行通信，而这些消息不能共享内存。他们永远不在同一座席集群中 每个代理都完全属于一个代理群集。 注2：集群中的代理不必在某个特定时间点都处于活动状态。如果代理A创建另一个代理B，然后A终止并且B创建了代理C，则如果A可以与B共享一些内存并且B可以与C共享一些内存，则这三个代理位于同一群集中。 群集中所有代理的各自代理记录中的[[LittleEndian]]属性必须具有相同的值。 注3：如果代理群集中的不同代理具有不同的[[LittleEndian]]值，则很难将共享内存用于多字节数据。 群集中的所有代理程序在其各自的代理程序记录中的[[IsLockFree1]]属性必须具有相同的值；对于[[IsLockFree2]]属性也是如此。 群集中的所有代理程序在其各自的代理程序记录中的[[Signifier]]属性必须具有不同的值。 在代理不知情或不合作的情况下，嵌入可能会使其无效（停止前进）或激活（继续前进）。如果嵌入这样做，则一定不能使集群中的某些代理处于活动状态，而集群中的其他代理会无限期停用。 注4：前述限制的目的是避免由于另一个代理已被停用而导致代理死锁或饥饿的情况。例如，如果允许一个寿命独立于任何窗口中的文档的HTML共享工作程序与这样一个独立文档的专用工作程序共享内存，并且在专用工作程序保持不动的同时，将停用该文档及其专用工作程序。锁定（例如，文档被推入其窗口的历史记录中），然后共享工作器尝试获取该锁定，然后共享工作器将被阻塞，直到再次激活专用工作器为止（如果有的话）。同时，其他尝试从其他窗口访问共享工作者的工作者也会挨饿。 限制的含义是，不可能在嵌入中不属于同一挂起/唤醒集合的代理之间共享内存。 嵌入可能会在没有代理集群其他代理的任何先验知识或合作的情况下终止代理。如果代理不是通过自身或集群中其他代理的编程动作而是通过集群外部的作用来终止的，则嵌入必须选择以下两种策略之一：终止集群中的所有代理，或提供可靠的API允许群集中的代理进行协调，以便群集中至少有一个剩余成员能够检测到终止，终止数据包含足够的信息以标识已终止的代理。 注5：这种终止的例子有：操作系统或用户终止在单独进程中运行的代理；当每个代理程序资源记帐指示该代理程序失控时，嵌入本身将终止与其他代理程序一起在进程中运行的代理程序。 在集群中的任何代理对任何ECMAScript代码进行任何评估之前，将集群中所有代理的“代理记录”的[[CandidateExecution]]字段设置为初始候选执行。最初的候选执行是一个空的候选执行，其[[EventsRecords]]字段是一个列表，对于每个代理，该列表包含一个Agent事件记录，其[[AgentSignifier]]字段是该代理的指示符，并且其[[EventList]]和[[AgentSynchronizesWith]]字段为空列表 注6：代理群集中的所有代理在其代理记录[[候选执行]]字段中共享相同的候选执行。候选执行是内存模型使用的指定机制。 注7：代理集群是一种规范机制，不需要与ECMAScript实现的任何特定工件相对应。 8.9 前进进度 代理商要取得进步，就是要执行根据此规范的评估步骤。 当代理的正在运行的执行上下文无限期地同步等待外部事件时，该代理将被阻塞。在这种情况下，只有座席记录的[[CanBlock]]属性为true的座席才能被阻止。未被阻止的代理是未被阻止的代理。 实施必须确保： ​ 每个具有专用执行线程的未阻塞代理程序最终都会在共享执行线程的一组代理程序中前进，一个代理程序最终会使代理程序向前前进，除非通过提供阻塞的显式API，否则该代理程序不会导致另一个代理程序被阻塞。 注：这与内存模型中的活动性保证一起，确保所有“ SeqCst”写入最终对于所有代理都是可见的。 词法环境是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个环境记录项和可能为空的外部词法环境引用构成。通常词法环境会与 ECMAScript 代码诸如 FunctionDeclaration、WithStatement 或者 TryStatement 的 Catch 块这样的特定句法结构相联系，且类似代码每次执行都会有一个新的词法环境被创建出来。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,可执行代码和可执行上下文,lexical-environments "},"ordinary-and-exotic-object-behaviours.html":{"url":"ordinary-and-exotic-object-behaviours.html","title":"9 普通和异类对象行为","keywords":"","body":"9 普通和异类对象行为 9.1 普通对象内部方法和内部插槽 所有普通对象都有一个称为[[Prototype]]的内部插槽。此内部插槽的值可以为null或一个对象，用于实现继承。[[Prototype]]对象的数据属性被继承（作为子对象的属性可见），是为了取值权限，而不是赋值权限。访问器属性被继承，同时获得取值权限和赋值权限。 每个普通对象都有一个布尔值的[[Extensible]]内部插槽，该插槽用于实现6.1.7.3中指定的与扩展性相关的内部方法不变量。即，一旦将对象的[[Extensible]]内部插槽的值设置为false，就无法再向该对象添加属性、修改该对象的[[Prototype]]内部插槽的值或随后将[[Extensible]]的值更改为true。 在以下算法描述中，假定O为普通对象，P为属性键值，V为任何ECMAScript语言值，而Desc为属性描述符记录。 每个普通对象的内部方法都委托一个名称相似的抽象操作。如果这样的抽象操作依赖于另一个内部方法，则在O上调用内部方法，而不是直接调用类似名称的抽象操作。这些语义确保将普通对象内部方法应用于异类对象时，将调用其覆盖的内部方法。 9.1.1 [[GetPrototypeOf]] ( ) 调用O的[[GetPrototypeOf]]内部方法时，将执行以下步骤： 返回 ! OrdinaryGetPrototypeOf(O). 9.1.1.1 OrdinaryGetPrototypeOf ( O ) 当使用对象O调用抽象操作 OrdinaryGetPrototypeOf 时，将执行以下步骤： 返回 O.[[Prototype]] 9.1.2 [[SetPrototypeOf]] ( V ) 使用参数V调用O的[[SetPrototypeOf]]内部方法时，将执行以下步骤： 返回 ! OrdinarySetPrototypeOf(O, V). 9.1.2.1 OrdinarySetPrototypeOf ( O, V ) 当使用对象O和值V调用抽象操作OrdinarySetPrototypeOf时，将执行以下步骤： 断言:Type(V) 是 Object 或 Null. 令 extensible 为 O.[[Extensible]]. 令 current 为 O.[[Prototype]]. 若 SameValue(V, current) 是 true, 返回 true. 若 extensible 是 false, 返回 false. 令 p 为 V. 令 done 为 false. 重复, 直到 done 是 false, 若 p 是 null, 设置 done 为 true. 否则如果 SameValue(p, O) 是 true, 返回 false. 否则, 若 p.[[GetPrototypeOf]] 不是在 9.1.1 定义的普通内部方法, 设置 done 为 true. 否则, 设置 p 为 p.[[Prototype]]. 设置 O.[[Prototype]] 为 V. 返回 true. 注：步骤8中保证在任何原型链中都不会存在循环，该原型链仅包括使用[[GetPrototypeOf]]和[[SetPrototypeOf]]的普通对象定义的对象。 9.1.3 [[IsExtensible]] ( ) 调用O的[[IsExtensible]]内部方法时，将执行以下步骤： 返回 ! OrdinaryIsExtensible(O). 9.1.3.1 OrdinaryIsExtensible ( O ) 当使用对象O调用抽象操作OrdinaryIsExtensible时，将执行以下步骤： 返回 O.[[Extensible]]. 9.1.4 [[PreventExtensions]] ( ) 调用O的[[PreventExtensions]]内部方法时，将执行以下步骤： 返回 ! OrdinaryPreventExtensions(O) 9.1.4.1 OrdinaryPreventExtensions ( O ) 当使用对象 O 调用抽象操作 OrdinaryPreventExtensions 时，将采取以下步骤： 设置 O.[[Extensible]] 为 false. 返回 true. 9.1.5 [[GetOwnProperty]] ( P ) 使用属性键P调用O的[[GetOwnProperty]]内部方法时，将执行以下步骤： 返回 ! OrdinaryGetOwnProperty(O, P). 9.1.5.1 OrdinaryGetOwnProperty ( O, P ) 当使用对象O和属性键P调用抽象操作OrdinaryGetOwnProperty时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 如果 O 没有使用键P的私有属性，返回 undefined. 令 D 为没有字段的新创建的属性描述符 令 X 为 O 的自有属性，其键为 P。 若 X 是一个数据属性, 那么 a. 设置 D.[[Value]] 为 X 的 [[Value]] 属性值. 设置 D.[[Writable]] 为X 的 [[Writable]] 属性值 否则 X 是访问器属性, a. 设置 D.[[Get]] 为X 的 [[Get]] 属性值 设置 D.[[Set]] 为X 的 [[Set]] 属性值. 设置 D.[[Enumerable]] 为X 的 [[Enumerable]] 属性值 设置 D.[[Configurable]] 为X 的 [[Configurable]] 属性值 返回 D. 9.1.6 [[DefineOwnProperty]] ( P, Desc ) 使用属性键P和属性描述符Desc调用O的[[DefineOwnProperty]]内部方法时，将执行以下步骤： 返回 ? OrdinaryDefineOwnProperty(O, P, Desc). 9.1.6.1 OrdinaryDefineOwnProperty ( O, P, Desc ) 当使用对象O，属性键P和属性描述符Desc调用抽象操作OrdinaryDefineOwnProperty时，将执行以下步骤： 令 current 为 ? O.[[GetOwnProperty]](P). 令 extensible 为 ? IsExtensible(O). 返回 ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current). 9.1.6.2 IsCompatiblePropertyDescriptor ( Extensible, Desc, Current ) 当使用布尔值Extensible、属性描述符Desc和Current调用抽象操作IsCompatiblePropertyDescriptor时，将执行以下步骤： 返回 ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current). 9.1.6.3 ValidateAndApplyPropertyDescriptor ( O, P, extensible, Desc, current ) 当使用对象O，属性键P，布尔值可扩展，属性描述符Desc和当前调用抽象操作ValidateAndApplyPropertyDescriptor时，将执行以下步骤： 注：如果将undefined传递为O，则仅执行验证，并且不执行对象更新。 断言: 若 O 不是 undefined, 那么 IsPropertyKey(P) 是 true. 若 current 是 undefined, 那么 若 extensible 是 false, 返回 false. 断言: extensible 是 true. 若 IsGenericDescriptor(Desc) 是 true 或 IsDataDescriptor(Desc) 是 true, 那么 若 O 不是 undefined, 创建一个名为P的私有数据属性，对象 O 的[[Value]], [[Writable]],[[Enumerable]] 和 [[Configurable]] 属性值用Desc来描述。若Desc的属性字段值不存在, 新创建的属性的属性设置为其默认值。 否则 Desc 必须为访问器属性， 若 O 不是 undefined, 创建一个名为P的私有访问器属性，对象 O 的[[Get]], [[Set]],[[Enumerable]] 和 [[Configurable]] 属性用Desc来描述。若Desc的属性字段值不存在, 新创建的属性的属性设置为其默认值。 返回 true. 若 Desc 的每一个字段都不存在, 返回 true. 若 current.[[Configurable]] 是 false, 那么 若 Desc.[[Configurable]] 存在且值为 true, 返回 false. 若 Desc.[[Enumerable]] 存在，并且[[Enumerable]] 字段的 current 和 Desc 布尔值互斥，返回 false. 若 IsGenericDescriptor(Desc) 是 true, 无需进一步验证。 否则若 IsDataDescriptor(current) 和 IsDataDescriptor(Desc) 结果不一样, 那么 若 current.[[Configurable]] 是 false, 返回 false. 若 IsDataDescriptor(current) 是 true, 那么 若 O 不是undefined，则将对象 O 的名为 P 的属性从数据属性转换为访问器属性。保留转换后属性的[[Configurable]]和[[Enumerable]]特性的现有值，并将该属性的其余特性设置为其默认值。 否则, 若 O 不是 undefined，则将对象 O 的名为 P 的属性从访问器属性转换为数据属性。保留转换后属性的[[Configurable]]和[[Enumerable]]特性的现有值，并将该属性的其余特性设置为其默认值。 否则若 IsDataDescriptor(current) 和 IsDataDescriptor(Desc) 都是 true, 那么 若 current.[[Configurable]] 是 false ，同时 current.[[Writable]] 是 false, 那么 若 Desc.[[Writable]] 存在， 并且 Desc.[[Writable]] 是 true，返回 false. 若 Desc.[[Value]] 存在，并且 SameValue(Desc.[[Value]], current.[[Value]]) 是 false, 返回 false. . 返回 true. 否则 IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true, 若 current.[[Configurable]] 是 false, 那么 若 Desc.[[Set]] 存在 and SameValue(Desc.[[Set]], current.[[Set]]) 是 false, 返回 false. 若 Desc.[[Get]] 存在 and SameValue(Desc.[[Get]], current.[[Get]]) 是 false, 返回 false. 返回 true. 若 O 不是 undefined, 那么 对于存在的Desc的每个字段，将对象 O 的名为 P 的属性的相应属性设置为该字段的值。 返回 true. 9.1.7 [[HasProperty]] ( P ) 使用属性键P调用O的[[HasProperty]]内部方法时，将执行以下步骤： 返回 ? OrdinaryHasProperty(O, P). 9.1.7.1 OrdinaryHasProperty ( O, P ) 当使用对象O和属性键P调用抽象操作OrdinaryHasProperty时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 hasOwn 为 ? O.[[GetOwnProperty]](P). 若 hasOwn 不是 undefined, 返回 true. 令 parent 为 ? O.[[GetPrototypeOf]](). 若 parent 不是 null, 那么 a. 返回 ? parent.[[HasProperty]](P). 返回 false. 9.1.8 [[Get]] ( P, Receiver ) 使用属性键P和ECMAScript语言值Receiver调用O的[[Get]]内部方法时，将执行以下步骤： 返回 ? OrdinaryGet(O, P, Receiver). 9.1.8.1 OrdinaryGet ( O, P, Receiver ) 当使用对象O，属性键P和ECMAScript语言值Receiver调用抽象操作OrdinaryGet时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 desc 为 ? O.[[GetOwnProperty]](P). 若 desc 是 undefined, 那么 令 parent 为 ? O.[[GetPrototypeOf]](). 若 parent 是 null, 返回 undefined. 返回 ? parent.[[Get]](P, Receiver). 若 IsDataDescriptor(desc) 是 true, 返回 desc.[[Value]]. 断言: IsAccessorDescriptor(desc) 是 true. 令 getter 为 desc.[[Get]]. 若 getter 是 undefined, 返回 undefined. 返回 ? Call(getter, Receiver). 9.1.9 [[Set]] ( P, V, Receiver ) 当使用属性键P，值V和ECMAScript语言值Receiver调用O的[[Set]]内部方法时，将执行以下步骤： 返回 ? OrdinarySet(O, P, V, Receiver). 9.1.9.1 OrdinarySet ( O, P, V, Receiver ) 当使用对象O，属性键P，值V和ECMAScript语言值Receiver调用抽象操作OrdinarySet时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 ownDesc 为 ? O.[[GetOwnProperty]](P). 返回 OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc). 9.1.9.2 OrdinarySetWithOwnDescriptor ( O, P, V , Receiver, ownDesc ) 当使用对象O，属性键P，值V，ECMAScript语言值Receiver和属性描述符（可能为undefined）ownDesc调用抽象操作OrdinarySetWithOwnDescriptor时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 若 ownDesc 是 undefined, 那么 令 parent 为 ? O.[[GetPrototypeOf]](). 若 parent 不是 null, 那么 返回 ? parent.[[Set]](P, V, Receiver). 否则, 设置 ownDesc 为 the PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true， [[Enumerable]]: true, [[Configurable]]: true }. 若 IsDataDescriptor(ownDesc) 是 true, 那么 若 ownDesc.[[Writable]] 是 false, 返回 false。 若 Type(Receiver) 不是 Object, 返回 false. 令 existingDescriptor 为 ? Receiver.[[GetOwnProperty]](P). 若 existingDescriptor 不是 undefined, 那么 若 IsAccessorDescriptor(existingDescriptor) 是 true, 返回 false. 若 existingDescriptor.[[Writable]] 是 false, 返回 false. 令 valueDesc 为 the PropertyDescriptor { [[Value]]: V }. 返回 ? Receiver.[[DefineOwnProperty]](P, valueDesc). 否则 Receiver 当前没有属性 P 返回 ? CreateDataProperty(Receiver, P, V). 断言: IsAccessorDescriptor(ownDesc) 是 true. 令 setter 为 ownDesc.[[Set]]. 若 setter 是 undefined, 返回 false. 执行 ? Call(setter, Receiver, « V »). 返回 true 9.1.10 [[Delete]] ( P ) 使用属性键P调用O的[[Delete]]内部方法时，将执行以下步骤： 返回 ? OrdinaryDelete(O, P). 9.1.10.1 OrdinaryDelete ( O, P ) 当使用对象O和属性键P调用抽象操作OrdinaryDelete时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 desc 为 ? O.[[GetOwnProperty]](P). 若 desc 是 undefined, 返回 true. 若 desc.[[Configurable]] 是 true, 那么 从 O 中移除名为 P 的私有属性. 返回 true. 返回 false. 9.1.11 [[OwnPropertyKeys]] ( ) 调用O的[[OwnPropertyKeys]]内部方法时，将执行以下步骤： 返回 ! OrdinaryOwnPropertyKeys(O). 9.1.11.1 OrdinaryOwnPropertyKeys ( O ) 使用Object OF调用抽象操作“普通OwnProperty Keys”时，将执行以下步骤： 令 keys 为一个新的空列表. 对于作为数组索引的 O 的每个私有的属性键P，按数字索引升序排列, 执行 将 P 添加为 keys 的最后一个元素。 对于每个字符串 O 的私有属性键 P（不是数组索引），按属性创建的时间顺序升序排列，执行 将 P 添加为 keys 的最后一个元素。 对于每个 Symbol 类型的 O 的私有属性键P，按属性创建的升序排列, 执行 将 P 添加为 keys 的最后一个元素。 返回 keys. 9.1.12 ObjectCreate ( proto [ , internalSlotsList ] ) 带 proto 参数（对象或null）的抽象操作 ObjectCreate 用于指定新的普通对象的运行时创建。可选参数internalSlotsList是额外内部插槽名称的列表，必须定义为对象一部分的。如果未提供列表，则使用新的空列表。此抽象操作执行以下步骤： 若 internalSlotsList 不存在, 设置 internalSlotsList 为一个新的空列表. 令 obj 为一个新创建的对象，其中 internalSlotsList 中的每个名称都有一个内部插槽。 设置 obj 的基本内部方法为 9.1中指定的默认普通对象定义。 设置 obj.[[Prototype]] 为 proto. 设置 obj.[[Extensible]] 为 true. 返回 obj. 9.1.13 OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto [ , internalSlotsList ] ) 抽象操作OrdinaryCreateFromConstructor创建一个普通对象，该对象的[[Prototype]]值从构造器的prototype属性中获取（如果存在）。否则，将由internalDefaultProto命名的内部函数用于[[Prototype]]。可选的internalSlotsList是额外内部插槽名称的列表，必须定义为对象一部分的。如果未提供列表，则使用新的空列表。此抽象操作执行以下步骤： 断言: intrinsicDefaultProto 是一个String值，它是此规范的内部对象名称。相应的对象必须是打算用作对象的[[Prototype]]值的内部函数。 令 proto 为 ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto). 返回 ObjectCreate(proto, internalSlotsList). 9.1.14 GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto ) 抽象操作GetPrototypeFromConstructor确定用于创建与特定构造函数相对应的对象的[[Prototype]]值。该值从构造函数的prototype属性中获取（如果存在）。否则，将由internalDefaultProto命名的内部函数用于[[Prototype]]。此抽象操作执行以下步骤： 断言: intrinsicDefaultProto 是一个String值，它是此规范的内部对象名称。 断言: IsCallable(constructor) 是 true. 令 proto 为 ? Get(constructor, \"prototype\"). 若 Type(proto) 不是 Object, 那么 令 realm 为 ? GetFunctionRealm(constructor). 设置 proto 为 realm's intrinsic object named intrinsicDefaultProto. 设置 proto 为 realm 的内部对象名 intrinsicDefaultProto. 返回 proto. 注：如果构造函数未提供[[Prototype]]值，则使用的默认值是从构造函数的作用域而不是从运行的执行上下文中获得的。 9.2 ECMAScript函数对象 ECMAScript函数对象封装了在词法环境中封闭的参数化ECMAScript代码，并支持对该代码的动态执行。ECMAScript函数对象是一个普通对象，并且具有与其他普通对象相同的内部插槽和相同的内部方法。ECMAScript函数对象的代码可以是严格模式代码（10.2.1）或非严格代码。代码为严格模式代码的ECMAScript函数对象称为严格函数。代码不是严格模式代码的代码称为非严格函数。 ECMAScript函数对象具有表27中列出的其他内部插槽。 内部插槽 类型 描述 [[Environment]] 词法环境 函数封闭的词法环境。在执行函数代码时用作外部环境。 [[FormalParameters]] 解析节点 源文本的根解析节点，用于定义函数的形式参数列表。 [[FunctionKind]] 字符串 \"normal\", \"classConstructor\", \"generator\", \"async\" 或 \"async generator\" [[ECMAScriptCode]] 解析节点 定义函数体的源文本的根解析节点。 [[ConstructorKind]] 字符串 \"base\" 或 \"derived\" [[Realm]] 作用域记录项 创建函数的作用域，并提供在执行函数时访问的任何内部对象。 [[ScriptOrModule]] 脚本记录项或模块记录项 创建函数的脚本或模块。 [[ThisMode]] (lexical, strict, global) 定义如何在函数的形式参数和代码体内解释引用this。 lexical意味着this是词法闭包函数的this值。 strict意味着this值完全按照函数调用的方式使用。 global意味着undefined的this值被解释为对全局对象的引用。 [[Strict]] Boolean 如果这是严格的模式函数，则为真，如果不是严格的模式函数，则为false。 [[HomeObject]] Object 如果函数使用super，这是[[GetPrototypeOf]]提供super属性查找开始的对象。 [[SourceText]] String 源文本定义了函数 所有ECMAScript函数对象都具有此处定义的[[Call]]内部方法。ECMAScript函数也是构造函数，另外还具有[[Construct]]内部方法。 9.2.1 [[Call]] ( thisArgument, argumentsList ) 使用参数thisArgument和argumentsList（ECMAScript语言值列表）来调用ECMAScript函数对象F的[[Call]]内部方法。采取以下步骤： 断言: F 是ECMAScript函数对象. 若 F.[[FunctionKind]] 是 \"classConstructor\", 抛出 TypeError 异常. 令 callerContext 为运行时执行上下文. 令 calleeContext 为 PrepareForOrdinaryCall(F, undefined). 断言: calleeContext 是当前的运行时执行上下文. 执行 OrdinaryCallBindThis(F, calleeContext, thisArgument). 令 result 为 OrdinaryCallEvaluateBody(F, argumentsList). 从执行上下文堆栈中删除calleeContext，并将callerContext还原为正在运行的执行上下文。 若 result.[[Type]] 是 return, 返回 NormalCompletion(result.[[Value]]). ReturnIfAbrupt(result). 返回 NormalCompletion(undefined). 注：当在步骤8中从执行上下文堆栈中删除calleeContext时，如果将其暂停并保留以供以后由可访问的生成器对象恢复，则不得销毁它。 9.2.1.1 PrepareForOrdinaryCall ( F, newTarget ) 使用函数对象F和ECMAScript语言值newTarget调用抽象操作PrepareForOrdinaryCall时，将执行以下步骤： 断言: Type(newTarget) 是 Undefined 或 Object. 令 callerContext 为运行时执行上下文. 令 calleeContext 为新的ECMAScript代码执行上下文. 设置 calleeContext 的函数为 F. 令 calleeRealm 为 F.[[Realm]]. 设置 calleeContext 的作用域为 calleeRealm. 设置 calleeContext 的 ScriptOrModule 为 F.[[ScriptOrModule]]. 令 localEnv 为 NewFunctionEnvironment(F, newTarget). 设置 calleeContext 的词法环境为 localEnv. 设置 calleeContext 变量环境为 localEnv. 若 callerContext 不是已经挂起, 挂起 callerContext. 将calleeContext推入执行上下文堆栈；calleeContext现在是运行中的执行上下文。 注意: 此后产生的任何异常对象都与calleeRealm相关联 返回 calleeContext. 9.2.1.2 OrdinaryCallBindThis ( F, calleeContext, thisArgument ) 当使用函数对象F，执行上下文calleeContext和ECMAScript值thisArgument调用抽象操作OrdinaryCallBindThis时，将执行以下步骤： 令 thisMode 为 F.[[ThisMode]]. 若 thisMode 是 lexical, 返回 NormalCompletion(undefined). 令 calleeRealm 为 F.[[Realm]]. 令 localEnv 为 calleeContext的词法环境. 若 thisMode 是 strict, 令 thisValue 为 thisArgument. 否则, 若 thisArgument 是 undefined 或 null, 那么 令 globalEnv 为 calleeRealm.[[GlobalEnv]]. 令 globalEnvRec 为 globalEnv的环境记录项. 断言: globalEnvRec 是全局环境记录项. 令 thisValue 为 globalEnvRec.[[GlobalThisValue]]. 否则, 令 thisValue 为 ! ToObject(thisArgument). 注意: ToObject 使用 calleeRealm生成包装对象. 令 envRec 为 localEnv 的环境记录项. 断言: envRec 是函数环境记录项. 断言: 下一步永远不会返回突然完成，因为 envRec.[[ThisBindingStatus]] 不是 \"initialized\". 返回 envRec.BindThisValue(thisValue). 9.2.1.3 OrdinaryCallEvaluateBody ( F, argumentsList ) 当使用函数对象 F 和列表 argumentsList 调用抽象操作 OrdinaryCallEvaluateBody 时，将执行以下步骤： 返回已解析代码的 EvaluateBody 的结果，即 F.[[ECMAScriptCode]] 传递 F 和 argumentsList 作为参数。 9.2.2 [[Construct]] ( argumentsList, newTarget ) 使用参数argumentsList和newTarget调用ECMAScript函数对象F的[[Construct]]内部方法。argumentsList是一个可能为空的ECMAScript语言值列表。采取以下步骤： 断言: F 是ECMAScript函数对象. 断言: Type(newTarget) 是 Object. 令 callerContext 为运行时执行上下文. 令 kind 为 F.[[ConstructorKind]]. 若 kind 是 \"base\", 那么 令 thisArgument 为 ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\"). 令 calleeContext 为 PrepareForOrdinaryCall(F, newTarget). 断言: calleeContext 是当前的运行时执行上下文. 若 kind 是 \"base\", 执行 OrdinaryCallBindThis(F, calleeContext, thisArgument). 令 constructorEnv 为 calleeContext 的词法环境. 令 envRec 为 constructorEnv 的环境记录项. 令 result 为 OrdinaryCallEvaluateBody(F, argumentsList). 从执行上下文堆栈中删除calleeContext，并将callerContext还原为正在运行的执行上下文 若 result.[[Type]] 是 return, 那么 若 Type(result.[[Value]]) 是 Object, 返回 NormalCompletion(result.[[Value]]). 若 kind 是 \"base\", 返回 NormalCompletion(thisArgument). 若 result.[[Value]] 不是 undefined, 抛出 TypeError 异常. 否则, ReturnIfAbrupt(result). 返回 ? envRec.GetThisBinding(). 9.2.3 FunctionAllocate ( functionPrototype, strict, functionKind ) 抽象操作FunctionAllocate需要三个参数functionPrototype，strict和functionKind。FunctionAllocate执行以下步骤： 断言: Type(functionPrototype) 是 Object. 断言: functionKind 是 \"normal\", \"non-constructor\", \"generator\", \"async\", 或 \"async generator\". 若 functionKind 是 \"normal\", 令 needsConstruct 为 true. 否则, 令 needsConstruct 为 false. 若 functionKind 是 \"non-constructor\", 设置 functionKind 为 \"normal\". 令 F 为一个新创建的 ECMAScript 函数对象，其内部插槽在表27中列出。所有这些内部插槽均被初始化为undefined 设置 F 的基本内部方法为9.1中指定的默认普通对象定义 设置 F.[[Call]] 为9.2.1中指定的定义. 若 needsConstruct 是 true, 那么 设置 F.[[Construct]] 为9.2.2指定的定义. 设置 F.[[ConstructorKind]] 为 \"base\". 设置 F.[[Strict]] 为 strict. 设置 F.[[FunctionKind]] 为 functionKind. 设置 F.[[Prototype]] 为 functionPrototype. 设置 F.[[Extensible]] 为 true. 设置 F.[[Realm]] 为当前作用域记录项. 返回 F. 9.2.4 FunctionInitialize ( F, kind, ParameterList, Body, Scope ) 抽象操作FunctionInitialize要求使用以下参数：函数对象F，类型为（Normal，Method，Arrow）之一，由ParameterList指定的参数列表Parse Node，由Body指定的主体Parse Node，由Scope指定的词法环境。FunctionInitialize执行以下步骤： 令 len 为 ParameterList 的 ExpectedArgumentCount. 执行 ! SetFunctionLength(F, len). 令 Strict 为 F.[[Strict]]. 设置 F.[[Environment]] 为 Scope 设置 F.[[FormalParameters]] 为 ParameterList. 设置 F.[[ECMAScriptCode]] 为 Body. 设置 F.[[ScriptOrModule]] 为 GetActiveScriptOrModule(). 若 kind 是 Arrow, 设置 F.[[ThisMode]] 为 lexical. 否则 若 Strict 是 true, 设置 F.[[ThisMode]] 为 strict. 否则, 设置 F.[[ThisMode]] 为 global. 返回 F. 9.2.5 FunctionCreate ( kind, ParameterList, Body, Scope, Strict [ , prototype ] ) 抽象操作FunctionCreate需要以下参数：kind（以下类型之一）：（ Normal, Method, Arrow ），由ParameterList指定的参数列表解析节点，由Body指定的主体解析节点，由Scope指定的词法环境，布尔标志Strict，以及可选的对象原型。FunctionCreate执行以下步骤： 若 prototype 不存在, 那么 设置 prototype 为内部对象 %FunctionPrototype%. 若 kind 不是 Normal, 令 allocKind 为 \"non-constructor\". 否则, 令 allocKind 为 \"normal\". 令 F 为 FunctionAllocate(prototype, Strict, allocKind). 返回 FunctionInitialize(F, kind, ParameterList, Body, Scope). 9.2.6 GeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict ) 抽象操作GeneratorFunctionCreate要求使用以下参数：kind是（ Normal, Method ）之一，由ParameterList指定的参数列表Parse Node，由Body指定的主体Parse Node，由Scope指定的词法环境和布尔标志Strict。GeneratorFunctionCreate执行以下步骤： 令 functionPrototype 为内部对象 %Generator%. 令 F 为 FunctionAllocate(functionPrototype, Strict, \"generator\"). 返回 FunctionInitialize(F, kind, ParameterList, Body, Scope). 9.2.7 AsyncGeneratorFunctionCreate ( kind, ParameterList, Body, Scope, Strict ) 抽象操作AsyncGeneratorFunctionCreate要求使用以下参数：kind（以下之一）：（ Normal, Method ），由ParameterList指定的参数列表Parse Node，由Body指定的主体Parse Node，由Scope指定的词法环境以及布尔标志Strict。AsyncGeneratorFunctionCreate执行以下步骤： 令 functionPrototype 为内部对象 %AsyncGenerator%. 令 F 为 ! FunctionAllocate(functionPrototype, Strict, \"generator\"). 返回 ! FunctionInitialize(F, kind, ParameterList, Body, Scope). 9.2.8 AsyncFunctionCreate ( kind, parameters, body, Scope, Strict ) 抽象操作AsyncFunctionCreate要求使用以下参数：kind（以下类型之一）：（ Normal, Method, Arrow ），参数列表所指定的参数解析节点，主体所指定的主体解析节点，Scope所指定的词法环境以及布尔值标志Strict。AsyncFunctionCreate执行以下步骤： 令 functionPrototype 为内部对象 %AsyncFunctionPrototype%. 令 F 为 ! FunctionAllocate(functionPrototype, Strict, \"async\"). 返回 ! FunctionInitialize(F, kind, parameters, body, Scope). 9.2.9 AddRestrictedFunctionProperties ( F, realm ) 以函数对象 F 和作用域记录项 Realm 作为其参数调用抽象操作AddRestrictedFunctionProperties。它执行以下步骤： 断言: realm.[[Intrinsics]].[[%ThrowTypeError%]] 存在并且已经初始化. 令 thrower 为 realm.[[Intrinsics]].[[%ThrowTypeError%]]. 执行 ! DefinePropertyOrThrow(F, \"caller\", PropertyDescriptor { [[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true }). 返回 ! DefinePropertyOrThrow(F, \"arguments\", PropertyDescriptor { [[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true }). 9.2.9.1 %ThrowTypeError% ( ) ％ThrowTypeError％内部函数是一个匿名内置函数对象，为每个作用域定义一次。调用％ThrowTypeError％时，它将执行以下步骤： 抛出 TypeError 异常. ％ThrowTypeError％函数的[[Extensible]]内部插槽的值为false。 ％ThrowTypeError％函数的“ length”属性具有属性{[[[Writable]]：false，[[Enumerable]]：false，[[Configurable]]：false}。 9.2.10 MakeConstructor ( F [ , writablePrototype [ , prototype ] ] ) 抽象操作MakeConstructor需要一个Function参数 F 、一个可选的布尔值 writablePrototype 和一个对象原型。如果提供了原型，则假定已包含（如果需要）值为“ F”的“constructor”属性。此操作通过执行以下步骤将F转换为构造函数： 断言: F 是ECMAScript函数对象. 断言: IsConstructor(F) 是 true. 断言: F 是没有prototype私有属性的可扩展对象 若 writablePrototype 不存在, 设置 writablePrototype 为 true. 若 prototype 不存在, 那么 设置 prototype 为 ObjectCreate(%ObjectPrototype%). 执行 ! DefinePropertyOrThrow(prototype, \"constructor\", PropertyDescriptor { [[Value]]: F,[[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }). 执行 ! DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false }). 返回 NormalCompletion(undefined). 9.2.11 MakeClassConstructor ( F ) 具有参数F的抽象操作MakeClassConstructor执行以下步骤： 断言: F 是ECMAScript函数对象. 断言: F.[[FunctionKind]] 是 \"normal\". 设置 F.[[FunctionKind]] 为 \"classConstructor\". 返回 NormalCompletion(undefined). 9.2.12 MakeMethod ( F, homeObject ) 具有参数 F 和 homeObject 的抽象操作 MakeMethod 通过执行以下步骤将F配置为方法： 断言: F 是ECMAScript函数对象. 断言: Type(homeObject) 是 Object. 设置 F.[[HomeObject]] 为 homeObject. 返回 NormalCompletion(undefined) 9.2.13 SetFunctionName ( F, name [ , prefix ] ) 抽象操作SetFunctionName需要一个Function参数F，一个String或Symbol参数名称以及一个可选的String参数前缀。该操作通过执行以下步骤将名称属性添加到F： 断言: F 是没有name私有属性的可扩展对象. 断言: Type(name) 是 Symbol 或 String. 断言: 若 prefix 存在, 那么 Type(prefix) 是 String. 若 Type(name) 是 Symbol, 那么 令 description 为 name's [[Description]] value. 若 description 是 undefined, 设置 name 为 the empty String. 否则, 设置 name 为 the string-concatenation of \"[\", description, and \"]\". 若 prefix 存在, 那么 设置 name 为前缀的字符串连接（码元0x0020（空格））和name 返回 ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor { [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }). 9.2.14 SetFunctionLength ( F, length ) 抽象操作SetFunctionLength需要一个Function参数F和一个Number参数长度。此操作通过执行以下步骤为F添加一个“length”属性： 断言: F 是没有\"length\"私有属性的可扩展对象. 断言: Type(length) 是 Number. 断言: length ≥ 0 并且 ! ToInteger(length) 等于 length. 返回 ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor { [[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }). 9.2.15 FunctionDeclarationInstantion ( func, argumentsList ) 注：当建立用于执行ECMAScript函数的执行上下文时，将创建一个新函数环境记录项，并在该环境记录项中实例化每个形式参数的绑定。函数体中的每个声明也都被实例化。如果函数的形参不包含任何默认值初始化程序，则主体声明将在与参数相同的环境记录中实例化。如果存在默认值参数初始化程序，则会为主体声明创建第二个环境记录。正式的参数和函数是初始化为FunctionDeclarationInstantiation的一部分。在函数体执行期间初始化所有其他绑定。 使用参数func和argumentsList如下执行FunctionDeclarationInstantiation。func是为其建立执行上下文的函数对象。 令 calleeContext 为运行时执行上下文. 令 env 为 calleeContext 的词法环境. 令 envRec 为 env 的环境记录项. 令 code 为 func.[[ECMAScriptCode]]. 令 strict 为 func.[[Strict]]. 令 formals 为 func.[[FormalParameters]]. 令 parameterNames 为 formals 的绑定名称. 若 parameterNames 有任何重复条目, 令 hasDuplicates 为 true. 否则, 令 hasDuplicates 为 false. 令 simpleParameterList 为 formals 的 IsSimpleParameterList . 令 hasParameterExpressions 为 formals 的 ContainsExpression. 令 varNames 为 code 的 VarDeclaredNames. 令 varDeclarations 为 code 的 VarScopedDeclarations. 令 lexicalNames 为 code 的 LexicallyDeclaredNames . 令 functionNames 为一个新的空列表. 令 functionsToInitialize 为一个新的空列表. 对于在 varDeclarations 中的每一个 d, 倒序排列, 执行 若 d 不是 VariableDeclaration、 ForBinding 或 BindingIdentifier, 那么 断言: d 是 FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, 或 AsyncGeneratorDeclaration. 令 fn 为 d 的绑定名称的唯一元素. 若 fn 不是 functionNames 元素之一, 那么 插入fn 作为functionNames的第一个元素。 注意: 如果有多个相同名称的函数声明，则使用最后一个声明。 插入d 作为functionsToInitialize的第一个元素。 令 argumentsObjectNeeded 为 true. 若 func.[[ThisMode]] 是 lexical, 那么 注意: 箭头函数从不具有参数对象。 设置 argumentsObjectNeeded 为 false. 否则 若 \"arguments\" 是 parameterNames 中的一个元素, 那么 设置 argumentsObjectNeeded 为 false. 否则 若 hasParameterExpressions 是 false, 那么 若 \"arguments\" 是 functionNames 的一个元素，或者若 \"arguments\" 是 lexicalNames 中的一个元素, 那么 设置 argumentsObjectNeeded 为 false. 对于在 parameterNames 中的每一个字符串 paramName , 执行 令 alreadyDeclared 为 envRec.HasBinding(paramName). 注意：早期错误确保重复的参数名称只能在没有参数默认值或其余参数的非严格函数中出现。 若 alreadyDeclared 是 false, 那么 执行 ! envRec.CreateMutableBinding(paramName, false). 若 hasDuplicates 是 true, 那么 执行 ! envRec.InitializeBinding(paramName, undefined). 若 argumentsObjectNeeded 是 true, 那么 若 strict 是 true 或 若 simpleParameterList 是 false, 那么 令 ao 为 CreateUnmappedArgumentsObject(argumentsList). 否则, 注意: 映射的参数对象仅提供给没有剩余参数、任何参数默认值初始化程序或任何非结构化参数的非严格函数。 令 ao 为 CreateMappedArgumentsObject(func, formals, argumentsList, envRec). 若 strict 是 true, 那么 执行 ! envRec.CreateImmutableBinding(\"arguments\", false). 否则, 执行 ! envRec.CreateMutableBinding(\"arguments\", false). 调用 envRec.InitializeBinding(\"arguments\", ao). 令 parameterBindings 为一个新的附加“ arguments ”的parameterNames列表。 否则, 令 parameterBindings 为 parameterNames. 令 iteratorRecord 为 CreateListIteratorRecord(argumentsList). 若 hasDuplicates 是 true, 那么 为有 iteratorRecord 和 undefined 参数的 formals，执行 ? IteratorBindingInitialization。 否则, 为有 iteratorRecord 和 env 参数的 formals， 执行 ? IteratorBindingInitialization。 若 hasParameterExpressions 是 false, 那么 注意: 参数和顶级变量仅需要一个词法环境。 令 instantiatedVarNames 为 parameterBindings 列表的一个拷贝. 对于 varNames 中的每一个 n, 执行 若 n 不是 instantiatedVarNames 中的一个元素, 那么 添加 n 到 instantiatedVarNames. 执行 ! envRec.CreateMutableBinding(n, false). 调用 envRec.InitializeBinding(n, undefined). 令 varEnv 为 env. 令 varEnvRec 为 envRec. 否则, 注意: 需要单独的环境记录，以确保由形参列表中的表达式创建的闭包在函数体中不具有声明的可见性。 令 varEnv 为 NewDeclarativeEnvironment(env). 令 varEnvRec 为 varEnv's 环境记录项. 设置 calleeContext 的可变环境为 varEnv. 令 instantiatedVarNames 为一个新的空列表. 对于 varNames 中的每一个 n, 执行 若 n 不是 instantiatedVarNames 的一个元素, 那么 Append n 为 instantiatedVarNames. 执行 ! varEnvRec.CreateMutableBinding(n, false). 若 n 不是 parameterBindings 的一个元素，或者若 n 是 functionNames 的一个元素, 令 initialValue为 undefined. 否则, 令 initialValue 为 ! envRec.GetBindingValue(n, false). 调用 varEnvRec.InitializeBinding(n, initialValue). 注意: 名称与形参相同的var，最初时与对应的初始化参数具有相同的值。 注意: 附录 2.3.3.1 此时会添加其他步骤。 若 strict 是 false, 那么 令 lexEnv 为 NewDeclarativeEnvironment(varEnv). 注意: 非严格函数将单独的词法环境记录用于顶级词法声明，以便直接eval可以确定由eval代码引入的任何var范围声明是否与预先存在的顶级词法范围声明冲突。严格的函数不需要这样做，因为严格的直接执行总是将所有声明放入新的环境记录中。 否则, 令 lexEnv 为 varEnv. 令 lexEnvRec 为 lexEnv's 环境记录项. 设置 the LexicalEnvironment of calleeContext 为 lexEnv. 令 lexDeclarations 为 code 的 LexicallyScopedDeclarations 对于每一个 lexDeclarations 中的元素 d, 执行 注意: 词法声明的名称不能与函数/生成器声明，形参或var名称相同。词汇声明的名称仅在此处实例化，而不初始化。 对于 d 的绑定名称的每一个元素 dn, 执行 若 d 的 IsConstantDeclaration 是 true, 那么 执行 ! lexEnvRec.CreateImmutableBinding(dn, true). 否则, 执行 ! lexEnvRec.CreateMutableBinding(dn, false). 对于 functionsToInitialize 的每一个解释节点 f，执行 令 fn 为 f 的绑定名称的唯一元素 令 fo 为对用参数 LexEnv 执行 f 的 InstantiateFunctionObject 的结果 执行 ! varEnvRec.SetMutableBinding(fn, fo, false). 返回 NormalCompletion(empty). 注2：2.3.3提供了上述算法的扩展，此扩展是向后兼容ECMAScript 2015之前的ECMAScript的Web浏览器实现所必需的。 注3：参数初始化程序可能包含直接的eval表达式。此类评估的任何顶级声明仅对执行代码（10.2）可见。14.1.19中描述了为此类声明创建环境的过程。 9.3 内置函数对象 本规范中定义的内置函数对象可以实现为ECMAScript函数对象（9.2），其行为使用ECMAScript代码提供，也可以实现为提供的函数异类对象，其行为以其他方式提供。无论哪种情况，调用此类函数的效果都必须符合其规范。一个实现也可以提供本规范中未定义的其他内置函数对象。 如果将内置函数对象实现为异类对象，则它必须具有9.1中指定的普通对象行为。所有此类函数异类对象还具有[[Prototype]]，[[Extensible]]，[[Realm]]和[[ScriptOrModule]]内部插槽 除非另有说明，否则每个内置函数对象都将％FunctionPrototype％对象作为其[[Prototype]]内部插槽的初始值。 通过算法步骤或其他方式为每个内置函数指定的行为是该函数的[[Call]]和[[Construct]]调用的函数主体行为的规范。但是，[[Construct]]调用不是所有内置函数都支持。对于每个内置函数，当使用[[Call]]调用时，[[Call]] thisArgument提供this值，[[Call]] argumentsList提供命名参数，NewTarget值为undefined。当使用[[Construct]]调用时，此值未初始化，[[Construct]] argumentsList提供了命名参数，而[[Construct]] newTarget参数提供NewTarget值。如果内置函数是作为ECMAScript函数对象实现，则此指定的行为必须由ECMAScript实现该函数的主体代码。作为ECMAScript函数对象的内置函数必须是严格函数。如果内置构造函数具有任何[[Call]]行为，除了抛出TypeError异常，必须以不会导致函数的[[FunctionKind]]内部插槽的值为“ classConstructor”的方式完成函数的ECMAScript实现。 除非在特定函数的说明中另有指定，否则未被标识为构造函数的内置函数对象不会实现[[Construct]]内部方法。当将内置构造函数作为新表达式的一部分调用时，被调用的[[Construct]]内部方法的argumentsList参数将提供内置构造函数的命名参数的值。 非构造函数的内置函数没有原型属性，除非在特定函数的说明中另有指定。 如果内置函数对象未实现为ECMAScript函数，则必须提供符合以下定义的[[Call]]和[[Construct]]内部方法： 9.3.1 [[Call]] ( thisArgument, argumentsList ) 使用参数thisArgument和argumentsList（ECMAScript语言值列表）来调用内置函数对象F的[[Call]]内部方法。采取以下步骤： 令 callerContext 为运行时执行上下文. 若 callerContext 不是已经挂起, 挂起 callerContext. 令 calleeContext 为新的ECMAScript代码执行上下文. 设置 the Function of calleeContext 为 F. 令 calleeRealm 为 F.[[Realm]]. 设置 calleeContext 的作用域为 calleeRealm. 设置 calleeContext 的 ScriptOrModule 为 F.[[ScriptOrModule]]. 对 calleeContext 执行任何必要的实现定义的初始化。 将 calleeContext 推入执行上下文堆栈；calleeContext现在是运行中的执行上下文。 令 result 为完成记录项，它是按照符合 F 规范的实现定义的方式执行 F 的结果。thisArgument 是 this 值，argumentsList提供命名的参数，而NewTarget值是undefined。 从执行上下文堆栈中删除calleeContext，并将callerContext还原为正在运行的执行上下文。 返回 result. 注：从执行上下文堆栈中删除 calleeContext 时，如果可访问的生成器对象已将其暂停并保留以供以后恢复，则不能销毁它。 9.3.2 [[Construct]] ( argumentsList, newTarget ) 使用参数argumentsList和newTarget调用内置函数对象F的[[Construct]]内部方法。执行的步骤与[[Call]]（请参阅9.3.1）相同，但步骤10替换为： 令 result 为完成记录项，它是按照符合 F 规范的实现定义方式执行 F 的结果。this 值未初始化，argumentsList 提供命名的参数，newTarget 提供 NewTarget 的值。 9.3.3 CreateBuiltinFunction ( steps, internalSlotsList [ , realm [ , prototype ] ] ) 抽象操作CreateBuiltinFunction接受参数步骤，internalSlotsList，作用域和原型。参数internalSlotsList是必须定义为对象一部分的其他内部插槽名称的列表。CreateBuiltinFunction返回通过以下步骤创建的内置函数对象： 断言: step 是本规范中提供的一组算法步骤或函数行为的其他定义。 若 realm 不存在, 设置 realm 为当前作用域记录项. 断言: realm 是作用域记录项. 若 prototype 不存在, 设置 prototype 为 realm.[[Intrinsics]].[[%FunctionPrototype%]]. 令 func 是一个新的内置函数对象，当调用该函数对象时，它执行 step 描述的操作。新函数对象具有内部插槽，其名称是 internalSlotsList 的元素。这些内部插槽中每个插槽的初始值均为undefined。 设置 func.[[Realm]] 为 realm. 设置 func.[[Prototype]] 为 prototype. 设置 func.[[Extensible]] 为 true. 设置 func.[[ScriptOrModule]] 为 null. 返回 func. 通过调用CreateBuiltinFunction抽象操作来创建本规范中定义的每个内置函数。 9.4 内置异类对象内部方法和插槽 该规范定义了几种内置的异类对象。这些对象的行为通常与普通对象相似，除了一些特定的情况。下列异类对象使用普通对象内部方法，除非在下面另行明确指定： 9.4.1 绑定函数异类对象 绑定函数是包装另一个函数对象的异类对象。绑定函数是可调用的（它具有[[Call]]内部方法，并且可能具有[[Construct]]内部方法）。调用绑定函数通常会导致调用其包装函数。 绑定函数对象没有表27中定义的ECMAScript功能对象的内部插槽。相反，它们具有表28中定义的内部插槽。 内部插槽 类型 描述 [[BoundTargetFunction]] 可调用对象 包装的函数对象。 [[BoundThis]] 任何 当调用包装函数时，始终作为this值传递的值。 [[BoundArguments]] 任何列表 一个值的列表，其元素被用作对包装函数的任何调用的第一个参数。 绑定函数对象提供了9.1中指定的所有基本内部方法。但是，对于函数对象的基本内部方法，它们使用以下定义。 9.4.1.1 [[Call]] ( thisArgument, argumentsList ) 当使用参数thisArgument和argumentsList（ECMAScript语言值列表）调用使用绑定函数创建的绑定函数异类对象F的[[Call]]内部方法时，将执行以下步骤： 令 target 为 F.[[BoundTargetFunction]]. 令 boundThis 为 F.[[BoundThis]]. 令 boundArgs 为 F.[[BoundArguments]]. 令 args 为一个新列表，其包含与列表boundArgs相同的值（顺序相同），然后与列表argumentsList的顺序相同。 返回 ? Call(target, boundThis, args). 9.4.1.2 [[Construct]] ( argumentsList, newTarget ) 当使用参数列表arguestList和newTarget调用使用绑定函数创建的绑定函数外部对象的[[Construct]]内部方法时，将执行以下步骤： 令 target 为 F.[[BoundTargetFunction]]. 断言: IsConstructor(target) 是 true. 令 boundArgs 为 F.[[BoundArguments]]. 令 args 为一个新列表，其包含与列表boundArgs相同的值（顺序相同），然后与列表argumentsList的顺序相同。 若 SameValue(F, newTarget) 是 true, 设置 newTarget 为 target. 返回 ? Construct(target, args, newTarget). 9.4.1.3 BoundFunctionCreate ( targetFunction, boundThis, boundArgs ) 具有targetFunction，boundThis和boundArgs参数的抽象操作BoundFunctionCreate用于指定创建新的绑定函数异类对象。它执行以下步骤： 断言: Type(targetFunction) 是 Object. 令 proto 为 ? targetFunction.[[GetPrototypeOf]](). 令 obj 为新创建的对象 设置 obj 的基本内部方法为9.1中指定的默认普通对象定义。 设置 obj.[[Call]] 为 9.4.1.1 所描述的. 若 IsConstructor(targetFunction) 是 true, 那么 设置 obj.[[Construct]] 为 9.4.1.2 所述的. 设置 obj.[[Prototype]] 为 proto. 设置 obj.[[Extensible]] 为 true. 设置 obj.[[BoundTargetFunction]] 为 targetFunction. 设置 obj.[[BoundThis]] 为 boundThis. 设置 obj.[[BoundArguments]] 为 boundArgs. 返回 obj. 9.4.2 数组异类对象 Array对象是一个特殊对象，它对数组索引属性键（请参见6.1.7）进行特殊处理。属性名称是数组索引的属性也称为元素。每个Array对象都有一个不可配置的“ length”属性，该属性的值始终是一个小于2^32的非负整数。“ length”属性的值在数值上大于每个其名称为数组索引的属性的名称；每当创建或更改Array对象的自身属性时，都会根据需要调整其他属性以保持该不变性。具体来说，每当添加一个自己的名称为数组索引的属性时，如果需要，将“ length”属性的值更改为比该数组索引的数值大一；并且，只要更改“ length”属性的值，就会删除名称为数组索引且其值不小于新长度的每个自己的属性。此约束仅适用于Array对象自身的属性，不受可能从其原型继承的“length”或数组索引属性的影响。 注：仅当ToString（ToUint32（P））等于P并且ToUint32（P）不等于2^32-1时，字符串属性名称P是数组索引。 数组异类对象为[[DefineOwnProperty]]内部方法提供了替代定义。除了该内部方法外，Array外部对象提供了9.1中指定的所有其他基本内部方法。 9.4.2.1 [[DefineOwnProperty]] ( P, Desc ) 当使用属性键P和属性描述符Desc调用Array异类对象A的[[DefineOwnProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 若 P 是 \"length\", 那么 a. 返回 ? ArraySetLength(A, Desc). 否则若 P 是一个数组索引, 那么 令 oldLenDesc 为 OrdinaryGetOwnProperty(A, \"length\"). 断言: 因为数组对象是用无法删除或重新配置的length数据属性创建的，所以oldLenDesc将永远不会是未undefined的或访问者描述符。 令 oldLen 为 oldLenDesc.[[Value]]. 令 index 为 ! ToUint32(P). 若 index ≥ oldLen 同时 oldLenDesc.[[Writable]] 是 false, 返回 false. 令 succeeded 为 ! OrdinaryDefineOwnProperty(A, P, Desc). 若 succeeded 是 false, 返回 false. 若 index ≥ oldLen, 那么 设置 oldLenDesc.[[Value]] 为 index + 1. 令 succeeded 为 OrdinaryDefineOwnProperty(A, \"length\", oldLenDesc). 断言: succeeded 是 true. 返回 true. 返回 OrdinaryDefineOwnProperty(A, P, Desc). 9.4.2.2 ArrayCreate ( length [ , proto ] ) 具有参数长度（0或正整数）和可选参数proto的抽象操作ArrayCreate用于指定创建新的Array异类对象。它执行以下步骤： 断言: length 是大于等于零的整数 若 length 是 -0, 设置 length 为 +0. 若 length > 2^32 - 1, 抛出 RangeError 异常. 若 proto 不存在, 设置 proto 为内部对象 %ArrayPrototype%. 令 A 为新创建的数组异类对象. 将除[[DefineOwnProperty]]之外的 A 的基本内部方法设置为9.1中指定的默认普通对象定义。 设置 A.[[DefineOwnProperty]] 为 9.4.2.1 的规范. 设置 A.[[Prototype]] 为 proto. 设置 A.[[Extensible]] 为 true. 执行 ! OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor { [[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 返回 A. 9.4.2.3 ArraySpeciesCreate ( originalArray, length ) 具有参数originalArray和length的抽象操作ArraySpeciesCreate用于使用从originalArray派生的构造函数来指定新Array对象的创建。它执行以下步骤： 断言: length 是大于等于零的整数 若 length 是 -0, 设置 length 为 +0. 令 isArray 为 ? IsArray(originalArray). 若 isArray 是 false, 返回 ? ArrayCreate(length). 令 C 为 ? Get(originalArray, \"constructor\"). 若 IsConstructor(C) 是 true, 那么 令 thisRealm 为当前作用域记录项 令 realmC 为 ? GetFunctionRealm(C). 若 thisRealm 和 realmC 不是同一个作用域记录项, 那么 若 SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) 是 true, 设置 C 为 undefined. 若 Type(C) 是 Object, 那么 设置 C 为 ? Get(C, @@species). 若 C 是 null, 设置 C 为 undefined. 若 C 是 undefined, 返回 ? ArrayCreate(length). 若 IsConstructor(C) 是 false, 抛出 TypeError 异常. 返回 ? Construct(C, « length »). 注：如果使用标准内置Array构造函数为不是正在运行的执行上下文的作用域的作用域创建了originalArray，则将使用正在运行的执行上下文的作用域创建一个新的Array。这可以与以前具有Array.prototype方法的行为的Web浏览器保持兼容性，该行为现在使用ArraySpeciesCreate定义。 9.4.2.4 ArraySetLength ( A, Desc ) 当使用Array异类对象A和属性描述符Desc调用抽象操作ArraySetLength时，将执行以下步骤： 若 Desc.[[Value]] 存在, 那么 返回 OrdinaryDefineOwnProperty(A, \"length\", Desc). 令 newLenDesc 为Desc的一个拷贝。 令 newLen 为 ? ToUint32(Desc.[[Value]]). 令 numberLen 为 ? ToNumber(Desc.[[Value]]). 若 newLen ≠ numberLen, 抛出 RangeError 异常. 设置 newLenDesc.[[Value]] 为 newLen. 令 oldLenDesc 为 OrdinaryGetOwnProperty(A, \"length\"). 断言: 因为将使用无法删除或重新配置的length数据属性创建Array对象，所以oldLenDesc将永远不会是未定义的或访问器描述符。 令 oldLen 为 oldLenDesc.[[Value]]. 若 newLen ≥ oldLen, 那么 a. 返回 OrdinaryDefineOwnProperty(A, \"length\", newLenDesc). 若 oldLenDesc.[[Writable]] 是 false, 返回 false. 若 newLenDesc.[[Writable]] 存在，或者值为true, 令 newWritable 为 true. 否则, 如果无法删除任何元素，则需要推迟将[[Writable]]属性设置为false。 令 newWritable 为 false. 设置 newLenDesc.[[Writable]] 为 true. 令 succeeded 为 ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc). 若 succeeded 是 false, 返回 false. 重复, 直到 newLen oldLen减一 令 deleteSucceeded 为 ! A.[[Delete]](! ToString(oldLen)). 若 deleteSucceeded 是 false, 那么 设置 newLenDesc.[[Value]] 为 oldLen + 1. 若 newWritable 是 false, 设置 newLenDesc.[[Writable]] 为 false. 执行 ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc). 返回 false. 若 newWritable 是 false, 那么 返回 OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor { [[Writable]]: false })。回调一直都为 true 返回 true. 注：在步骤3和4中，如果Desc.[[Value]]是一个对象，则其valueOf方法将被调用两次。这是从本规范的第二版开始具有此效果的历史遗留行为。 9.4.3 字符串异类对象 字符串对象是一个异类对象，它封装了一个字符串值，并公开了与该字符串值的各个代码单元元素相对应的虚拟整数索引数据属性。字符串异类对象始终具有一个名为“length”的数据属性，其值是封装的字符串值中代码单元元素的数量。代码单元数据属性和“ length”属性都是不可写和不可配置的。 字符串异类对象具有与普通对象相同的内部插槽。它们还具有[[StringData]]内部插槽。 字符串异类对象为以下内部方法提供替代定义。以下未定义的所有其他其他String异类对象基本内部方法均在9.1中指定。 9.4.3.1 [[GetOwnProperty]] ( P ) 使用属性键P调用String异类对象S的[[GetOwnProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 desc 为 OrdinaryGetOwnProperty(S, P). 若 desc 不是 undefined, 返回 desc. 返回 ! StringGetOwnProperty(S, P) 9.4.3.2 [[DefineOwnProperty]] ( P, Desc ) 当使用属性键P和属性描述符Desc调用String异类对象S的[[DefineOwnProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 stringDesc 为 ! StringGetOwnProperty(S, P). 若 stringDesc 不是 undefined, 那么 令 extensible 为 S.[[Extensible]]. 返回 ! IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc). 返回 ! OrdinaryDefineOwnProperty(S, P, Desc). 9.4.3.3 [[OwnPropertyKeys]] ( ) 当调用String异类对象O的[[OwnPropertyKeys]]内部方法时，将执行以下步骤： 令 keys 为一个新的空列表. 令 str 为 O.[[StringData]]. 断言: Type(str) 是 String. 令 len 为 str 的长度. 对于每个以0开头的整数，i≤len，按照升序排序, 执行 把 ! ToString(i) 添加到 keys 的最后一个元素. 对于 O 的每个私有属性键P，使得P是数组索引，并且ToInteger（P）≥len，以数字索引升序排列，执行 将P添加到键的最后一个元素。 对于 O 的每个私有属性键P，使得Type（P）为String且P不是数组索引，按属性创建的时间顺序升序，执行 将P添加到键的最后一个元素。 对于 O 的每个私有属性键P， 使得Type（P）为Symbol，以属性创建的时间顺序升序 ，执行 将P添加到键的最后一个元素。 返回 keys. 9.4.3.4 StringCreate ( value, prototype ) 具有参数value和prototype的抽象操作StringCreate用于指定创建新的String异类对象。它执行以下步骤： 断言: Type(value) 是 String. 令 S 为新创建的String异类对象. 设置 S.[[StringData]] 为 value. 设置 S 的基本内部方法为9.1中指定的默认普通对象定义 设置 S.[[GetOwnProperty]] 为 9.4.3.1 的规范 设置 S.[[DefineOwnProperty]] 9.4.3.2 的规范. 设置 S.[[OwnPropertyKeys]] 9.4.3.3 的规范. 设置 S.[[Prototype]] 为 prototype. 设置 S.[[Extensible]] 为 true. 令 length 为 value 的码元元素的数量 执行 ! DefinePropertyOrThrow(S, \"length\", PropertyDescriptor { [[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }). 返回 S. 9.4.3.5 StringGetOwnProperty ( S, P ) 使用参数S和P调用的抽象操作StringGetOwnProperty执行以下步骤： 断言: S 是对象，并且有 [[StringData]] 内置插槽. 断言: IsPropertyKey(P) 是 true. 若 Type(P) 不是 String, 返回 undefined. 令 index 为 ! CanonicalNumericIndexString(P). 若 index 是 undefined, 返回 undefined. 若 IsInteger(index) 是 false, 返回 undefined. 若 index = -0, 返回 undefined. 令 str 为 S.[[StringData]]. 断言: Type(str) 是 String. 令 len 为 str 的长度. 若 index 令 resultStr 为长度为1的String值，包含来自str的一个代码单元，特别是索引index处的代码单元 返回 a PropertyDescriptor { [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}. 9.4.4 参数异类对象 大多数ECMAScript函数使参数对象可用于其代码。根据函数定义的特性，其参数对象可以是普通对象，也可以是参数异类对象。参数异类对象是一个异类对象，其数组索引属性映射到与其关联的ECMAScript函数的调用的形式参数绑定。 参数异类对象具有与普通对象相同的内部插槽。它们还具有一个[[ParameterMap]]内部插槽。普通参数对象还具有一个[[ParameterMap]]内部插槽，其值始终是未定义的。对于普通自变量对象，[[ParameterMap]]内部插槽仅由Object.prototype.toString（19.1.3.6）用来标识它们。 参数异类对象为以下内部方法提供替代定义。以下未定义的所有其他参数异类对象基本内部方法均在9.1中指定 注1：参数异类对象的整数索引数据属性（其数字名称值小于相应函数对象的形参的数量）最初在函数的执行上下文中与相应的参数绑定共享其值。这意味着更改属性会更改参数绑定的相应值，反之亦然。如果删除此类属性然后重新定义，或者将该属性更改为访问器属性，则此对应关系将被破坏。如果arguments对象是普通对象，则其属性的值只是传递给函数的参数的副本，并且属性值和形式参数值之间没有动态链接。 注2：ParameterMap对象及其属性值用作指定参数对象与对应参数绑定。无法从ECMAScript代码直接观察ParameterMap对象和作为其属性值的对象。ECMAScript实现不需要实际创建或使用此类对象来实现指定的语义。 注3：普通参数对象定义了一个名为“ callee”的不可配置的访问器属性，该属性在访问时引发TypeError异常。“ callee”属性对于仅针对某些非严格函数类创建的异类对象参数具有更特定的含义。普通变体中存在此属性的定义，以确保通过遵循ECMAScript实现不以任何其他方式定义它。 注4：ECMAScript自变量对象的实现在历史上一直包含一个名为“ caller”的访问器属性。在ECMAScript 2017之前，此规范包括在普通参数对象上定义引发“调用者”属性的定义。由于实现不再包含此扩展，因此ECMAScript 2017放弃了对抛出\"caller''访问器的要求。 9.4.4.1 [[GetOwnProperty]] ( P ) 使用属性键P调用时，参数异类对象的[[GetOwnProperty]]内部方法执行以下步骤： 令 args 为参数对象 令 desc 为 OrdinaryGetOwnProperty(args, P). 若 desc 是 undefined, 返回 desc. 令 map 为 args.[[ParameterMap]]. 令 isMapped 为 ! HasOwnProperty(map, P). 若 isMapped 是 true, 那么 设置 desc.[[Value]] 为 Get(map, P). 返回 desc. 9.4.4.2 [[DefineOwnProperty]] ( P, Desc ) 使用属性键P和属性描述符Desc调用时，参数异类对象的[[DefineOwnProperty]]内部方法将执行以下步骤： 令 args 为参数对象. 令 map 为 args.[[ParameterMap]]. 令 isMapped 为 HasOwnProperty(map, P). 令 newArgDesc 为 Desc. 若 isMapped 是 true 同时 IsDataDescriptor(Desc) 是 true, 那么 若 Desc.[[Value]] 不存在，同时 Desc.[[Writable]] 存在，值为 false, 那么 设置 newArgDesc 为 Desc 的一个拷贝 设置 newArgDesc.[[Value]] 为 Get(map, P). 令 allowed 为 ? OrdinaryDefineOwnProperty(args, P, newArgDesc). 若 allowed 是 false, 返回 false. 若 isMapped 是 true, 那么 若 IsAccessorDescriptor(Desc) 是 true, 那么 调用 map.[[Delete]](P). 否则, 若 Desc.[[Value]] 存在, 那么 令 setStatus 为 Set(map, P, Desc.[[Value]], false). 断言: setStatus为true，因为由参数对象映射的形式参数始终是可写的。 若 Desc.[[Writable]] 存在，值为 false, 那么 调用 map.[[Delete]](P). 返回 true. 9.4.4.3 [[Get]] ( P, Receiver ) 使用属性键P和ECMAScript语言值Receiver调用时，参数异类对象的[[Get]]内部方法执行以下步骤： 令 args 为参数对象. 令 map 为 args.[[ParameterMap]]. 令 isMapped 为 ! HasOwnProperty(map, P). 若 isMapped 是 false, 那么 返回 ? OrdinaryGet(args, P, Receiver). 否则映射包含用于P的形式参数映射， 返回 Get(map, P). 9.4.4.4 [[Set]] ( P, V, Receiver ) 使用属性键P，值V和ECMAScript语言值Receiver调用时，参数异类对象的[[Set]]内部方法： 令 args 为参数对象. 若 SameValue(args, Receiver) 是 false, 那么 令 isMapped 为 false. 否则, 令 map 为 args.[[ParameterMap]]. 令 isMapped 为 ! HasOwnProperty(map, P). 若 isMapped 是 true, 那么 令 setStatus 为 Set(map, P, V, false). 断言: setStatus为true，因为参数对象映射的形参始终可写 返回 ? OrdinarySet(args, P, V, Receiver). 9.4.4.5 [[Delete]] ( P ) 用属性键P调用时，参数异类对象的[[Delete]]内部方法执行以下步骤： 令 args 为参数对象. 令 map 为 args.[[ParameterMap]]. 令 isMapped 为 ! HasOwnProperty(map, P). 令 result 为 ? OrdinaryDelete(args, P). 若 result 是 true 同时 isMapped 是 true, 那么 调用 map.[[Delete]](P). 返回 result. 9.4.4.6 CreateUnmappedArgumentsObject ( argumentsList ) 使用参数argumentsList调用的抽象操作CreateUnmappedArgumentsObject执行以下步骤： 令 len 为argumentsList中元素的数量。 令 obj 为 ObjectCreate(%ObjectPrototype%, « [[ParameterMap]] »). 设置 obj.[[ParameterMap]] 为 undefined. 执行 DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor { [[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }). 令 index 为 0. 重复, 直到 index 令 val 为 argumentsList[index]. 执行 CreateDataProperty(obj, ! ToString(index), val). index增加一 执行 ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }). 执行 ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false }). 返回 obj. 9.4.4.7 CreateMappedArgumentsObject ( func, formals, argumentsList, env ) 抽象操作CreateMappedArgumentsObject与对象函数，解析节点形式，列表argumentsList和环境记录环境一起调用。执行以下步骤： 断言: formals 不包含rest参数，任何绑定模式或任何初始化程序。它可能包含重复的标识符。 令 len 为argumentsList中元素的数量. 令 obj 为带有 [[ParameterMap]] 内部插槽的新创建的参数异类对象 设置 obj.[[GetOwnProperty]] 为 9.4.4.1 的规范. 设置 obj.[[DefineOwnProperty]] 的 9.4.4.2 的规范. 设置 obj.[[Get]] 为 9.4.4.3 的规范. 设置 obj.[[Set]] 为 9.4.4.4 的规范 . 设置 obj.[[Delete]] 为 9.4.4.5 的规范. 设置 obj 的其余基本内部方法为9.1中指定的默认普通对象定义。 设置 obj.[[Prototype]] 为 %ObjectPrototype%. 设置 obj.[[Extensible]] 为 true. 令 map 为 ObjectCreate(null). 设置 obj.[[ParameterMap]] 为 map. 令 parameterNames 为 formals 的绑定名称. 令 numberOfParameters 为 parameterNames 的元素数量. 令 index 为 0. 重复, 直到 index 令 val 为 argumentsList[index]. 执行 CreateDataProperty(obj, ! ToString(index), val). index增加1. 执行 DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor { [[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }). 令 mappedNames 为一个新的空列表. 令 index 为 numberOfParameters - 1. 重复, 直到 index ≥ 0, 令 name 为 parameterNames[index]. 若 name 不是 mappedNames 中的一个元素, 那么 添加 name，作为mappedNames列表的一个元素 若 index 令 g 为 MakeArgGetter(name, env). 令 p 为 MakeArgSetter(name, env). 执行 map.[[DefineOwnProperty]](! ToString(index), PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true }). index减一。 执行 ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }). 执行 ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor { [[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }). 返回 obj. 9.4.4.7.1 MakeArgGetter ( name, env ) 使用String name和环境记录项 env调用的抽象操作MakeArgGetter创建一个内置函数对象，该对象在执行时返回env中为name绑定的值。它执行以下步骤： 令 steps 为下面指定的ArgGetter函数的步骤。 令 getter 为 CreateBuiltinFunction(steps, « [[Name]], [[Env]] »). 设置 getter.[[Name]] 为 name. 设置 getter.[[Env]] 为 env. 返回 getter. ArgGetter函数是具有[[Name]]和[[Env]]内部插槽的匿名内置函数。当调用不期望参数的ArgGetter函数时，它将执行以下步骤： 令 f 为活动的函数对象 令 name 为 f.[[Name]]. 令 env 为 f.[[Env]]. 返回 env.GetBindingValue(name, false). 注：ArgGetter函数永远不能直接由ECMAScript代码访问。 9.4.4.7.2 MakeArgSetter ( name, env ) 使用String name和环境记录项 env调用的抽象操作MakeArgSetter创建一个内置函数对象，该对象在执行时设置env中为name绑定的值。它执行以下步骤： 令 steps 为下面指定的ArgGetter函数的步骤。 令 setter 为 CreateBuiltinFunction(steps, « [[Name]], [[Env]] »). 设置 setter.[[Name]] 为 name. 设置 setter.[[Env]] 为 env. 返回 setter. ArgSetter函数是具有[[Name]]和[[Env]]内部插槽的匿名内置函数。当使用参数值调用ArgSetter函数时，它将执行以下步骤： 令 f 为活动的函数对象 令 name 为 f.[[Name]]. 令 env 为 f.[[Env]]. 返回 env.SetMutableBinding(name, value, false). 注：ArgSetter函数永远不能直接由ECMAScript代码访问。 9.4.5 整数索引异类对象 整数索引的异类对象是对整数索引属性键执行特殊处理的异类对象。 整数索引的异类对象具有与普通对象相同的内部插槽，另外还具有[[ViewedArrayBuffer]]，[[ArrayLength]]，[[ByteOffset]]和[[TypedArrayName]]内部插槽。 整数索引的异类对象为以下内部方法提供了替代定义。以下未定义的所有其他IntegerIndexed异类对象基本内部方法均在9.1中指定。 9.4.5.1 [[GetOwnProperty]] ( P ) 当使用属性键P调用索引为整数的异类对象O的[[GetOwnProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 断言: O 是一个具有 [[ViewedArrayBuffer]] 内部插槽的对象。 若 Type(P) 是 String, 那么 令 numericIndex 为 ! CanonicalNumericIndexString(P). 若 numericIndex 不是 undefined, 那么 令 value 为 ? IntegerIndexedElementGet(O, numericIndex). 若 value 是 undefined, 返回 undefined. 返回 PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }. 返回 OrdinaryGetOwnProperty(O, P) 9.4.5.2 [[HasProperty]] ( P ) 当使用属性键P调用整数索引的异类对象O的[[HasProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 断言: O 是一个具有 [[ViewedArrayBuffer]] 内部插槽的对象。 若 Type(P) 是 String, 那么 令 numericIndex 为 ! CanonicalNumericIndexString(P). 若 numericIndex 不是 undefined, 那么 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 抛出 TypeError 异常. 若 IsInteger(numericIndex) 是 false, 返回 false. 若 numericIndex = -0, 返回 false. 若 numericIndex 若 numericIndex ≥ O.[[ArrayLength]], 返回 false. 返回 true. 返回 ? OrdinaryHasProperty(O, P). 9.4.5.3 [[DefineOwnProperty]] ( P, Desc ) 当使用属性键P和属性描述符Desc调用整数索引的异类对象O的[[DefineOwnProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 断言: O 是一个具有 [[ViewedArrayBuffer]] 内部插槽的对象。 若 Type(P) 是 String, 那么 令 numericIndex 为 ! CanonicalNumericIndexString(P). 若 numericIndex 不是 undefined, 那么 若 IsInteger(numericIndex) 是 false, 返回 false. 若 numericIndex = -0, 返回 false. 若 numericIndex 令 length 为 O.[[ArrayLength]]. 若 numericIndex ≥ length, 返回 false. 若 IsAccessorDescriptor(Desc) 是 true, 返回 false. 若 Desc 有 [[Configurable]] 字段，并且若 Desc.[[Configurable]] 是 true, 返回 false. 若 Desc 有 [[Enumerable]] 字段，并且若 Desc.[[Enumerable]] 是 false, 返回 false. 若 Desc 有 [[Writable]] 字段，并且若 Desc.[[Writable]] 是 false, 返回 false. 若 Desc 有 [[Value]] 字段, 那么 令 value 为 Desc.[[Value]]. 返回 ? IntegerIndexedElementSet(O, numericIndex, value). 返回 true. 返回 ! OrdinaryDefineOwnProperty(O, P, Desc) 9.4.5.4 [[Get]] ( P, Receiver ) 使用属性键P和ECMAScript语言值Receiver调用整数索引的异类对象O的[[Get]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 若 Type(P) 是 String, 那么 令 numericIndex 为 ! CanonicalNumericIndexString(P). 若 numericIndex 不是 undefined, 那么 返回 ? IntegerIndexedElementGet(O, numericIndex). 返回 ? OrdinaryGet(O, P, Receiver). 9.4.5.5 [[Set]] ( P, V, Receiver ) 当使用属性键P，值V和ECMAScript语言值Receiver调用整数索引的异类对象O的[[Set]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 若 Type(P) 是 String, 那么 令 numericIndex 为 ! CanonicalNumericIndexString(P). 若 numericIndex 不是 undefined, 那么 返回 ? IntegerIndexedElementSet(O, numericIndex, V). 返回 ? OrdinarySet(O, P, V, Receiver). 9.4.5.6 [[OwnPropertyKeys]] ( ) 当调用整数索引的异类对象O的[[OwnPropertyKeys]]内部方法时，将执行以下步骤： 令 keys 为一个新的空列表. 断言: O 是一个对象，具有 [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] 内部插槽. 令 len 为 O.[[ArrayLength]]. 对于每个以0开头的整数，i≤len，升序排列, 执行 添加 ! ToString(i) 到 keys 的最后一个元素 对于 O 的每个自己的属性键P，使得Type（P）为String且P不是整数索引，以属性创建的时间顺序升序, 执行 将P添加到键的最后一个元素。 对于 O 的每个自己的属性键P，以使Type（P）为Symbol，以属性创建的时间顺序升序, 执行 将P添加到键的最后一个元素。 返回 keys. 9.4.5.7 IntegerIndexedObjectCreate ( prototype, internalSlotsList ) 带参数prototype和internalSlotsList的抽象操作IntegerIndexedObjectCreate用于指定创建新的以整数索引表示的异类对象。参数internalSlotsList是必须定义为对象一部分的其他内部插槽名称的列表。IntegerIndexedObjectCreate执行以下步骤： 断言: internalSlotsList 包含名为 [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]] 和 [[TypedArrayName]]. 令 A 为一个新创建的对象，该对象的内部插槽为internalSlotsList中的每个名称 设置 A's essential internal methods 为 the default ordinary object definitions specified in 9.1. 设置 A.[[GetOwnProperty]] 按照 9.4.5.1的规范. 设置 A.[[HasProperty]] 按照 9.4.5.2 的规范. 设置 A.[[DefineOwnProperty]] 按照 9.4.5.3 的规范. 设置 A.[[Get]] 按照 9.4.5.4 的规范. 设置 A.[[Set]] 按照 9.4.5.5 的规范. 设置 A.[[OwnPropertyKeys]] 按照 9.4.5.6 的规范. 设置 A.[[Prototype]] 为 prototype. 设置 A.[[Extensible]] 为 true. 返回 A. 9.4.5.8 IntegerIndexedElementGet ( O, index ) 具有参数O和index的抽象操作IntegerIndexedElementGet执行以下步骤： 断言: Type(index) 是 Number. 断言: O 是一个对象，拥有 [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] 内部插槽. 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 抛出 TypeError 异常. 若 IsInteger(index) 是 false, 返回 undefined. 若 index = -0, 返回 undefined. 令 length 为 O.[[ArrayLength]]. 若 index 令 offset 为 O.[[ByteOffset]]. 令 arrayTypeName 为 O.[[TypedArrayName]] 的 String 值. 令 elementSize 为表59中为 arrayTypeName 指定的元素大小的Number值。 令 indexedPosition 为 (index × elementSize) + offset. 令 elementType 为表59中arrayTypeName的元素类型的String值。 返回 GetValueFromBuffer(buffer, indexedPosition, elementType, true, \"Unordered\"). 9.4.5.9 IntegerIndexedElementSet ( O, index, value ) 具有参数O，索引和值的抽象操作IntegerIndexedElementSet执行以下步骤： 断言: Type(index) 是 Number. 断言: O 是对象，拥有[[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] 内部插槽. 令 numValue 为 ? ToNumber(value). 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 抛出 TypeError 异常. 若 IsInteger(index) 是 false, 返回 false. 若 index = -0, 返回 false. 令 length 为 O.[[ArrayLength]]. 若 index 令 offset 为 O.[[ByteOffset]]. 令 arrayTypeName 为 O.[[TypedArrayName]] 的String值. 令 elementSize 为表59中为 arrayTypeName 指定的元素大小的Number值。 令 indexedPosition 为 (index × elementSize) + offset. 令 elementType 为表59中arrayTypeName的元素类型的String值。 执行 SetValueInBuffer(buffer, indexedPosition, elementType, numValue, true, \"Unordered\"). 返回 true 9.4.6 模块命名空间异类对象 模块名称空间对象是一个异类对象，它公开了从ECMAScript模块导出的绑定（请参见15.2.3）。模块名称空间异类对象的字符串键自己的属性与模块导出的绑定名称之间存在一一对应的关系。导出的绑定包括使用 export* 导出项间接导出的任何绑定。每个String值自己的属性键是相应的导出绑定名称的StringValue。这些是模块名称空间异类对象的唯一String-keyed属性。每个此类属性都具有属性{[[[Writable]]：true，[[Enumerable]]：true，[[Configurable]]：false}。模块名称空间对象不可扩展。 内部插槽 类型 描述 [[Module]] 模块记录项 此名称空间公开的模块记录 [[Exports]] String列表 一个列表，其中包含作为该对象的属性公开的导出名称的String值。该列表被排序，就好像使用Array.prototype.sort使用undefined作为comparefn对相同值的Array进行了排序一样。 模块名称空间异类对象为[[GetPrototypeOf]]以外的所有内部方法提供了替代定义，其行为符合9.1.1的定义。 9.4.6.1 [[SetPrototypeOf]] ( V ) 当使用参数V调用模块名称空间异类对象O的[[SetPrototypeOf]]内部方法时，将执行以下步骤： 返回 ? SetImmutablePrototype(O, V). 9.4.6.2 [[IsExtensible]] ( ) 当调用模块名称空间异类对象O的[[IsExtensible]]内部方法时，将执行以下步骤： 返回 false. 9.4.6.3 [[PreventExtensions]] ( ) 调用模块名称空间异类对象O的[[PreventExtensions]]内部方法时，将执行以下步骤： 返回 true. 9.4.6.4 [[GetOwnProperty]] ( P ) 当使用属性键P调用模块名称空间异类对象O的[[GetOwnProperty]]内部方法时，将执行以下步骤： 若 Type(P) 是 Symbol, 返回 OrdinaryGetOwnProperty(O, P). 令 exports 为 O.[[Exports]]. 若 P 不是 exports 的一个元素, 返回 undefined. 令 value 为 ? O.[[Get]](P, O). 返回 PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }. 9.4.6.5 [[DefineOwnProperty]] ( P, Desc ) 当使用属性键P和属性描述符Desc调用模块名称空间异类对象O的[[DefineOwnProperty]]内部方法时，将执行以下步骤： 若 Type(P) 是 Symbol, 返回 OrdinaryDefineOwnProperty(O, P, Desc). 令 current 为 ? O.[[GetOwnProperty]](P). 若 current 是 undefined, 返回 false. 若 IsAccessorDescriptor(Desc) 是 true, 返回 false. 若 Desc.[[Writable]] 存在，值为false, 返回 false. 若 Desc.[[Enumerable]] 存在，值为false, 返回 false. 若 Desc.[[Configurable]] 存在，值为true, 返回 false. 若 Desc.[[Value]] 存在, 返回 SameValue(Desc.[[Value]], current.[[Value]]). 返回 true. 9.4.6.6 [[HasProperty]] ( P ) 当使用属性键P调用模块名称空间异类对象O的[[HasProperty]]内部方法时，将执行以下步骤： 若 Type(P) 是 Symbol, 返回 OrdinaryHasProperty(O, P). 令 exports 为 O.[[Exports]]. 若 P 是 exports 的一个元素, 返回 true. 返回 false 9.4.6.7 [[Get]] ( P, Receiver ) 当使用属性键P和ECMAScript语言值Receiver调用模块名称空间异类对象O的[[Get]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 若 Type(P) 是 Symbol, 那么 返回 ? OrdinaryGet(O, P, Receiver). 令 exports 为 O.[[Exports]]. 若 P 不是 exports 的一个元素, 返回 undefined. 令 m 为 O.[[Module]]. 令 binding 为 ! m.ResolveExport(P, « »). 断言: binding 是 ResolvedBinding 记录项. 令 targetModule 为 binding.[[Module]]. 断言: targetModule 不是 undefined. 令 targetEnv 为 targetModule.[[Environment]]. 若 targetEnv 是 undefined, 抛出 ReferenceError 异常. 令 targetEnvRec 为 targetEnv 的环境记录项. 返回 ? targetEnvRec.GetBindingValue(binding.[[BindingName]], true). 注：ResolveExport是幂等且无副作用的。一个实现可能选择为每个模块名称空间异类对象的[[Exports]]预计算或缓存ResolveExport结果。 9.4.6.8 [[Set]] ( P, V, Receiver ) 当使用属性键P，值V和ECMAScript语言值Receiver调用模块名称空间异类对象O的[[Set]]内部方法时，将执行以下步骤： 返回 false. 9.4.6.9 [[Delete]] ( P ) 当使用属性键P调用模块名称空间异类对象O的[[Delete]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 若 Type(P) 是 Symbol, 那么 返回 ? OrdinaryDelete(O, P). 令 exports 为 O.[[Exports]]. 若 P 是 exports 的一个元素, 返回 false. 返回 true. 9.4.6.10 [[OwnPropertyKeys]] ( ) 当调用模块名称空间异类对象O的[[OwnPropertyKeys]]内部方法时，将执行以下步骤： 令 exports 为 O.[[Exports]] 的一个拷贝. 令 symbolKeys 为 ! OrdinaryOwnPropertyKeys(O). 将 symbolKeys 的所有条目追加到导出的末尾。 返回 exports. 9.4.6.11 ModuleNamespaceCreate ( module, exports ) 带参数模块的抽象操作ModuleNamespaceCreate和export用于指定创建新模块名称空间的异类对象。它执行以下步骤： 断言: module 是模块记录项. 断言: module.[[Namespace]] 是 undefined. 断言: exports 是String值的一个列表. 令 M 为新创建的对象. 设置 M 的基本内部方法为9.4.6中指定的定义 设置 M.[[Module]] 为 module. 令 sortedExports 为一个新列表，其包含与列表导出相同的值，列表中的值按顺序排列，就好像使用Array.prototype.sort使用undefined作为comparefn对相同值的Array进行了排序一样。 设置 M.[[Exports]] 为 sortedExports. 创建与26.3中的定义相对应的 M 的私有属性 设置 module.[[Namespace]] 为 M. 返回 M 9.4.7 不变原型异类对象 不变的原型异类对象是具有[[Prototype]]内部插槽的异类对象，该内部插槽一旦初始化就不会更改。 不可变的原型异物具有与普通对象相同的内部插槽。它们仅在以下内部方法中才是异类的。下面未明确定义的不变原型奇特对象的所有其他内部方法改为在普通对象中定义。 9.4.7.1 [[SetPrototypeOf]] ( V ) 当使用参数V调用不可变原型异类对象O的[[SetPrototypeOf]]内部方法时，将执行以下步骤： 返回 ? SetImmutablePrototype(O, V) 9.4.7.2 SetImmutablePrototype ( O, V ) 当使用参数O和V调用SetImmutablePrototype抽象操作时，将执行以下步骤： 断言: Either Type(V) 是 Object 或 Type(V) 是 Null. 令 current 为 ? O.[[GetPrototypeOf]](). 若 SameValue(V, current) 是 true, 返回 true. 返回 false. 9.5 代理对象内部方法和内部插槽 代理对象是一个异类对象，其基本内部方法使用ECMAScript代码部分实现。每个代理对象都有一个名为[[ProxyHandler]]的内部插槽。[[ProxyHandler]]的值是一个对象，称为代理的处理程序对象，或者为null。处理程序对象的方法（请参见表30）可以用于增强代理对象的一个或多个内部方法的实现。每个代理对象还具有一个名为[[ProxyTarget]]的内部插槽，其值可以是对象或null值。该对象称为代理的目标对象。 内部方法 处理方法 [[GetPrototypeOf]] getPrototypeOf [[SetPrototypeOf]] setPrototypeOf [[IsExtensible]] isExtensible [[PreventExtensions]] preventExtensions [[GetOwnProperty]] getOwnPropertyDescriptor [[HasProperty]] has [[Get]] get [[Set]] set [[Delete]] deleteProperty [[DefineOwnProperty]] defineProperty [[OwnPropertyKeys]] ownKeys [[Call]] apply [[Construct]] construct 当调用处理程序方法以提供代理对象内部方法的实现时，会将处理程序方法作为参数传递给代理的目标对象。代理的处理程序对象不一定具有对应于每个基本内部方法的方法。如果处理程序对象没有对应于内部陷阱的方法，则在代理上调用内部方法将导致在代理的目标对象上调用相应的内部方法。 代理对象的[[ProxyHandler]]和[[ProxyTarget]]内部插槽在创建对象时总是被初始化，通常不能修改。某些代理对象的创建方式允许它们随后被吊销。吊销代理后，其[[ProxyHandler]]和[[ProxyTarget]]内部插槽设置为null，从而导致对该代理对象的内部方法的后续调用引发TypeError异常。 由于代理对象允许通过任意ECMAScript代码提供内部方法的实现，因此可以定义其处理程序方法违反6.1.7.3中定义的不变量的代理对象。6.1.7.3中定义的一些内部方法不变式是必不可少的完整性不变式。这些不变量由本节中指定的代理对象内部方法明确实施。在存在所有可能的不变违规的情况下，ECMAScript实现必须具有鲁棒性。 在以下算法描述中，假设O是ECMAScript代理对象，P是属性键值，V是任何ECMAScript语言值，而Desc是属性描述符记录 9.5.1 [[GetPrototypeOf]] ( ) 当调用代理异类对象O的[[GetPrototypeOf]]内部方法时，将执行以下步骤： 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"getPrototypeOf\"). 若 trap 是 undefined, 那么 返回 ? target.[[GetPrototypeOf]](). 令 handlerProto 为 ? Call(trap, handler, « target »). 若 Type(handlerProto) 不是 Object 或 Null, 抛出 TypeError 异常. 令 extensibleTarget 为 ? IsExtensible(target). 若 extensibleTarget 是 true, 返回 handlerProto. 令 targetProto 为 ? target.[[GetPrototypeOf]](). 若 SameValue(handlerProto, targetProto) 是 false, 抛出 TypeError 异常. 返回 handlerProto 注：代理对象的[[GetPrototypeOf]]强制执行以下不变量： [[GetPrototypeOf]]的结果必须是Object或null。如果目标对象不可扩展，则应用于代理对象的[[GetPrototypeOf]]必须返回与应用于代理对象的目标对象的[[GetPrototypeOf]]相同的值。 9.5.2 [[SetPrototypeOf]] ( V ) 当使用参数V调用代理异类对象O的[[SetPrototypeOf]]内部方法时，将执行以下步骤： 断言: Type(V) 是 Object 或 Null. 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"setPrototypeOf\"). 若 trap 是 undefined, 那么 返回 ? target.[[SetPrototypeOf]](V). 令 booleanTrapResult 为 ToBoolean(? Call(trap, handler, « target, V »)). 若 booleanTrapResult 是 false, 返回 false. 令 extensibleTarget 为 ? IsExtensible(target). 若 extensibleTarget 是 true, 返回 true. 令 targetProto 为 ? target.[[GetPrototypeOf]](). 若 SameValue(V, targetProto) 是 false, 抛出 TypeError 异常. 返回 true. 注：代理对象的[[SetPrototypeOf]]强制执行以下不变量： [[SetPrototypeOf]]的结果是一个布尔值。如果目标对象不可扩展，则参数值必须与应用于目标对象的[[GetPrototypeOf]]的结果相同。 9.5.3 [[IsExtensible]] ( ) 当调用代理异类对象O的[[IsExtensible]]内部方法时，将执行以下步骤： 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"isExtensible\"). 若 trap 是 undefined, 那么 a. 返回 ? target.[[IsExtensible]](). 令 booleanTrapResult 为 ToBoolean(? Call(trap, handler, « target »)). 令 targetResult 为 ? target.[[IsExtensible]](). 若 SameValue(booleanTrapResult, targetResult) 是 false, 抛出 TypeError 异常. 返回 booleanTrapResult. 注：代理对象的[[IsExtensible]]强制执行以下不变量： [[IsExtensible]]的结果是一个布尔值。应用于代理对象的[[IsExtensible]]必须返回与具有相同参数的应用于代理对象的目标对象的[[IsExtensible]]相同的值。 9.5.4 [[PreventExtensions]] ( ) 当调用代理异类对象O的[[PreventExtensions]]内部方法时，将执行以下步骤： 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"preventExtensions\"). 若 trap 是 undefined, 那么 返回 ? target.[[PreventExtensions]](). 令 booleanTrapResult 为 ToBoolean(? Call(trap, handler, « target »)). 若 booleanTrapResult 是 true, 那么 令 targetIsExtensible 为 ? target.[[IsExtensible]](). 若 targetIsExtensible 是 true, 抛出 TypeError 异常. 返回 booleanTrapResult. 注：代理对象的[[PreventExtensions]]强制执行以下不变量： [[PreventExtensions]]的结果是一个布尔值。仅当应用于代理对象目标对象的[[IsExtensible]]为false时，应用于代理对象的[[PreventExtensions]]才返回true。 9.5.5 [[GetOwnProperty]] ( P ) 当使用属性键P调用Proxy异类对象O的[[GetOwnProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"getOwnPropertyDescriptor\"). 若 trap 是 undefined, 那么 返回 ? target.[[GetOwnProperty]](P). 令 trapResultObj 为 ? Call(trap, handler, « target, P »). 若 Type(trapResultObj) 不是 Object 或 Undefined, 抛出 TypeError 异常. 令 targetDesc 为 ? target.[[GetOwnProperty]](P). 若 trapResultObj 是 undefined, 那么 若 targetDesc 是 undefined, 返回 undefined. 若 targetDesc.[[Configurable]] 是 false, 抛出 TypeError 异常. 令 extensibleTarget 为 ? IsExtensible(target). 若 extensibleTarget 是 false, 抛出 TypeError 异常. 返回 undefined. 令 extensibleTarget 为 ? IsExtensible(target). 令 resultDesc 为 ? ToPropertyDescriptor(trapResultObj). 调用 CompletePropertyDescriptor(resultDesc). 令 valid 为 IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc). 若 valid 是 false, 抛出 TypeError 异常. 若 resultDesc.[[Configurable]] 是 false, 那么 若 targetDesc 是 undefined 或 targetDesc.[[Configurable]] 是 true, 那么 抛出 TypeError 异常. 返回 resultDesc. 注：代理对象的[[GetOwnProperty]]强制执行以下不变量： [[GetOwnProperty]]的结果必须是Object或undefined。 如果属性作为目标对象的不可配置的自身属性存在，则不能将其报告为不存在。 如果属性作为目标对象的自身属性存在并且目标对象不可扩展，则不能将其报告为不存在。 如果属性不作为目标对象的自身属性存在并且目标对象不可扩展，则不能将其报告为存在。 如果属性不作为目标对象的自身属性存在，或者作为目标对象的可配置自身属性存在，则不能将其报告为不可配置。 9.5.6 [[DefineOwnProperty]] ( P, Desc ) 当使用属性键P和属性描述符Desc调用代理异类对象O的[[DefineOwnProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"defineProperty\"). 若 trap 是 undefined, 那么 返回 ? target.[[DefineOwnProperty]](P, Desc). 令 descObj 为 FromPropertyDescriptor(Desc). 令 booleanTrapResult 为 ToBoolean(? Call(trap, handler, « target, P, descObj »)). 若 booleanTrapResult 是 false, 返回 false. 令 targetDesc 为 ? target.[[GetOwnProperty]](P). 令 extensibleTarget 为 ? IsExtensible(target). 若 Desc 有 [[Configurable]] 字段 and 若 Desc.[[Configurable]] 是 false, 那么 令 settingConfigFalse 为 true. 否则, 令 settingConfigFalse 为 false. 若 targetDesc 是 undefined, 那么 若 extensibleTarget 是 false, 抛出 TypeError 异常. 若 settingConfigFalse 是 true, 抛出 TypeError 异常. 否则 targetDesc 不是 undefined, 若 IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) 是 false, 抛出 TypeError 异常. 若 settingConfigFalse 是 true and targetDesc.[[Configurable]] 是 true, 抛出 TypeError 异常. 返回 true. 注：代理对象的[[DefineOwnProperty]]强制执行以下不变量： [[DefineOwnProperty]]的结果是一个布尔值。 如果目标对象不可扩展，则无法添加属性。 除非目标对象存在相应的不可配置的自身属性，否则属性不能不可配置。 如果属性具有对应的目标对象属性，则使用[[DefineOwnProperty]]将属性的属性描述符应用于目标对象将不会引发异常。 9.5.7 [[HasProperty]] ( P ) 当使用属性键P调用Proxy异类对象O的[[HasProperty]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"has\"). 若 trap 是 undefined, 那么 返回 ? target.[[HasProperty]](P) 令 booleanTrapResult 为 ToBoolean(? Call(trap, handler, « target, P »)). 若 booleanTrapResult 是 false, 那么 令 targetDesc 为 ? target.[[GetOwnProperty]](P). 若 targetDesc 不是 undefined, 那么 若 targetDesc.[[Configurable]] 是 false, 抛出 TypeError 异常. 令 extensibleTarget 为 ? IsExtensible(target). 若 extensibleTarget 是 false, 抛出 TypeError 异常. 返回 booleanTrapResult. 注：代理对象的[[HasProperty]]强制执行以下不变量： [[HasProperty]]的结果是一个布尔值。 如果属性作为目标对象的不可配置的自身属性存在，则不能将其报告为不存在。 如果属性作为目标对象的自身属性存在并且目标对象不可扩展，则不能将其报告为不存在。 9.5.8 [[Get]] ( P, Receiver ) 使用属性键P和ECMAScript语言值Receiver调用代理异类对象O的[[Get]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"get\"). 若 trap 是 undefined, 那么 返回 ? target.[[Get]](P, Receiver). 令 trapResult 为 ? Call(trap, handler, « target, P, Receiver »). 令 targetDesc 为 ? target.[[GetOwnProperty]](P). 若 targetDesc 不是 undefined 并且 targetDesc.[[Configurable]] 是 false, 那么 若 IsDataDescriptor(targetDesc) 是 true 并且 targetDesc.[[Writable]] 是 false, 那么 若 SameValue(trapResult, targetDesc.[[Value]]) 是 false, 抛出 TypeError 异常. 若 IsAccessorDescriptor(targetDesc) 是 true 并且 targetDesc.[[Get]] 是 undefined, 那么 若 trapResult 不是 undefined, 抛出 TypeError 异常. 返回 trapResult. 注：代理对象的[[Get]]强制执行以下不变量： 如果目标对象属性是不可写的，不可配置的自身数据属性，则为属性报告的值必须与相应目标对象属性的值相同。如果相应的目标对象属性是不可定义的自己的访问器属性，并且其[[Get]]属性未定义，则该属性的报告值必须是未定义的。 9.5.9 [[Set]] ( P, V, Receiver ) 使用属性键P，值V和ECMAScript语言值Receiver调用代理异类对象O的[[Set]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"设置\"). 若 trap 是 undefined, 那么 返回 ? target.[[Set]](P, V, Receiver). 令 booleanTrapResult 为 ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)). 若 booleanTrapResult 是 false, 返回 false. 令 targetDesc 为 ? target.[[GetOwnProperty]](P). 若 targetDesc 不是 undefined 并且 targetDesc.[[Configurable]] 是 false, 那么 若 IsDataDescriptor(targetDesc) 是 true 并且 targetDesc.[[Writable]] 是 false, 那么 若 SameValue(V, targetDesc.[[Value]]) 是 false, 抛出 TypeError 异常. 若 IsAccessorDescriptor(targetDesc) 是 true, 那么 若 targetDesc.[[Set]] 是 undefined, 抛出 TypeError 异常. 返回 true 注：代理对象的[[Set]]强制执行以下不变量： [[Set]]的结果是布尔值。如果相应的目标对象属性是不可写的，不可配置的自身数据属性，则无法将属性的值更改为与相应目标对象属性的值不同的值。如果相应的目标对象属性是其[[Set]]属性未定义的不可配置的自身访问器属性，则无法设置属性的值。 9.5.10 [[Delete]] ( P ) 当使用属性键P调用Proxy异类对象O的[[Delete]]内部方法时，将执行以下步骤： 断言: IsPropertyKey(P) 是 true. 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"deleteProperty\"). 若 trap 是 undefined, 那么 返回 ? target.[[Delete]](P) 令 booleanTrapResult 为 ToBoolean(? Call(trap, handler, « target, P »)). 若 booleanTrapResult 是 false, 返回 false. 令 targetDesc 为 ? target.[[GetOwnProperty]](P). 若 targetDesc 是 undefined, 返回 true. 若 targetDesc.[[Configurable]] 是 false, 抛出 TypeError 异常. 返回 true. 注：代理对象的[[Delete]]强制执行以下不变量： [[Delete]]的结果是一个布尔值。 如果属性作为目标对象的不可配置的自身属性存在，则不能将其报告为已删除 9.5.11 [[OwnPropertyKeys]] ( ) 当调用代理异类对象O的[[OwnPropertyKeys]]内部方法时，将执行以下步骤： 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"ownKeys\"). 若 trap 是 undefined, 那么 返回 ? target.[[OwnPropertyKeys]](). 令 trapResultArray 为 ? Call(trap, handler, « target »). 令 trapResult 为 ? CreateListFromArrayLike(trapResultArray, « String, Symbol »). 若 trapResult 包含任何重复的条目, 抛出 TypeError 异常. 令 extensibleTarget 为 ? IsExtensible(target). 令 targetKeys 为 ? target.[[OwnPropertyKeys]](). 断言: targetKeys 是一个仅包含 String 和 Symbol 的列表。 断言: targetKeys 包含不重复的条目. 令 targetConfigurableKeys 为一个新的空列表. 令 targetNonconfigurableKeys 为一个新的空列表. 对于targetKeys的每个key元素, 执行 令 desc 为 ? target.[[GetOwnProperty]](key). 若 desc 不是 undefined 同时 desc.[[Configurable]] 是 false, 那么 添加 key，作为 targetNonconfigurableKeys 的一个元素. 否则, 添加 key，作为 targetConfigurableKeys 的一个元素 若 extensibleTarget 是 true 并且 targetNonconfigurableKeys 是 empty, 那么 返回 trapResult. 令 uncheckedResultKeys 为新列表，它是 trapResult 的副本 对于 targetNonconfigurableKeys 的每一个元素 key, 执行 若 key 不是 uncheckedResultKeys 的一个元素, 抛出 TypeError 异常. 从 uncheckedResultKeys 中移除key. 若 extensibleTarget 是 true, 返回 trapResult. 对于 targetConfigurableKeys 中的每一个元素key, 执行 若 key 不是 uncheckedResultKeys 中的一个元素, 抛出 TypeError 异常. 从 uncheckedResultKeys 中移除key. 若 uncheckedResultKeys 不是 empty, 抛出 TypeError 异常. 返回 trapResult. 注：代理对象的[[OwnPropertyKeys]]强制执行以下不变量： [[OwnPropertyKeys]]的结果是一个列表。 返回的列表不包含重复的条目。 每个结果列表元素的类型是String或Symbol。 结果列表必须包含目标对象所有不可配置的自身属性的键。 如果目标对象不可扩展，则结果列表必须包含目标对象自身属性的所有键，并且不包含其他值。 9.5.12 [[Call]] ( thisArgument, argumentsList ) 代理异类对象O的[[Call]]内部方法使用参数thisArgument和argumentsList（ECMAScript语言值列表）来调用。采取以下步骤： 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 令 trap 为 ? GetMethod(handler, \"apply\"). 若 trap 是 undefined, 那么 返回 ? Call(target, thisArgument, argumentsList). 令 argArray 为 CreateArrayFromList(argumentsList). 返回 ? Call(trap, handler, « target, thisArgument, argArray »). 注：如果Proxy异类对象的[[ProxyTarget]]内部插槽的初始值是具有[[Call]]内部方法的对象，则仅具有[[Call]]内部方法。 9.5.13 [[Construct]] ( argumentsList, newTarget ) 代理异类对象O的[[Construct]]内部方法用参数argumentsList调用，该参数可能是ECMAScript语言值和newTarget的可能为空的列表。采取以下步骤： 令 handler 为 O.[[ProxyHandler]]. 若 handler 是 null, 抛出 TypeError 异常. 断言: Type(handler) 是 Object. 令 target 为 O.[[ProxyTarget]]. 断言: IsConstructor(target) 是 true. 令 trap 为 ? GetMethod(handler, \"construct\"). 若 trap 是 undefined, 那么 返回 ? Construct(target, argumentsList, newTarget). 令 argArray 为 CreateArrayFromList(argumentsList). 令 newObj 为 ? Call(trap, handler, « target, argArray, newTarget »). 若 Type(newObj) 不是 Object, 抛出 TypeError 异常. 返回 newObj. 注1：如果代理异类对象的[[ProxyTarget]]内部插槽的初始值是具有[[Construct]]内部方法的对象，则该对象仅具有[[Construct]]内部方法。 注2：代理对象的[[Construct]]强制执行以下不变量： ​ [[Construct]]的结果必须是一个Object。 9.5.14 ProxyCreate ( target, handler ) 具有参数target和handler的抽象操作ProxyCreate用于指定创建新的Proxy异类对象。它执行以下步骤： 若 Type(target) 不是 Object, 抛出 TypeError 异常. 若 target 是代理异类对象，并且 target.[[ProxyHandler]] 是 null, 抛出 TypeError 异常. 若 Type(handler) 不是 Object, 抛出 TypeError 异常. 若 handler 是代理异类对象，并且 handler.[[ProxyHandler]] 是 null, 抛出 TypeError 异常. 令 P 为新创建的对象. 设置 P的基本内部方法（[[Call]]和[[Construct]]除外）为9.5中指定的定义 若 IsCallable(target) 是 true, 那么 设置 P.[[Call]] 按照 9.5.12 的规范. 若 IsConstructor(target) 是 true, 那么 设置 P.[[Construct]] 按照 9.5.13 的规范. 设置 P.[[ProxyTarget]] 为 target. 设置 P.[[ProxyHandler]] 为 handler. 返回 P. 所有普通对象都有一个称为[[Prototype]]的内部插槽。此内部插槽的值可以为null或一个对象，用于实现继承。[[Prototype]]对象的数据属性被继承（作为子对象的属性可见），是为了取值权限，而不是赋值权限。访问器属性被继承，同时获得取值权限和赋值权限。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,普通和异类对象行为,ordinary-and-exotic-object-behaviours "},"source-code.html":{"url":"source-code.html","title":"10 ECMAScript语言：源代码","keywords":"","body":"10 ECMAScript语言：源代码 10.1 源文本 语法： SourceCharacter:: any Unicode code point ECMAScript代码使用Unicode表示。ECMAScript源文本是一系列代码点。从U+0000到U+10FFFF的所有Unicode码点，包括代理码点，都可能出现在ECMAScript语法允许的源文本中。用于存储和交换ECMAScript源文本的实际编码与该规范无关。不管外部源文本如何编码，符合ECMAScript的实现都将源文本当作源字符值的等效序列来处理，每个源字符都是一个Unicode码点。不需要执行ECMAScript一致性实现即可对源代码进行任何标准化文本，或者表现得好像他们正在对源文本进行规范化。 即使用户可能会将整个序列视为单个字符，也将组合字符序列的组成部分视为单独的Unicode码点。 注意： 在字符串文字，正则表达式文字，模板文字和标识符中，任何Unicode码点也可以使用Unicode转义序列表示，该转义序列明确表示代码点的数值。在注释中，这样的转义序列实际上会被忽略为注释的一部分。 ECMAScript在Unicode转义序列的行为方面与Java编程语言不同。例如，在Java程序中，如果Unicode转义序列\\ u000A出现在单行注释中，它将被解释为行终止符（Unicode代码点U + 000A为LINE FEED（LF）），因此下一个代码重点不是评论的一部分。同样，如果Unicode转义序列\\ u000A出现在Java程序的字符串文字中，则它也被解释为行终止符，这在字符串文字中是不允许的-必须写\\ n而不是\\ u000A才能引起LINEFEED（LF）成为字符串文字的String值的一部分。在ECMAScript程序中，注释中出现的Unicode转义序列永远不会被解释，因此不会有助于注释的终止。同样，在ECMAScript程序的字符串文字中出现的Unicode转义序列始终对文字有帮助，并且永远不会解释为行终止符或可能会终止字符串文字的代码点。 10.1.1 SS: UTF16Encoding ( cp ) 数字代码点值cp的UTF16Encoding如下确定： 断言: 0 ≤ cp ≤ 0x10FFFF. 若 cp ≤ 0xFFFF, 返回 cp. 令 cu1 为 floor((cp - 0x10000) / 0x400) + 0xD800. 令 cu2 为 ((cp - 0x10000) modulo 0x400) + 0xDC00. 返回由 cu1 和 cu2 组成的码元序列。 10.1.2 SS: UTF16Decode ( lead, trail ) 通过执行以下步骤，将形成UTF-16代理对的两个代码单元（前导和尾随）转换为代码点： 断言: lead 是先行代理，trail 是尾代理 令 cp 为 (lead - 0xD800) × 0x400 + (trail - 0xDC00) + 0x10000. 返回码点 cp 10.2 源代码类型 ECMAScript代码有四种类型： 全局代码是被视为ECMAScript脚本的源文本。特定脚本的全局代码不包含作为FunctionDeclaration，FunctionExpression，GeneratorDeclaration，GeneratorExpression，AsyncFunctionDeclaration，AsyncFunctionExpression，AsyncGeneratorDeclaration，AsyncGeneratorExpression，MethodDefinition，ArrowFunction，AsyncArrowFunction，ClassDeclaration 或 ClassExpression。 Eval代码是提供给内置 eval 函数的源文本。更准确地说，如果内置eval函数的参数是String，则将其视为ECMAScript脚本。特定eval调用的eval代码是该脚本的全局代码部分。 函数代码是经过解析的源文本，以提供ECMAScript功能对象的[[ECMAScriptCode]]和[[FormalParameters]]内部插槽的值（请参见9.2）。特定ECMAScript函数的函数代码不包含任何源文本，这些源文本被解析为嵌套的FunctionDeclaration，FunctionExpression，GeneratorDeclaration，GeneratorExpression，AsyncFunctionDeclaration, AsyncFunctionExpression, AsyncGeneratorDeclaration, AsyncGeneratorExpression, MethodDefinition, ArrowFunction, AsyncArrowFunction, ClassDeclaration, 或 ClassExpression. 模块代码是源文本，它是作为ModuleBody提供的代码。初始化模块时直接执行该代码。特定模块的模块代码不包含作为嵌套的FunctionDeclaration，FunctionExpression，GeneratorDeclaration，GeneratorExpression，AsyncFunctionDeclaration，AsyncFunctionExpression，AsyncGeneratorDeclaration，AsyncGeneratorExpression，MethodDefinition，ArrowFunction，AsyncArrowFunction，ClassDeclaration或ClassExpression的一部分解析的任何源文本。 注意： 通常将函数代码作为函数定义（14.1），箭头函数定义（14.2），方法定义（14.3），生成器函数定义（14.4），异步函数定义（14.7），异步生成器函数定义（14.5），和异步箭头函数（14.8）。函数代码还从 Function 构造函数（19.2.1.1），GeneratorFunction构造函数（25.2.1.1）和 AsyncFunction 构造函数（25.7.1.1）的参数派生。 10.2.1 严格模式代码 可以使用非限制或严格模式的语法和语义来处理ECMAScript脚本语法单元。在以下情况下，代码被解释为严格模式代码： 如果全局代码以包含使用严格指令的指令序言开头，则它是严格模式代码。 模块代码始终是严格模式代码。 ClassDeclaration或ClassExpression的所有部分都是严格模式代码。 如果Eval代码以包含使用严格指令的指令序言开头，或者如果eval的调用是严格模式代码中包含的直接eval，则Eval代码为严格模式代码。 如果关联的FunctionDeclaration，FunctionExpression，GeneratorDeclaration，GeneratorExpression，AsyncFunctionDeclaration，AsyncFunctionExpression，AsyncGeneratorDeclaration，AsyncGeneratorExpression，MethodDefinition，ArrowFunction或AsyncArrowFunction包含在严格模式代码中，或者产生该函数的[[[ECMAScriptCode]]内部插槽以包含使用严格指令的指令序言开头，则函数代码是严格模式代码。 如果最后一个参数是一个字符串，则该函数代码作为内置函数，生成器，AsyncFunction和AsyncGenerator构造函数的参数提供的函数代码是严格模式代码，该字符串在处理时是一个以包含使用严格性的指令序言开头的FunctionBody指示。 不是严格模式代码的ECMAScript代码称为非严格代码。 10.2.2 非ECMAScript函数 ECMAScript实现可能支持对其可求值行为是异类对象的函数求值，除了通过ECMAScript代码之外，还可以用一些可执行代码的实现定义形式来表示。从调用或由此类非ECMAScript函数调用的ECMAScript代码函数的角度来看，从语义上无法观察到函数对象是ECMAScript代码函数还是非ECMAScript函数。 ECMAScript代码使用Unicode表示。ECMAScript源文本是一系列代码点。从U+0000到U+10FFFF的所有Unicode码点，包括代理码点，都可能出现在ECMAScript语法允许的源文本中。用于存储和交换ECMAScript源文本的实际编码与该规范无关。不管外部源文本如何编码，符合ECMAScript的实现都将源文本当作源字符值的等效序列来处理，每个源字符都是一个Unicode码点。不需要执行ECMAScript一致性实现即可对源代码进行任何标准化文本，或者表现得好像他们正在对源文本进行规范化。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,ECMAScript语言 源代码,source-code"},"lexical-grammar.html":{"url":"lexical-grammar.html","title":"11 ECMAScript语言：词法语法","keywords":"","body":"11 ECMAScript语言：词法 首先将ECMAScript脚本或模块的源文本转换成一系列输入元素，这些输入元素是标记，行终止符，注释或空白。从左到右扫描源文本，重复使用尽可能长的码点序列作为下一个输入元素。 在几种情况下，词法输入元素的识别对使用输入元素的句法上下文很敏感。这要求词法具有多个目标符号。InputElementRegExpOrTemplateTail 目标用于允许使用 RegularExpressionLiteral，TemplateMiddle 或 TemplateTail 的句法上下文中。InputElementRegExp 目标符号用于所有允许使用 RegularExpressionLiteral 但不允许 TemplateMiddle 或 TemplateTail 的句法上下文中。InputElementTemplateTail 目标用于所有允许使用 TemplateMiddle 或 TemplateTail 但不允许使用 RegularExpressionLiteral 的句法上下文中。在所有其他上下文中，InputElementDiv 用作词法目标符号。 注意 使用多个词法目标可确保不会出现会影响自动分号插入的词法歧义。例如，没有句法上下文允许同时使用前导除法或除赋值和前导RegularExpressionLiteral。这不受分号插入的影响（请参见11.9）。在如下示例中： a = b /hi/g.exec(c).map(d); 如果LineTerminator之后的第一个非空白，非注释码点为U+002F（/），并且语法上下文允许进行除法或除赋值，则LineTerminator上不会插入分号。也就是说，以上示例的解释方式与： a = b /hi/ g.exec(c).map(d); 语法 InputElementDiv :: WhiteSpace LineTerminator Comment CommonToken DivPunctuator RightBracePunctuator InputElementRegExp :: WhiteSpace LineTerminator Comment CommonToken RightBracePunctuator RegularExpressionLiteral InputElementRegExpOrTemplateTail :: WhiteSpace LineTerminator Comment CommonToken RegularExpressionLiteral TemplateSubstitutionTail InputElementTemplateTail :: WhiteSpace LineTerminator Comment CommonToken DivPunctuator TemplateSubstitutionTail 11.1 Unicode格式控制字符 Unicode 格式控制字符（即，Unicode 字符数据库中 Cf分类 里的字符，如“左至右符号”或“右至左符号”）是用来控制被更高层级协议（如标记语言）忽略的文本范围的格式的控制代码。 允许在源代码文本中出现控制字符是有利于编辑和显示的。所有格式控制字符可写入到注释、字符串字面量、模板自变量和正则表达式字面量中。 U+200C（零宽不连字）和U+200D（零宽连字符）是格式控制字符，用于在形成某些语言的单词或短语时进行必要的区分。在ECMAScript源文本中，这些码点也可以在第一个字符之后的IdentifierName中使用。 U+FEFF（零宽不换行）是一种格式控制字符，主要用于文本的开头，以将其标记为Unicode，并允许检测文本的编码和字节顺序。用于此目的的\\字符有时也可能在文本开头之后出现，例如，由于连接文件而引起的。在ECMAScript源文本中，\\码点被视为空白字符（请参见11.2）。 表31总结了注释，字符串文字和正则表达式文字之外的某些格式控制字符的特殊处理。 码点 名称 缩写 用途 U+200C 零宽不连字 \\ 标识符部分 U+200D 零宽连字符 \\ 标识符部分 U+FEFF 零宽不换行 \\ 空格 11.2 空格 空格码点用于提高源文本的可读性，并将标记（不可分割的词法单位）彼此分隔开，但在其他方面则无关紧要。空格码点可能出现在任意两个标记之间以及输入的开始或结尾。空格码点可能出现在StringLiteral，RegularExpressionLiteral，Template或TemplateSubstitutionTail中，这些空格被视为构成文字值一部分的重要码点。它们也可能出现在注释中，但不能出现在任何其他种类的标记中。 表32中列出了ECMAScript空格码点。 码点 名称 缩写 U+0009 制表符 \\ U+000B 行制表符 \\ U+000C 换行 (FF) \\ U+0020 空格 \\ U+00A0 不换行空格 \\ U+FEFF 零宽不换行 \\ 其他类别 “Zs” 其他Unicode的“空白分隔符”码点 \\ ECMAScript实现必须将“空白分隔符”（“ Zs”）类别中列出的WhiteSpace码点识别为空白。 注意： 除了表32中列出的码点之外，ECMAScript WhiteSpace有意排除了所有具有Unicode的“空白分隔符”属性但未归类为“ Space_Separator”（“ Zs”）类别的码点。 语法 WhiteSpace:: 11.3 行终止符 像空白字符一样，行终止字符用于改善源文本的可读性和分割 Token（不可分割的词法单位）。然而，不像空白字符，行终止符对句法的行为有一定的影响。一般情况下，行终止符可以出现在任何两个 Token 之间，但也有少数地方，句法禁止这样做。行终止符也影响自动插入分号的过程（11.9）。行终止符不能出现在 StringLiteral， 之外的任何 Token 内。\\和\\行终止符不能在StringLiteral的Token内出现，除非作为LineContinuation的一部分。 行终止符可以出现在 MultiLineComment 内，但不能出现在 SingleLineComment 内。 行终止符包含在\\ s类在正则表达式中匹配的空白码点集中。 表33中列出了ECMAScript行终止符码点。 Code Point Unicode 名称 Abbreviation U+000A 换行 (LF) \\ U+000D 回车 (CR) \\ U+2028 行分隔符 \\ U+2029 段落分隔符 \\ 仅将表33中的Unicode码点视为行终止符。如果其他新行或换行符Unicode码点满足表32中列出的要求，则不会将它们视为行终止符，而是将其视为空格。序列\\ \\通常用作行终止符。为了记录行号，应将其视为单个SourceCharacter。 语法 LineTerminator:: LineTerminatorSequence:: [lookahead ≠ ] 11.4 注释 注释可以是单行或多行。多行注释不能嵌套。 因为单行注释可以包含除了 LineTerminator 字符之外的任何字符，又因为有一般规则：一个 Token 总是尽可能匹配更长，所以一个单行注释总是包含从 // 到行终止符之间的所有字符。然而，在该行末尾的 LineTerminator 不被看成是单行注释的一部分，它被词法识别成句法输入元素流的一部分。这一点非常重要，因为这意味着是否存在单行注释都不影响自动分号插入进程（请参见11.9）。 像空白一样，注释会被句法简单丢弃，除了 MultiLineComment 包含行终止符字符的情况，这种情况下整个注释会当作一个 LineTerminator 提供给句法文法解析。 语法： Comment:: MultiLineComment SingleLineComment MultiLineComment:: /*MultiLineCommentCharsopt*/ MultiLineCommentChars:: MultiLineNotAsteriskCharMultiLineCommentCharsopt *PostAsteriskCommentCharsopt PostAsteriskCommentChars:: MultiLineNotForwardSlashOrAsteriskCharMultiLineCommentCharsopt *PostAsteriskCommentCharsopt MultiLineNotAsteriskChar:: SourceCharacterbut not * MultiLineNotForwardSlashOrAsteriskChar:: SourceCharacterbut not one of / or * SingleLineComment:: //SingleLineCommentCharsopt SingleLineCommentChars:: SingleLineCommentCharSingleLineCommentCharsopt SingleLineCommentChar:: SourceCharacterbut not LineTerminator 11.5 Token 语法 CommonToken:: IdentifierName Punctuator NumericLiteral StringLiteral Template 注意 DivPunctuator，RegularExpressionLiteral，RightBracePunctuator和TemplateSubstitutionTail产生式得出额外的 Token，不包含CommonToken产生式。 11.6 名称和关键字 IdentifierName和ReservedWord是根据Unicode标准附件＃31，标识符和模式语法中给出的默认标识符语法进行了解释，并进行了一些小的修改的token。ReservedWord是IdentifierName的枚举子集。句法将标识符定义为不是保留字的IdentifierName。Unicode标识符语法基于Unicode标准指定的字符属性。所有符合标准的ECMAScript实现都必须将Unicode标准最新版本中指定类别中的Unicode码点视为这些类别中的Unicode码点。ECMAScript实现可以识别在Unicode标准的更高版本中定义的标识符码点。 注1 该标准指定了特定的码点添加：在IdentifierName中的任何位置都允许使用U+0024（美元符号）和U+005F（下划线），以及码点U+200C（零宽不连字）和U+200D（零宽连字符）允许在IdentifierName的第一个码点之后的任何位置。 IdentifierName中允许使用Unicode转义序列，在该序列中，它们向IdentifierName提供单个Unicode码点。该码点由UnicodeEscapeSequence的CodePoint表示（请参见11.8.4）。UnicodeEscapeSequence之前的\\和u和{}码元（如果出现）不会为IdentifierName提供码点。不能使用UnicodeEscapeSequence将码点放入否则可能是非法的IdentifierName中。换句话说，如果\\ UnicodeEscapeSequence序列被其提供的SourceCharacter替换，则结果必须仍然是有效的IdentifierName，其SourceCharacter元素的序列与原始IdentifierName完全相同。本规范中对IdentifierName的所有解释均基于其实际码点，无论是否使用转义序列来提供任何特定码点。 除非按照每个UnicodeEscapeSequence替换后，它们由完全相同的码点序列表示，否则根据Unicode标准，在规范上等效的两个IdentifierName互不相等。 语法 IdentifierName:: IdentifierStart IdentifierNameIdentifierPart IdentifierStart:: UnicodeIDStart $ _ \\UnicodeEscapeSequence IdentifierPart:: UnicodeIDContinue $ _ \\UnicodeEscapeSequence UnicodeIDStart:: any Unicode code point with the Unicode property “ID_Start” UnicodeIDContinue:: any Unicode code point with the Unicode property “ID_Continue” 非终结UnicodeEscapeSequence的定义在11.8.4中给出。 注2： 非终结符IdentifierPart通过UnicodeIDContinue派生\"_\"。 注3： 具有Unicode属性“ ID_Start”和“ ID_Continue”的码点集分别包括具有Unicode属性“ Other_ID_Start”和“ Other_ID_Continue”的码点。 11.6.1 标识符名称 11.6.1.1 静态语义：Early Errors IdentifierStart::UnicodeEscapeSequence 如果SV（Unicode转义序列）不为“ $”或“ _”或与UnicodeIDStart词法生成匹配的码点的UTF16Encoding，则为语法错误。 IdentifierPart::UnicodeEscapeSequence 如果SV（Unicode转义序列）都不是“ $”或“ _”，或者是\\或\\的UTF16Encoding，或者是与UnicodeIDContinue词法产生式匹配的Unicode码点的UTF16Encoding，则这是语法错误。 11.6.1.2 静态语义：StringValue ​ IdentifierName:: ​ IdentifierStart ​ IdentifierNameIdentifierPart 返回由对应于IdentifierName的码元序列组成的String值。在确定序列时，首先用UnicodeEscapeSequence表示的码点替换\\ UnicodeEscapeSequence的出现，然后通过UTF16Encoding每个码点将整个IdentifierName的码点转换为码元。 11.6.2 保留关键字 保留字是不能用作标识符的IdentifierName。 语法 ReservedWord :: Keyword FutureReservedWord NullLiteral BooleanLiteral 注意 ReservedWord定义被指定为特定SourceCharacter元素的文字序列。保留字中的码点不能用\\ UnicodeEscapeSequence表示。 11.6.2.1 关键字 以下标记是ECMAScript关键字，不能在ECMAScript程序中用作标识符。 语法 Keyword :: one of await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield 注 在某些情况下，yield和await被赋予标识符的语义。见12.1.1。在严格模式代码中，let和static通过静态语义限制（请参见12.1.1、13.3.1.1、13.7.5.1和14.6.1）而不是词法语法被视为保留字。 11.6.2.2 未来保留关键字 保留以下标记，以在将来的语言扩展中用作关键字。 语法 FutureReservedWord :: enum 注 还保留在严格模式代码内使用以下标记。使用静态语义限制（请参见12.1.1）而不是词法来限制使用： implements package protected interface private public 11.7 标点符号 语法 Punctuator :: one of { ( ) [ ] . ... ; , = == != === !== + - * % ** ++ -- > >>> & | ^ ! ~ && || ? : = += -= *= %= **= >= >>>= &= |= ^= => DivPunctuator :: / /= RightBracePunctuator :: } 11.8 字面量 11.8.1 空字面量 语法 NullLiteral :: null 11.8.2 布尔字面量 语法 BooleanLiteral :: true false 11.8.3 数字字面量 语法 NumericLiteral :: DecimalLiteral BinaryIntegerLiteral OctalIntegerLiteral HexIntegerLiteral DecimalLiteral :: DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt . DecimalDigits ExponentPartopt DecimalIntegerLiteral ExponentPartopt DecimalIntegerLiteral :: 0 NonZeroDigit DecimalDigitsopt DecimalDigits :: DecimalDigit DecimalDigits DecimalDigit DecimalDigit :: one of 0 1 2 3 4 5 6 7 8 9 NonZeroDigit :: one of 1 2 3 4 5 6 7 8 9 ExponentPart :: ExponentIndicator SignedInteger ExponentIndicator :: one of e E SignedInteger :: DecimalDigits + DecimalDigits - DecimalDigits BinaryIntegerLiteral :: 0b BinaryDigits 0B BinaryDigits BinaryDigits :: BinaryDigit BinaryDigits BinaryDigit BinaryDigit :: one of 0 1 OctalIntegerLiteral :: 0o OctalDigits 0O OctalDigits OctalDigits :: OctalDigit OctalDigits OctalDigit OctalDigit :: one of 0 1 2 3 4 5 6 7 HexIntegerLiteral :: 0x HexDigits 0X HexDigits HexDigits :: HexDigit HexDigits HexDigit HexDigit :: one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F 紧跟在NumericLiteral之后的SourceCharacter一定不能是IdentifierStart或DecimalDigit。 如B.1.1所述，在处理严格模式代码时，符合规范的实现不得扩展NumericLiteral的语法以包括LegacyOctalIntegerLiteral，也不得扩展DecimalIntegerLiteral的语法以包括NonOctalDecimalIntegerLiteral。 11.8.3.1 静态语义：MV 数字文字代表Number类型的值。该值分两个步骤确定：首先，从文字中得出数学值（MV）；第二，从公式中得出数学值。其次，该数学值按以下说明四舍五入。 NumericLiteral :: DecimalLiteral 的数学值是 DecimalLiteral 的数学值。 NumericLiteral :: BinaryIntegerLiteral 的数学值是 BinaryIntegerLiteral 的数学值。 NumericLiteral :: OctalIntegerLiteral 的数学值是 OctalIntegerLiteral 的数学值。 NumericLiteral :: HexIntegerLiteral 的数学值是 HexIntegerLiteral 的数学值。 DecimalLiteral :: DecimalIntegerLiteral . 的数学值是 DecimalIntegerLiteral 的数学值。 DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits 的数学值是 DecimalIntegerLiteral 的数学值加上 (DecimalDigits 的数学值乘 10^-n), 这里的 n 是 DecimalDigits 的字符个数。 DecimalLiteral :: DecimalIntegerLiteral . ExponentPart 的数学值是 DecimalIntegerLiteral 的数学值乘 10^e, 这里的 e 是 ExponentPart 的数学值。 DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits ExponentPart 的数学值是 (DecimalIntegerLiteral 的数学值加 (DecimalDigits 的数学值乘 10^-n)) 乘 10e, 这里的 n 是 DecimalDigits 的字符个数，e 是 ExponentPart 的数学值。 DecimalLiteral :: . DecimalDigits 的数学值是 DecimalDigits 的数学值乘 10-n, 这里的 n 是 DecimalDigits 的字符个数。 DecimalLiteral :: . DecimalDigits ExponentPart 的数学值是 DecimalDigits 的数学值乘 10e-n, 这里的 n 是 DecimalDigits 的字符个数，e 是 ExponentPart 的数学值。 DecimalLiteral :: DecimalIntegerLiteral 的数学值是 DecimalIntegerLiteral 的数学值。 DecimalLiteral :: DecimalIntegerLiteral ExponentPart 的数学值是 DecimalIntegerLiteral 的数学值乘 10^e, 这里的 e 是 ExponentPart 的数学值。 DecimalIntegerLiteral :: 0 的数学值是 0。 DecimalLiteral :: NonZeroDigit 的数学值是 NonZeroDigit 的数学值。 DecimalIntegerLiteral :: NonZeroDigit DecimalDigits 的数学值是 (NonZeroDigit 的数学值乘 10n) 加 DecimalDigits 的数学值, 这里的 n 是 DecimalDigits 的字符个数。 DecimalDigits :: DecimalDigit 的数学值是 DecimalDigit 的数学值。 DecimalDigits :: DecimalDigits DecimalDigit 的数学值是 (DecimalDigits 的数学值乘 10) 加 DecimalDigit 的数学值。 ExponentPart :: ExponentIndicator SignedInteger 的数学值是 SignedInteger 的数学值。 SignedInteger :: DecimalDigits 的数学值是 DecimalDigits 的数学值。 SignedInteger :: + DecimalDigits 的数学值是 DecimalDigits 的数学值。 SignedInteger :: - DecimalDigits 的数学值是 DecimalDigits 的数学值取负。 DecimalDigit :: 0 或 HexDigit :: 0 的数学值是 0。 DecimalDigit :: 1 或 NonZeroDigit :: 1 或 HexDigit :: 1 的数学值是 1。 DecimalDigit :: 2 或 NonZeroDigit :: 2 或 HexDigit :: 2 的数学值是 2。 DecimalDigit :: 3 或 NonZeroDigit :: 3 或 HexDigit :: 3 的数学值是 3。 DecimalDigit :: 4 或 NonZeroDigit :: 4 或 HexDigit :: 4 的数学值是 4。 DecimalDigit :: 5 或 NonZeroDigit :: 5 或 HexDigit :: 5 的数学值是 5。 DecimalDigit :: 6 或 NonZeroDigit :: 6 或 HexDigit :: 6 的数学值是 6。 DecimalDigit :: 7 或 NonZeroDigit :: 7 或 HexDigit :: 7 的数学值是 7。 DecimalDigit :: 8 或 NonZeroDigit :: 8 或 HexDigit :: 8 的数学值是 8。 DecimalDigit :: 9 或 NonZeroDigit :: 9 或 HexDigit :: 9 的数学值是 9。 HexDigit :: a 或 HexDigit :: A 的数学值是 10。 HexDigit :: b 或 HexDigit :: B 的数学值是 11。 HexDigit :: c 或 HexDigit :: C 的数学值是 12。 HexDigit :: d 或 HexDigit :: D 的数学值是 13。 HexDigit :: e 或 HexDigit :: E 的数学值是 14。 HexDigit :: f 或 HexDigit :: F 的数学值是 15。 BinaryIntegerLiteral::0bBinaryDigits 的数学值是 BinaryDigits 的数学值 BinaryIntegerLiteral::0BBinaryDigits 的数学值是 BinaryDigits 的数学值 BinaryDigits::BinaryDigit 的数学值是 BinaryDigit 的数学值 BinaryDigits::BinaryDigitsBinaryDigit 的数学值是 (BinaryDigits × 2的值) 乘以 BinaryDigit 的数学值 OctalIntegerLiteral::0oOctalDigits 的数学值是 OctalDigits 的数学值 OctalIntegerLiteral::0OOctalDigits 的数学值是 OctalDigits 的数学值 OctalDigits::OctalDigit 的数学值是 OctalDigit 的数学值 OctalDigits::OctalDigitsOctalDigit 的数学值是 (OctalDigits × 8的值) 乘以 OctalDigit 的数学值 HexIntegerLiteral::0xHexDigits 的数学值是 HexDigits 的数学值 HexIntegerLiteral::0XHexDigits 的数学值是 HexDigits 的数学值 HexDigits::HexDigit 的数学值是 HexDigit 的数学值 HexDigits::HexDigitsHexDigit 的数学值 (HexDigits × 16的值) 乘以 HexDigit 的数学值. 一旦确定了数字文字的确切MV，则将其舍入为Number类型的值。如果MV为0，则舍入值为+0；否则，四舍五入的值必须是MV的Number值（如6.1.6中所指定），除非文字是DecimalLiteral并且文字具有20个以上的有效数字，在这种情况下Number值可以是Number值通过将20号之后的每个有效数字替换为0位而产生的文字的MV或通过将20号之后的每个有效数字替换为0位然后在20号增加该文字而产生的文字的MV的Number值有效数字位。如果数字不是ExpnentPart的一部分，则该数字是有效的；并且 ​ 不为0；或左侧有一个非零数字，右侧有一个非零数字（不在ExponentPart中）。 11.8.4 字符串字面量 注：字符串文字是用单引号或双引号引起来的零个或多个Unicode码点。Unicode码点也可以由转义序列表示。除了结束引号码点U+005C（反斜杠），U+000D（回车）和U+000A（换行）外，所有码点都可能以字符串文字形式出现。任何码点都可能以转义序列的形式出现。字符串文字的计算结果为ECMAScript字符串值。生成这些字符串值时，Unicode码点按照10.1.1中的定义进行UTF-16编码。属于基本多语言平面的码点被编码为字符串的单个码元元素。所有其他码点均编码为字符串的两个码元元素。 语法 StringLiteral:: \"DoubleStringCharactersopt\" 'SingleStringCharactersopt' DoubleStringCharacters:: DoubleStringCharacterDoubleStringCharactersopt SingleStringCharacters:: SingleStringCharacterSingleStringCharactersopt DoubleStringCharacter:: SourceCharacterbut not one of \" or \\ or LineTerminator \\EscapeSequence LineContinuation SingleStringCharacter:: SourceCharacterbut not one of ' or \\ or LineTerminator \\EscapeSequence LineContinuation LineContinuation:: \\LineTerminatorSequence EscapeSequence:: CharacterEscapeSequence 0[lookahead ∉ DecimalDigit] HexEscapeSequence UnicodeEscapeSequence 在处理严格模式代码时，符合标准的实现不得将EscapeSequence的语法扩展为包括B.1.2中所述的LegacyOctalEscapeSequence。 CharacterEscapeSequence:: SingleEscapeCharacter NonEscapeCharacter SingleEscapeCharacter::one of '\"\\bfnrtv NonEscapeCharacter:: SourceCharacterbut not one of EscapeCharacter or LineTerminator EscapeCharacter:: SingleEscapeCharacter DecimalDigit x u HexEscapeSequence:: xHexDigitHexDigit UnicodeEscapeSequence:: uHex4Digits u{HexDigits} Hex4Digits:: HexDigitHexDigitHexDigitHexDigit 非终结符HexDigit的定义在11.8.3中给出。SourceCharacter在10.1中定义。 注 2 \\和\\不能出现在字符串文字中，除非作为LineContinuation的一部分来产生空码点序列。包含在字符串文字的String值中的正确方法是使用转义序列，例如\\n或\\u000A。 11.8.4.1 静态语义：StringValue StringLiteral :: \" DoubleStringCharactersopt \" ' SingleStringCharactersopt ' 返回String值，其代码单位是此StringLiteral的静态语义。 11.8.4.2 静态语义：SV 字符串文字代表String类型的值。文字的字符串值（SV）是根据字符串文字的各个部分贡献的码元来描述的。作为此过程的一部分，字符串文字中的某些Unicode码点被解释为具有数学值（MV），如下所述或11.8.3中所述。 StringLiteral :: \"\" 的SV是空码元序列。 StringLiteral :: ''的SV是空码元序列。 StringLiteral :: \"DoubleStringCharacters\"的SV是DoubleStringCharacters的SV。 StringLiteral :: 'SingleStringCharacters'的SV是SingleStringCharacters的SV。 DoubleStringCharacters :: DoubleStringCharacter（最多两个码元的序列）的SV是DoubleStringCharacter的SV。 DoubleStringCharacters :: DoubleStringCharacter的SV DoubleStringCharacters是由最多两个码元组成的序列，该序列是DoubleStringCharacter的SV，按照 DoubleStringCharacters SV的码元顺序排列。 SingleStringCharacters :: SingleStringCharacter（最多两个码元的序列）的SV是SingleStringCharacter的SV SingleStringCharacters :: SingleStringCharacter的SV SingleStringCharacter是由最多两个码元组成的序列，该序列是SingleStringCharacter的SV，按照 SingleStringCharacter SV的码元顺序排列。 DoubleStringCharacter :: SourceCharacter的SV是SourceCharacter的码点值的UTF16Encoding，而不是 “ 或 \\ 或LineTerminator之一。 DoubleStringCharacter :: \\ 的SV是码元 0x2028 (行分隔符)) DoubleStringCharacter :: \\ 的SV是码元 0x2029 (段落分隔符) DoubleStringCharacter :: \\ EscapeSequence 的SV是EscapeSequence的SV DoubleStringCharacter :: LineContinuation 的SV是空的码元序列 SingleStringCharacter :: SourceCharacter 不是 ' 或 \\ 或 LineTerminator 的SV是SourceCharacter的UTF16Encoding码点值 SingleStringCharacter :: \\ 的SV是码元 0x2028 (行分隔符) SingleStringCharacter :: \\ 的SV是码元 0x2029 (段落分隔符) SingleStringCharacter :: \\ EscapeSequence 的SV是EscapeSequence的SV SingleStringCharacter :: LineContinuation的SV是空的码元序列 EscapeSequence :: CharacterEscapeSequence的SV是 CharacterEscapeSequence的SV EscapeSequence :: 0 的SV是码元 0x0000 (NULL)。 EscapeSequence :: HexEscapeSequence的SV是 HexEscapeSequence 的SV EscapeSequence :: UnicodeEscapeSequence的SV是 UnicodeEscapeSequence的SV CharacterEscapeSequence :: SingleEscapeCharacter 的SV是由SingleEscapeCharacter根据表34确定的码元 转义序列 代码单元值 Unicode 编码名称 符号 \\b 0x0008 退格符 \\ \\t 0x0009 水平制表符 \\ \\n 0x000A 换行符 \\ \\v 0x000B 垂直制表符 \\ \\f 0x000C 换页符 \\ \\r 0x000D 回车符 \\ \\\" 0x0022 双引号 \" \\' 0x0027 单引号 ' \\\\ 0x005C 反斜杠 \\ CharacterEscapeSequence :: NonEscapeCharacter 的SV是 NonEscapeCharacter 的SV NonEscapeCharacter :: SourceCharacterbut 不是 EscapeCharacter 或 LineTerminator的SV是SourceCharacter的码点值的UTF16Encoding。 HexEscapeSequence :: x HexDigitHexDigit 的码元值，是第一个HexDigit的MV的16倍加上第二个HexDigit的MV的SV UnicodeEscapeSequence :: u Hex4Digits 的SV是 Hex4Digits 的SV Hex4Digits :: HexDigitHexDigitHexDigitHexDigit 是码元值（第一个HexDigit的MV的4096倍）加上（第二个HexDigit的MV的256倍）加上（第三个HexDigit的MV的16倍）加上第四个HexDigit的MV的SV UnicodeEscapeSequence :: u{ CodePoint } 的SV是UTF16Encoding码点的MV 11.8.5 正则表达式字面量 注：正则表达式文字是一个输入元素，每次对文字进行求值时都会将其转换为RegExp对象（请参见21.2）。程序中的两个正则表达式文字求和为正则表达式对象，即使这两个文字的内容相同，它们也永远不会相互比较===。还可以在运行时通过新的RegExp或将RegExp构造函数作为函数调用来创建RegExp对象（请参见21.2.3）。 下面的生成描述了正则表达式文字的语法，并被输入元素扫描程序用来查找正则表达式文字的结尾。随后，使用更严格的ECMAScript正则表达式语法（21.2.1）再次解析包含RegularExpressionBody和RegularExpressionFlags的源文本。 一个实现可以扩展在21.2.1中定义的ECMAScript正则表达式语法，但不能扩展下面定义的RegularExpressionBody和RegularExpressionFlags生产或这些生产使用的生产。 语法 RegularExpressionLiteral:: /RegularExpressionBody/RegularExpressionFlags RegularExpressionBody:: RegularExpressionFirstCharRegularExpressionChars RegularExpressionChars:: [empty] RegularExpressionCharsRegularExpressionChar RegularExpressionFirstChar:: RegularExpressionNonTerminatorbut not one of * or \\ or / or [ RegularExpressionBackslashSequence RegularExpressionClass RegularExpressionChar:: RegularExpressionNonTerminatorbut not one of \\ or / or [ RegularExpressionBackslashSequence RegularExpressionClass RegularExpressionBackslashSequence:: \\RegularExpressionNonTerminator RegularExpressionNonTerminator:: SourceCharacterbut not LineTerminator RegularExpressionClass:: [RegularExpressionClassChars] RegularExpressionClassChars:: [empty] RegularExpressionClassCharsRegularExpressionClassChar RegularExpressionClassChar:: RegularExpressionNonTerminatorbut not one of ] or \\ RegularExpressionBackslashSequence RegularExpressionFlags:: [empty] RegularExpressionFlagsIdentifierPart 注 2 正则表达式文字不能为空；码元序列//而不是表示空的正则表达式文字，而是开始单行注释。要指定一个空的正则表达式，请使用：/（？：）/。 11.8.5.1 静态语义：Early Errors RegularExpressionFlags :: RegularExpressionFlags IdentifierPart ​ 如果IdentifierPart包含Unicode转义序列，则是语法错误。 11.8.5.2 静态语义：BodyText RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags ​ 1. 返回被识别为RegularExpressionBody的源文本 11.8.5.3 静态语义：FlagText RegularExpressionLiteral :: / RegularExpressionBody / RegularExpressionFlags ​ 1.返回被识别为RegularExpressionFlags的源文本。 11.8.6 模板字面量文字组件 语法 Template:: NoSubstitutionTemplate TemplateHead NoSubstitutionTemplate:: `TemplateCharactersopt` TemplateHead:: `TemplateCharactersopt${ TemplateSubstitutionTail:: TemplateMiddle TemplateTail TemplateMiddle:: }TemplateCharactersopt${ TemplateTail:: }TemplateCharactersopt` TemplateCharacters:: TemplateCharacterTemplateCharactersopt TemplateCharacter:: $[lookahead ≠ {] \\EscapeSequence LineContinuation LineTerminatorSequence SourceCharacterbut not one of ` or \\ or $ or LineTerminator NotEscapeSequence :: 0 DecimalDigit DecimalDigit but not 0 x [lookahead ∉ HexDigit] x HexDigit [lookahead ∉ HexDigit] u [lookahead ∉ HexDigit] [lookahead ≠ {] u HexDigit [lookahead ∉ HexDigit] u HexDigit HexDigit [lookahead ∉ HexDigit] u HexDigit HexDigit HexDigit [lookahead ∉ HexDigit] u { [lookahead ∉ HexDigit] u { NotCodePoint [lookahead ∉ HexDigit] u { CodePoint [lookahead ∉ HexDigit] [lookahead ≠ }] NotCodePoint :: HexDigits but only if MV of HexDigits > 0x10FFFF CodePoint :: HexDigits but only if MV of HexDigits ≤ 0x10FFFF 符合规范的实现在解析TemplateCharacter时不得使用B.1.2中描述的EscapeSequence的扩展定义。 注 InputSubTemplateTail替代词法目标使用TemplateSubstitutionTail。 11.8.6.1 静态语义：TV and TRV 模板文字组件被解释为Unicode码点的序列。文字组件的模板值（TV）用由模板文字组件的各个部分贡献的代码单位值（SV，11.8.4）描述。作为此过程的一部分，模板组件中的某些Unicode码点被解释为具有数学值（MV，11.8.3）。在确定电视时，将转义序列替换为由转义序列表示的Unicode码点的UTF-16码元。模板原始值（TRV）与模板值类似，不同之处在于TRV中的转义序列按字面意义进行解释。 NoSubstitutionTemplate :: `` 的TV和TRV是空的码元序列. TemplateHead :: `${ 的TV和TRV是空的码元序列. TemplateMiddle :: }${ 的TV和TRV是空的码元序列. TemplateTail :: }` 的TV和TRV是空的码元序列. NoSubstitutionTemplate :: `TemplateCharacters`的TV是TemplateCharacters的TV. TemplateHead :: `TemplateCharacters ${ 的TV是TemplateCharacters的TV. TemplateMiddle :: }TemplateCharacters ${的TV是TemplateCharacters的TV. TemplateTail :: } TemplateCharacters `的TV是TemplateCharacters的TV. TemplateCharacters :: TemplateCharacter的TV是TemplateCharacter的TV. 如果TemplateCharacter的TV是undefined或TemplateCharacters是undefined，则TemplateCharacters :: TemplateCharacter TemplateCharacters 的TV是undefined，否则这是一个按照TemplateCharacters的TV的码元组成的TemplateCharacter的TV码元序列 TemplateCharacter :: SourceCharacterbut 的TV是SourceCharacter的码点值的UTF16Encoding，而不是 ` 或 \\ 或 $ 或 LineTerminator. TemplateCharacter :: $ 的TV是码元值0x0024（$）. TemplateCharacter :: \\ EscapeSequence的TV是EscapeSequence的SV TemplateCharacter :: \\ NotEscapeSequence 的TV是undefined. TemplateCharacter :: LineContinuation的TV是LineContinuation的TV. TemplateCharacter :: LineTerminatorSequence的TV是LineTerminatorSequence的TRV. LineContinuation :: \\LineTerminatorSequence的TV是空的码元序列. NoSubstitutionTemplate :: `TemplateCharacters`的TRV是TemplateCharacters的TRV. TemplateHead :: ` TemplateCharacters ${的TRV是TemplateCharacters的TRV. TemplateMiddle :: } TemplateCharacters ${的TRV是TemplateCharacters的TRV. TemplateTail :: } TemplateCharacters `的TRV是TemplateCharacters的TRV. TemplateCharacters :: TemplateCharacter的TRV是TemplateCharacter的TRV. TemplateCharacters :: TemplateCharacter TemplateCharacters 的TRV是一个按照TemplateCharacters的TRV的码元组成的TemplateCharacter的TRV码元序列 TemplateCharacter :: SourceCharacterbut 的TRV是SourceCharacter的码点值的UTF16Encoding，而不是 ` 或 \\ 或 $ 或 LineTerminator. ` or \\ or $ or LineTerminator的TRV of TemplateCharacter :: SourceCharacterbut not one是the UTF16Encoding of the code point value of SourceCharacter. TemplateCharacter :: $ 的TRV是码元值0x0024（$） TemplateCharacter :: \\EscapeSequence的TRV是the sequence consisting of the code unit value 0x005C followed by the code units of TRV of EscapeSequence. TemplateCharacter :: LineContinuation的TRV是TRV of LineContinuation. TemplateCharacter :: LineTerminatorSequence的TRV是LineTerminatorSequence的TRV. EscapeSequence :: CharacterEscapeSequence的TRV是TRV of the CharacterEscapeSequence. EscapeSequence :: 0的TRV是the code unit value 0x0030 (DIGIT ZERO). EscapeSequence :: HexEscapeSequence的TRV是TRV of the HexEscapeSequence. EscapeSequence :: UnicodeEscapeSequence的TRV是TRV of the UnicodeEscapeSequence. CharacterEscapeSequence :: SingleEscapeCharacter的TRV是TRV of the SingleEscapeCharacter. CharacterEscapeSequence :: NonEscapeCharacter的TRV是the NonEscapeCharacter的静态语义 SingleEscapeCharacter :: one of'\"\\bfnrtv的TRV是the SourceCharacter that的静态语义是that single code point. HexEscapeSequence :: xHexDigitHexDigit的TRV是the sequence consisting of code unit value 0x0078 followed by TRV of the first HexDigit followed by TRV of the second HexDigit. UnicodeEscapeSequence :: uHex4Digits的TRV是the sequence consisting of code unit value 0x0075 followed by TRV of Hex4Digits. UnicodeEscapeSequence :: u{HexDigits}的TRV是the sequence consisting of code unit value 0x0075 followed by code unit value 0x007B followed by TRV of HexDigits followed by code unit value 0x007D. Hex4Digits :: HexDigitHexDigitHexDigitHexDigit的TRV是the sequence consisting of TRV of the first HexDigit followed by TRV of the second HexDigit followed by TRV of the third HexDigit followed by TRV of the fourth HexDigit. HexDigits :: HexDigit的TRV是TRV of HexDigit. HexDigits :: HexDigitsHexDigit的TRV是the sequence consisting of TRV of HexDigits followed by TRV of HexDigit. a HexDigit的TRV是the SourceCharacter that的静态语义是that HexDigit. LineContinuation :: \\LineTerminatorSequence的TRV是the sequence consisting of the code unit value 0x005C followed by the code units of TRV of LineTerminatorSequence. LineTerminatorSequence :: \\的TRV是the code unit value 0x000A. LineTerminatorSequence :: \\的TRV是the code unit value 0x000A. LineTerminatorSequence :: \\的TRV是the code unit value 0x2028. LineTerminatorSequence :: \\的TRV是the code unit value 0x2029. LineTerminatorSequence :: \\\\的TRV是the sequence consisting of the code unit value 0x000A. 11.9 自动分号插入 大多数ECMAScript语句和声明必须以分号终止。这样的分号可能总是显式地出现在源文本中。但是，为方便起见，在某些情况下可以从源文本中省略此类分号。通过说在这些情况下将分号自动插入到源代码令牌流中来描述这些情况。 11.9.1 自动分号插入规则 在以下规则中，“令牌”是指使用第11条中所述的当前词法目标符号确定的实际公认词法令牌。 分号插入有三个基本规则： 当源文本从左到右进行解析时，遇到语法产生的任何形式都不允许的标记（称为冒犯标记）时，如果一个或多个冒号包含一个分号，则会自动在该冒犯标记之前插入分号。满足以下条件： 至少一个LineTerminator将违规token与先前的token分开。 违规token是}。 之前的令牌是)，然后插入的分号将被解析为do-while语句的终止分号（13.7.2）。 当源文本从左到右进行解析时，遇到令牌输入流的末尾，并且解析器无法将输入令牌流解析为目标非终结符的单个实例，则分号会自动插入输入流的末尾。 当按照从左到右的顺序解析源文本时，遇到某种语法产生所允许的标记，但是产生是受限产生，并且该标记将成为紧随该标记之后的终端或非终端的第一个标记受限生产中的注释“ [此处没有LineTerminator]”（因此，此类令牌称为受限令牌），并且受限令牌与至少一个LineTerminator与前一个令牌分开，然后在受限之前自动插入分号令牌。 但是，上述规则还有一个额外的优先条件：如果分号随后将被解析为空语句，或者该分号成为for语句的标头中的两个分号之一，则永远不会自动插入分号。13.7.4）。 注 以下是语法中仅有的限定词： UpdateExpression[Yield]: LeftHandSideExpression[?Yield][no LineTerminator here]++ LeftHandSideExpression[?Yield][no LineTerminator here]-- ContinueStatement[Yield]: continue; continue[no LineTerminator here]LabelIdentifier[?Yield]; BreakStatement[Yield]: break; break[no LineTerminator here]LabelIdentifier[?Yield]; ReturnStatement[Yield]: return; return[no LineTerminator here]Expression[In, ?Yield]; ThrowStatement[Yield]: throw[no LineTerminator here]Expression[In, ?Yield]; ArrowFunction[In, Yield]: ArrowParameters[?Yield][no LineTerminator here]=>ConciseBody[?In] YieldExpression[In]: yield[no LineTerminator here]*AssignmentExpression[?In, Yield] yield[no LineTerminator here]AssignmentExpression[?In, Yield] 这些限制生产的实际效果如下： 当遇到一个++或 -- token时，解析器将其视为后缀操作符，并且至少有一个LineTerminator发生在前面的token和++或 --标记之间，则分号将自动插入到++或 -- token之前 当遇到continue，break，return，throw或yield 词条时，在下一个词条(token)之前遇到一个LineTerminator，则在continue，break，return，throw或yield令牌之后会自动插入分号。 由此给ECMAScript程序员带来的实用建议是： 后缀++或 -- 运算符应该出现在与其操作数相同的行上。 return或throw语句中的表达式或yield表达式中的AssignmentExpression应该在与return，throw或yield词条相同的行上开始。 break或continue语句中的LabelIdentifier应与break或continue标记位于同一行。 11.9.2 自动分号插入规则示例 The source { 1 2 } 3 即使使用自动分号插入规则，ECMAScript语法中也不是有效的句子。 相反，来源 { 1 2 } 3 也不是有效的ECMAScript句子，但是通过自动分号插入到以下变量中： { 1 ;2 ;} 3; 这是一个有效的ECMAScript句子。 The source for (a; b ) 不是一个有效的ECMAScript句子，并且不会被自动分号插入更改，因为for语句的标题需要分号。 自动分号插入不会在for语句的标题中插入两个分号中的一个。 The source return a + b 通过自动分号插入转换为以下内容： return; a + b; NOTE 1 表达式a + b不被视为返回语句返回的值，因为LineTerminator将其从token return中分离出来。 The source a = b ++c 通过自动分号插入转换为以下内容： a = b; ++c; NOTE 2 token ++不被视为应用于变量b的后缀运算符，因为LineTerminator发生在b和++之间。 The source if (a > b) else c = d 不是一个有效的ECMAScript句子，并且不会在else标记之前自动分号插入更改，即使在该点不会生成语法，因为自动插入的分号将被解析为空语句。 The source a = b + c (d + e).print() 不会通过自动分号插入进行转换，因为开始第二行的括号表达式可以解释为函数调用的参数列表： a = b + c(d + e).print() 在赋值语句必须以左括号开头的情况下，程序员在前一个语句的末尾提供一个明确的分号，而不是依靠自动分号插入是一个好主意。 首先将ECMAScript脚本或模块的源文本转换成一系列输入元素，这些输入元素是标记，行终止符，注释或空白。从左到右扫描源文本，重复使用尽可能长的码点序列作为下一个输入元素。 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,lexical-grammar"},"expressions.html":{"url":"expressions.html","title":"12 ECMAScript语言：表达式","keywords":"","body":"12 ECMAScript语言：表达式 12.1 标识符 语法 IdentifierReference[Yield, Await] : Identifier [~Yield] yield [~Await] await BindingIdentifier[Yield, Await] : Identifier yield await LabelIdentifier[Yield, Await] : Identifier [~Yield] yield [~Await] await Identifier : IdentifierName but not ReservedWord 注意 在语法中允许yield和await作为BindingIdentifier，并在下面的静态语义中禁止使用yield和await，以防止在一下情况下自动插入分号： 令 await 0; 12.1.1 静态语义：早期错误 BindingIdentifier:Identifier 如果与此生产式匹配的代码包含在严格模式代码中，并且Identifier的StringValue是“ arguments”或“ eval”，则是语法错误。 IdentifierReference : yield BindingIdentifier : yield LabelIdentifier : yield 如果与此生产式匹配的代码包含在严格模式代码中，则是语法错误。 IdentifierReference : await BindingIdentifier : await LabelIdentifier : await 如果句法的目标符号是“模块”，则为语法错误。 BindingIdentifier : yield 如果此生产式具有[Yield]参数，则是语法错误。 BindingIdentifier : await 如果此生产式具有[Await]参数，则是语法错误。 IdentifierReference : Identifier BindingIdentifier : Identifier LabelIdentifier : Identifier 如果此生产具有[Yield]参数，并且Identifier的StringValue为“ yield”，则为语法错误。 如果此生产具有[Await]参数，并且Identifier的StringValue为“ await”，则为语法错误。 Identifier : IdentifierName but not ReservedWord 如果此短语包含在严格模式代码中，并且IdentifierName的StringValue为：\"implements\", \"interface\", \"令\", \"package\", \"private\", \"protected\", \"public\", \"static\", 或 \"yield\"。 如果语法语法的目标符号为Module且IdentifierName的StringValue为“ await”，则为语法错误。 如果IdentifierName的StringValue与任何ReservedWord的StringValue相同的String值（除yield或await之外）均是语法错误。 注意： IdentifierName的StringValue规范化了IdentifierName中的所有Unicode转义序列，因此此类转义不能用于编写其码点序列与ReservedWord相同的Identifier 12.1.2 静态语义：绑定名称 BindingIdentifier : Identifier 返回一个新列表，其中包含标识符的StringValue。 BindingIdentifier : yield 返回一个包含“ yield”的新列表。 BindingIdentifier : await 返回一个包含“await”的新列表。 12.1.3 静态语义：AssignmentTargetType IdentifierReference : Identifier 如果此IdentifierReference包含在严格模式代码中，并且Identifier的StringValue是“ eval”或“ arguments”，则返回 strict。 返回 simple IdentifierReference : yield 返回 simple IdentifierReference : await 返回 simple 12.1.4 静态语义：StringValue IdentifierReference : yield BindingIdentifier : yield LabelIdentifier : yield 返回 \"yield\"。 IdentifierReference : await BindingIdentifier : await LabelIdentifier : await 返回 \"await\". Identifier : IdentifierName but not ReservedWord 返回IdentifierName的StringValue 12.1.5 运行时语义：BindingInitialization 具有参数 value和environment 注：为环境传递undefined，以指示应该使用PutValue操作来分配初始化值。某些非严格函数的var语句和形式参数列表就是这种情况（请参见9.2.15）。在这些情况下，在执行其初始值设定项之前会先挂起并预初始化词法绑定 BindingIdentifier : Identifier 假设name为Identifier的StringValue。 返回 ? InitializeBoundName(name, value, environment). BindingIdentifier : yield 返回 ? InitializeBoundName(\"yield\", value, environment). BindingIdentifier : await 返回 ? InitializeBoundName(\"await\", value, environment). 12.1.5.1 运行时语义：InitializeBoundName ( name, value, environment ) 断言: Type(name) 是字符串. 如果 enviroment 不是 undefined, 那么 令 env 为环境的EnvironmentRecord组件。 执行 env.InitializeBinding(name, value). 返回 NormalCompletion(undefined). 否则, 令 lhs 为 ResolveBinding(name). 返回 ? PutValue(lhs, value) 12.1.6 运行时语义：Evaluation IdentifierReference : Identifier 返回 ? ResolveBinding(StringValue of Identifier). IdentifierReference : yield 返回 ? ResolveBinding(\"yield\"). IdentifierReference : await 返回 ? ResolveBinding(\"await\"). 注 1： 执行IdentifierReference的结果始终是Reference类型的值。 注 2：在非严格代码中，关键字yield可以用作标识符。执行IdentifierReference可以解决yield的绑定，就好像它是一个Identifier一样。早期错误限制可确保仅执行非严格代码。 12.2 主要表达式 语法 PrimaryExpression[Yield, Await] : this IdentifierReference[?Yield, ?Await] Literal ArrayLiteral[?Yield, ?Await] ObjectLiteral[?Yield, ?Await] FunctionExpression ClassExpression[?Yield, ?Await] GeneratorExpression AsyncFunctionExpression AsyncGeneratorExpression RegularExpressionLiteral TemplateLiteral[?Yield, ?Await, ~Tagged] CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] : ( Expression[+In, ?Yield, ?Await] ) ( Expression[+In, ?Yield, ?Await] , ) ( ) ( ... BindingIdentifier[?Yield, ?Await] ) ( ... BindingPattern[?Yield, ?Await] ) ( Expression[+In, ?Yield, ?Await] , ... BindingIdentifier[?Yield, ?Await] ) ( Expression[+In, ?Yield, ?Await] , ... BindingPattern[?Yield, ?Await] ) 补充语法 处理生产实例时 PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 使用以下语法完善CoverParenthesizedExpressionAndArrowParameterList的解释： ParenthesizedExpression[Yield, Await] : ( Expression[+In, ?Yield, ?Await] ) 12.2.1 语义 12.2.1.1 静态语义：CoveredParenthesizedExpression CoverParenthesizedExpressionAndArrowParameterList : ( Expression ) 返回涵盖 CoverParenthesizedExpressionAndArrowParameterList 的 ParenthesizedExpression 12.2.1.2 静态语义：HasName PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 令 expr 为 CoverParenthesizedExpressionAndArrowParameterList 的 CoveredParenthesizedExpression。 若 expr 的 IsFunctionDefinition 是 false, 返回 false. 返回 expr 的 HasName. 12.2.1.3 静态语义：IsFunctionDefinition PrimaryExpression : this IdentifierReference Literal ArrayLiteral ObjectLiteral RegularExpressionLiteral TemplateLiteral 返回 false. PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 令 expr 为CoverParenthesizedExpressionAndArrowParameterList的CoveredParenthesizedExpression 返回expr的IsFunctionDefinition 12.2.1.4 静态语义：IsIdentifierRef PrimaryExpression : IdentifierReference 返回 true PrimaryExpression : this Literal ArrayLiteral ObjectLiteral FunctionExpression ClassExpression GeneratorExpression AsyncFunctionExpression AsyncGeneratorExpression RegularExpressionLiteral TemplateLiteral CoverParenthesizedExpressionAndArrowParameterList 返回 false. 12.2.1.5 静态语义：AssignmentTargetType PrimaryExpression : this Literal ArrayLiteral ObjectLiteral FunctionExpression ClassExpression GeneratorExpression AsyncFunctionExpression AsyncGeneratorExpression RegularExpressionLiteral TemplateLiteral 返回 invalid. PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 令 expr 为CoverParenthesizedExpressionAndArrowParameterList的CoveredParenthesizedExpression 返回expr的AssignmentTargetType 12.2.2 this 关键字 12.2.2.1 运行时语义：Evaluation PrimaryExpression : this 返回 ? ResolveThisBinding(). 12.2.3 标识符引用 See 12.1 for IdentifierReference. 12.2.4 字面量 语法 Literal : NullLiteral BooleanLiteral NumericLiteral StringLiteral 12.2.4.1 运行时语义：Evaluation Literal : NullLiteral 返回 null. Literal : BooleanLiteral 若 BooleanLiteral 是 token false, 返回 false. 若 BooleanLiteral 是 token true, 返回 true. Literal : NumericLiteral 返回 NumericLiteral 的 MV（定义在11.8.3）值的数字 Literal : StringLiteral 返回StringLiteral（定义在11.8.4.1）的StringValue。 12.2.5 数组初始化 注：ArrayLiteral是一个表达式，它使用一个列表描述一个Array对象的初始化。它是一个零个或者多个表达式的序列，其中每一个表示一个数组元素，并且用方括号括起来。元素并不一定要是字面量，每次数组初始化执行时它们都会被执行一次。 数组元素可能在元素列表的开始、结束，或者中间位置以逗号取代。当元素列表中的一个逗号的前面没有 AssignmentExpression（如，一个逗号在另一个逗号之前。）的情况下，缺失的数组元素仍然会对数组长度有贡献，并且增加后续元素的索引值。以逗号省略的数组元素是 undefined。假如元素在数组末尾被省略，那么元素不会贡献数组长度。 语法 ArrayLiteral[Yield, Await] : [ Elisionopt ] [ ElementList[?Yield, ?Await] ] [ ElementList[?Yield, ?Await] , Elisionopt ] ElementList[Yield, Await] : Elisionopt AssignmentExpression[+In, ?Yield, ?Await] Elisionopt SpreadElement[?Yield, ?Await] ElementList[?Yield, ?Await] , Elisionopt AssignmentExpression[+In, ?Yield, ?Await] ElementList[?Yield, ?Await] , Elisionopt SpreadElement[?Yield, ?Await] Elision : , Elision , SpreadElement[Yield, Await] : ... AssignmentExpression[+In, ?Yield, ?Await] 12.2.5.1 静态语义：ElisionWidth Elision : , 返回数学值1. Elision : Elision , 令 preceding 为 Elision 的 ElisionWidth 返回 preceding + 1. 12.2.5.2 运行时语义：ArrayAccumulation 带有参数array和nextIndex。 ElementList : Elision AssignmentExpression 令 padding 为 Elision 的 ElisionWidth; 若 Elision 不存在, 使用数学值0. 令 initResult 为 执行 AssignmentExpression 的结果. 令 initValue 为 ? GetValue(initResult). 令 created 为 CreateDataProperty(array, ToString(ToUint32(nextIndex + padding)), initValue). 断言: created 是 true. 返回 nextIndex + padding + 1. ElementList : Elision SpreadElement 令 padding 为Elision的ElisionWidth; 若 Elision 不存在, 使用数学值0 返回对有 array 和 nextIndex + padding 的参数的 SpreadElement 执行 ArrayAccumulation 的结果。 ElementList : ElementList , Elision AssignmentExpression 令 postIndex 为对带有参数array和nextIndex的ElementList执行ArrayAccumulation的结果。 ReturnIfAbrupt(postIndex). 令 padding 为Elision的ElisionWidth; 若 Elision 不存在, 使用数学值0 令 initResult 为执行 AssignmentExpression 的结果. 令 initValue 为 ? GetValue(initResult). 令 created 为 CreateDataProperty(array, ToString(ToUint32(postIndex + padding)), initValue). 断言: created 是 true. 返回 postIndex + padding + 1. ElementList : ElementList , Elision SpreadElement 令 postIndex 为对带有参数array和nextIndex的ElementList执行ArrayAccumulation的结果。 ReturnIfAbrupt(postIndex). 令 padding 为Elision的ElisionWidth; 若 Elision 不存在, 使用数学值0 返回使用参数array和postIndex + padding对SpreadElement执行ArrayAccumulation的结果。 SpreadElement : ... AssignmentExpression 令 spreadRef 为执行AssignmentExpression的结果. 令 spreadObj 为 ? GetValue(spreadRef). 令 iteratorRecord 为 ? GetIterator(spreadObj). 重复, 令 next 为 ? IteratorStep(iteratorRecord). 若 next 是 false, 返回 nextIndex. 令 nextValue 为 ? IteratorValue(next). 令 status 为 CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue). 断言: status 是 true. nextIndex 加 1. 注：CreateDataProperty用于确保为数组定义了自己的属性，即使已修改标准内置Array原型对象的方式，也无法使用[[Set]]创建自己的新属性 12.2.5.3 运行时语义：Evaluation ArrayLiteral : [ Elision ] 令 array 为 ! ArrayCreate(0). 令 pad 为 Elision 的 ElisionWidth; 若 Elision 不存在, 使用数学值0 执行 Set(array, \"length\", ToUint32(pad), false). 注意: 由于ArrayCreate返回的对象的性质，上述Set不会失败 返回 array ArrayLiteral : [ ElementList ] 令 array 为 ! ArrayCreate(0). 令 len 为对带有参数array和0的ElementList执行ArrayAccumulation的结果。 ReturnIfAbrupt(len). 执行 Set(array, \"length\", ToUint32(len), false). 注意: 由于ArrayCreate返回的对象的性质，上述Set不会失败 返回 array. ArrayLiteral : [ ElementList , Elision ] 令 array 为 ! ArrayCreate(0). 令 len 为对带有参数array和0的ElementList执行ArrayAccumulation的结果。 ReturnIfAbrupt(len). 令 padding 为Elision的ElisionWidth; 若 Elision 不存在, 使用数学值0 执行 Set(array, \"length\", ToUint32(padding + len), false). 注意: 由于ArrayCreate返回的对象的性质，上述Set不会失败 返回 array. 12.2.6 对象初始化 注1：对象初始化程序是一种描述对象初始化的表达式，以类似于文字的形式编写。它是零对或更多对属性键和相关值的列表，并用大括号括起来。这些值不必是文字。每次执行对象初始值设定项时都对它们进行执行。 语法 ObjectLiteral[Yield, Await] : { } { PropertyDefinitionList[?Yield, ?Await] } { PropertyDefinitionList[?Yield, ?Await] , } PropertyDefinitionList[Yield, Await] : PropertyDefinition[?Yield, ?Await] PropertyDefinitionList[?Yield, ?Await] , PropertyDefinition[?Yield, ?Await] PropertyDefinition[Yield, Await] : IdentifierReference[?Yield, ?Await] CoverInitializedName[?Yield, ?Await] PropertyName[?Yield, ?Await] : AssignmentExpression[+In, ?Yield, ?Await] MethodDefinition[?Yield, ?Await] ... AssignmentExpression[+In, ?Yield, ?Await] PropertyName[Yield, Await] : LiteralPropertyName ComputedPropertyName[?Yield, ?Await] LiteralPropertyName : IdentifierName StringLiteral NumericLiteral ComputedPropertyName[Yield, Await] : [ AssignmentExpression[+In, ?Yield, ?Await] ] CoverInitializedName[Yield, Await] : IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await] Initializer[In, Yield, Await] : = AssignmentExpression[?In, ?Yield, ?Await] 注2：方法定义在14.3中定义。 注3：在某些情况下，ObjectLiteral用作覆盖语法，用于更严格的辅助语法。必须完全使用CoverInitializedName才能完全覆盖这些辅助语法。但是，在通常需要实际ObjectLiteral的正常情况下，使用这种产生方式会导致早期的语法错误。 12.2.6.1 静态语义：Early Errors PropertyDefinition : MethodDefinition 如果MethodDefinition的HasDirectSuper为true，则为语法错误。 除了描述实际的对象初始化程序之外，ObjectLiteral生成还用作ObjectAssignmentPattern的覆盖语法，并且可以识别为CoverParenthesizedExpressionAndArrowParameterList的一部分。当在要求ObjectAssignmentPattern的上下文中出现ObjectLiteral时，则不会应用以下早期错误规则。此外，在最初解析CoverParenthesizedExpressionAndArrowParameterList或CoverCallExpressionAndAsyncArrowHead时，不会应用它们。 PropertyDefinition : CoverInitializedName ​ 如果代码与此产生式匹配，则始终抛出语法错误。 注：存在这种产生式是为了使ObjectLiteral可以用作ObjectAssignmentPattern的覆盖语法。它不能在实际的对象初始化程序中发生。 12.2.6.2 静态语义：ComputedPropertyContains 带有参数符号。 PropertyName : LiteralPropertyName 返回 false. PropertyName : ComputedPropertyName 返回包含symbol的ComputedPropertyName结果。 12.2.6.3 静态语义：Contains 带有symbol符号。 PropertyDefinition : MethodDefinition 若 symbol 是 MethodDefinition, 返回 true. 返回带symbol参数的MethodDefinition的ComputedPropertyContains结果 注：依赖于子结构的静态语义规则通常不会考虑函数定义。 LiteralPropertyName : IdentifierName 若 symbol 是 ReservedWord, 返回 false. 若 symbol 是一个 Identifier 并且 symbol 的 StringValue 和 IdentifierName 的 StringValue 值相同, 返回 true. 返回 false. 12.2.6.4 静态语义：IsComputedPropertyKey PropertyName : LiteralPropertyName 返回 false. PropertyName : ComputedPropertyName 返回 true. 12.2.6.5 静态语义：PropName PropertyDefinition : IdentifierReference 返回IdentifierReference的StringValue PropertyDefinition : ... AssignmentExpression 返回 empty. PropertyDefinition : PropertyName : AssignmentExpression 返回PropertyName的PropName LiteralPropertyName : IdentifierName 返回IdentifierName的StringValue LiteralPropertyName : StringLiteral 返回字符串值，其码元是 StringLiteral 的SV。 LiteralPropertyName : NumericLiteral 令 nbr 为组成NumericLiteral的值的结果。 返回 ! ToString(nbr). ComputedPropertyName : [ AssignmentExpression ] 返回 empty 12.2.6.6 静态语义：PropertyNameList PropertyDefinitionList : PropertyDefinition 若 PropertyDefinition 的 PropName 是 empty, 返回一个新的空列表 返回 a new List containing PropName of PropertyDefinition. PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition 令 list 为PropertyDefinitionList的PropertyNameList 若 PropertyDefinition 的 PropName 是 empty, 返回 list. 将PropertyDefinition的PropName追加到列表的末尾。 返回 list 12.2.6.7 运行时语义：Evaluation ObjectLiteral : { } 返回 ObjectCreate(%ObjectPrototype%). ObjectLiteral : { PropertyDefinitionList } { PropertyDefinitionList , } 令 obj 为 ObjectCreate(%ObjectPrototype%). 执行 ? 带有参数 obj 和 true 的 PropertyDefinitionList 的 PropertyDefinitionEvaluation 返回 obj. LiteralPropertyName : IdentifierName 返回 IdentifierName 的 StringValue。 LiteralPropertyName : StringLiteral 返回 String值，其码元是StringLiteral的SV。 LiteralPropertyName : NumericLiteral 令 nbr 为形成NumericLiteral的值的结果。 返回 ! ToString(nbr). ComputedPropertyName : [ AssignmentExpression ] 令 exprValue 为AssignmentExpression的运算结果。 令 propName 为 ? GetValue(exprValue). 返回 ? ToPropertyKey(propName). 12.2.6.8 运行时语义：PropertyDefinitionEvaluation 带 object 和 enumerable 的参数。 PropertyDefinitionList : PropertyDefinitionList , PropertyDefinition 执行 ? 带有参数 object 和 enumerable 的 PropertyDefinitionList 的 PropertyDefinitionEvaluation. 返回用参数 object 和 enumerable 执行 PropertyDefinition 的 PropertyDefinitionEvaluation 的结果。 PropertyDefinition : ... AssignmentExpression 令 exprValue 为 AssignmentExpression 的运算结果. 令 fromValue 为 ? GetValue(exprValue). 令 excludedNames 为一个新的空列表 返回 ? CopyDataProperties(object, fromValue, excludedNames). PropertyDefinition : IdentifierReference 令 propName 为 IdentifierReference 的 StringValue 令 exprValue 为 IdentifierReference 的运算结果 令 propValue 为 ? GetValue(exprValue). 断言: enumerable 是 true. 断言: object 是一个没有不可配置属性的普通可扩展对象 返回 ! CreateDataPropertyOrThrow(object, propName, propValue). PropertyDefinition : PropertyName : AssignmentExpression 令 propKey 为PropertyName的运算结果 ReturnIfAbrupt(propKey). 若 IsAnonymousFunctionDefinition(AssignmentExpression) 是 true, 那么 令 propValue 为使用参数propKey为AssignmentExpression执行NamedEvaluation的结果。 否则, 令 exprValueRef 为AssignmentExpression的运算结果 令 propValue 为 ? GetValue(exprValueRef). 断言: enumerable 是 true. 断言: object 是一个没有不可配置属性的普通可扩展对象 返回 ! CreateDataPropertyOrThrow(object, propKey, propValue). 注：B.3.1中给出了这种生产的另一种语义。 12.2.7 函数定义表达式 有关PrimaryExpression：FunctionExpression，请参见14.1。 有关PrimaryExpression：GeneratorExpression，请参见14.4。 有关PrimaryExpression：ClassExpression，请参见14.6。 有关PrimaryExpression：AsyncFunctionExpression，请参见14.7。 有关PrimaryExpression：AsyncGeneratorExpression，请参见14.5。 12.2.8 正则表达式字面量 语法 参见 11.8.5 12.2.8.1 静态语义：Early Errors PrimaryExpression : RegularExpressionLiteral 如果无法使用21.2.1中指定的ECMAScript RegExp语法的目标符号模式识别RegularExpressionLiteral的BodyText，则会出现语法错误。 如果RegularExpressionLiteral的FlagText包含除“ g”，“ i”，“ m”，“ s”，“ u”或“ y”之外的任何代码点，或者包含的相同代码点多于一次，则是语法错误。 12.2.8.2 运行时语义：Evaluation PrimaryExpression : RegularExpressionLiteral 令 pattern 为 String值，它由RegularExpressionLiteral的BodyText的每个代码点的UTF16Encoding组成。 令 flags 为 String 值，该值由RegularExpressionLiteral的FlagText的每个代码点的UTF16Encoding组成。 返回 RegExpCreate(pattern, flags). 12.2.9 模板字面量 语法 TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate SubstitutionTemplate[?Yield, ?Await, ?Tagged] SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged] TemplateSpans[Yield, Await, Tagged] : TemplateTail TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail TemplateMiddleList[Yield, Await, Tagged] : TemplateMiddle Expression[+In, ?Yield, ?Await] TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await] 12.2.9.1 静态语义：Early Errors TemplateLiteral : NoSubstitutionTemplate 如果TemplateLiteral的TemplateStrings的结果中带有参数false的元素数大于2^32-1，则是语法错误。 如果未设置[Tagged]参数并且NoSubstitutionTemplate包含NotEscapeSequence，则为语法错误。 SubstitutionTemplate : TemplateHead Expression TemplateSpans ​ 如果未设置[Tagged]参数并且TemplateHead包含NotEscapeSequence，则为语法错误。 TemplateSpans : TemplateTail ​ 如果未设置[Tagged]参数并且TemplateTail包含NotEscapeSequence，则为语法错误。 TemplateMiddleList[Yield, Await, Tagged] : TemplateMiddle Expression[+In, ?Yield, ?Await] TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await] ​ 如果未设置[Tagged]参数并且TemplateMiddle包含NotEscapeSequence，则为语法错误。 12.2.9.2 静态语义：TemplateStrings 带有参数raw。 TemplateLiteral : NoSubstitutionTemplate 若 raw 是 false, 那么 令 string 为NoSubstitutionTemplate的TV 否则, 令 string 为NoSubstitutionTemplate的TRV 返回包含单个元素，string的List SubstitutionTemplate : TemplateHead Expression TemplateSpans 若 raw 是 false, 那么 令 head 为TemplateHead的TV 否则, 令 head 为TemplateHead的TRV 令 tail 为带有参数raw的TemplateSpans的TemplateStrings。 返回一个包含头部的列表，其后依次包含尾部元素。 TemplateSpans : TemplateTail 若 raw 是 false, 那么 令 tail 为TemplateTail的TV 否则, 令 tail 为TemplateTail的TRV 返回一个包含单个元素tail的列表。 TemplateSpans : TemplateMiddleList TemplateTail 令 middle 为带参数 raw 的 TemplateMiddleList 的 TemplateStrings。 若 raw 是 false, 那么 令 tail 为TemplateTail的TV 否则, 令 tail 为TemplateTail的TRV 返回一个列表，按顺序包含中间元素和尾部元素。 TemplateMiddleList : TemplateMiddle Expression 若 raw 是 false, 那么 令 string 为TemplateMiddle的TV 否则, 令 string 为TemplateMiddle的TRV 返回一个包含单个元素字符串的列表。 TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression 令 front 为带参数 raw 的 TemplateMiddleList 的 TemplateStrings。 若 raw 是 false, 那么 a. 令 last 为TemplateMiddle的TV 否则, a. 令 last 为TemplateMiddle的TRV 将last作为List的最后一个元素追加。 返回 front. 12.2.9.3 运行时语义：ArgumentListEvaluation TemplateLiteral : NoSubstitutionTemplate 令 templateLiteral 为这个 TemplateLiteral. 令 siteObj 为 GetTemplateObject(templateLiteral). 返回一个包含一个元素的列表，该元素是siteObj。 SubstitutionTemplate : TemplateHead Expression TemplateSpans 令 templateLiteral 为这个 TemplateLiteral. 令 siteObj 为 GetTemplateObject(templateLiteral). 令 firstSubRef 为Expression的运算结果 令 firstSub 为 ? GetValue(firstSubRef). 令 restSub 为 TemplateSpans 的 SubstitutionEvaluation ReturnIfAbrupt(restSub). 断言: restSub 是一个List. 返回一个列表，其第一个元素是siteObj，其第二个元素是firstSub，其后续元素是 restSub 的元素按顺序排列。 restSub可能不包含任何元素。 12.2.9.4 运行时语义：GetTemplateObject ( templateLiteral ) 使用解析节点templateLiteral作为参数调用抽象操作GetTemplateObject。它执行以下步骤： 令 rawStrings 为带参数 true 的 templateLiteral 的 TemplateStrings。 令 realm 为当前作用域记录项。 令 templateRegistry 为 realm.[[TemplateMap]]. 对每一个templateRegistry中的元素 e, 执行 若 e.[[Site]] 是与 templateLiteral 相同的解析节点, 那么 返回 e.[[Array]]. 令 cookedStrings 为 templateLiteral 的 TemplateStrings，参数为false。 令 count 为列表中CookedStrings中元素的数量。 断言: count ≤ 2^32 - 1. 令 template 为 ! ArrayCreate(count). 令 rawObj 为 ! ArrayCreate(count). 令 index 为 0. 重复, 当 index 令 prop 为 ! ToString(index). 令 cookedValue 为 cookedStrings[index] 的字符串值. 调用 template.[[DefineOwnProperty]](prop, PropertyDescriptor { [[Value]]: cookedValue, [[Writable]]: false,[[Enumerable]]: true, [[Configurable]]: false }). 令 rawValue 为 rawStrings[index] 的字符串值. 调用 rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor { [[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }). index 增加1。 执行 SetIntegrityLevel(rawObj, \"frozen\"). 调用 template.[[DefineOwnProperty]](\"raw\", PropertyDescriptor { [[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }). 执行 SetIntegrityLevel(template, \"frozen\"). 添加 Record { [[Site]]: templateLiteral, [[Array]]: template } 到 templateRegistry. 返回 template. 注1：模板对象的创建不能导致突然完成。 注2：作用域的程序代码中的每个TemplateLiteral都与唯一的模板对象相关联，该对象用于执行带标签的模板（12.2.9.6）。模板对象被冻结，并且每次执行特定的标记模板时都使用相同的模板对象。模板对象是在对TemplateLiteral进行第一次执行时是懒惰地创建还是在第一次执行之前急切地创建，这是ECMAScript代码无法观察到的实现选择 注3：本规范的未来版本可能会定义模板对象的其他不可枚举的属性。 12.2.9.5 运行时语义：SubstitutionEvaluation TemplateSpans : TemplateTail 返回一个新的空列表 TemplateSpans : TemplateMiddleList TemplateTail 返回 TemplateMiddleList 的 SubstitutionEvaluation 结果. TemplateMiddleList : TemplateMiddle Expression 令 subRef 为 Expression 的运算结果 令 sub 为 ? GetValue(subRef). 返回只包含sub的列表 TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression 令 preceding 为 TemplateMiddleList 的 SubstitutionEvaluation 的结果. ReturnIfAbrupt(preceding). 令 nextRef 为Expression的运算结果 令 next 为 ? GetValue(nextRef). 将next附加到List的最后一个元素的前面。 返回 preceding. 12.2.9.6 运行时语义：Evaluation TemplateLiteral : NoSubstitutionTemplate 返回字符串，其码元是 NoSubstitutionTemplate 元素的 TV（定义在11.8.6）。 SubstitutionTemplate : TemplateHead Expression TemplateSpans 令 head 为 TemplateHead 的 TV（定义在11.8.6）。 令 subRef 为Expression的运算结果 令 sub 为 ? GetValue(subRef). 令 middle 为 ? ToString(sub). 令 tail 为TemplateSpans的运算结果 ReturnIfAbrupt(tail). 返回 head，middle 和 tail 的字符串连接 注1：应用于Expression值的字符串转换语义类似于String.prototype.concat而不是+运算符。 TemplateSpans : TemplateTail 令 tail 为 TemplateTail 的 TV（定义在11.8.6） 返回由tail的码元组成的String值 TemplateSpans : TemplateMiddleList TemplateTail 令 head 为TemplateMiddleList的运算结果 ReturnIfAbrupt(head). 令 tail 为 TemplateTail 的 TV（定义在11.8.6） 返回 head 和 tail 的字符串连接. TemplateMiddleList : TemplateMiddle Expression 令 head 为 TemplateMiddle 的 TV（定义在11.8.6） 令 subRef 为Expression的运算结果 令 sub 为 ? GetValue(subRef). 令 middle 为 ? ToString(sub). 返回由head码元和middle元素组成的码元序列。 注2：应用于Expression值的字符串转换语义类似于String.prototype.concat而不是+运算符。 TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression 令 rest 为TemplateMiddleList的运算结果 ReturnIfAbrupt(rest). 令 middle 为 the TV of TemplateMiddle as defined in 11.8.6. 令 subRef 为Expression的运算结果 令 sub 为 ? GetValue(subRef). 令 last 为 ? ToString(sub). 返回由rest元素组成的码元序列，其后是middle码元通过last的元素。 注3：应用于Expression值的字符串转换语义类似于String.prototype.concat而不是+运算符。 12.2.10 群组运算符 12.2.10.1 静态语义：Early Errors PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 如果CoverParenthesizedExpressionAndArrowParameterList没有涵盖括号表达式，则是语法错误。 所有适用于括号表示的早期错误规则及其派生结果，也适用于CoverParenthesizedExpressionAndArrowParameterList的CoveredParenthesizedExpression。 12.2.10.2 静态语义：IsFunctionDefinition ParenthesizedExpression : ( Expression ) 返回Expression的IsFunctionDefinition 12.2.10.3 静态语义：AssignmentTargetType ParenthesizedExpression : ( Expression ) 返回Expression的AssignmentTargetType 12.2.10.4 运行时语义：NamedEvaluation 带有参数名称。 PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 令 expr 为CoverParenthesizedExpressionAndArrowParameterList的CoveredParenthesizedExpression 返回使用参数名称对expr执行NamedEvaluation的结果。 ParenthesizedExpression : ( Expression ) 断言: IsAnonymousFunctionDefinition(Expression) 是 true. 返回使用参数名称执行Expression的NamedEvaluation的结果。 12.2.10.5 运行时语义：Evaluation PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 令 expr 为CoverParenthesizedExpressionAndArrowParameterList的CoveredParenthesizedExpression 返回expr的运算结果 ParenthesizedExpression : ( Expression ) 返回Expression的运算结果。这可能为引用类型。 注：该算法不会将GetValue应用于执行Expression的结果。这样做的主要动机是可以将诸如delete和typeof之类的运算符应用于带括号的表达式。 12.3 左值表达式 语法 MemberExpression[Yield, Await] : PrimaryExpression[?Yield, ?Await] MemberExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ] MemberExpression[?Yield, ?Await] . IdentifierName MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged] SuperProperty[?Yield, ?Await] MetaProperty new MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await] SuperProperty[Yield, Await] : super [ Expression[+In, ?Yield, ?Await] ] super . IdentifierName MetaProperty : NewTarget NewTarget : new . target NewExpression[Yield, Await] : MemberExpression[?Yield, ?Await] new NewExpression[?Yield, ?Await] CallExpression[Yield, Await] : CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] SuperCall[?Yield, ?Await] CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await] CallExpression[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ] CallExpression[?Yield, ?Await] . IdentifierName CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged] SuperCall[Yield, Await] : super Arguments[?Yield, ?Await] Arguments[Yield, Await] : ( ) ( ArgumentList[?Yield, ?Await] ) ( ArgumentList[?Yield, ?Await] , ) ArgumentList[Yield, Await] : AssignmentExpression[+In, ?Yield, ?Await] ... AssignmentExpression[+In, ?Yield, ?Await] ArgumentList[?Yield, ?Await] , AssignmentExpression[+In, ?Yield, ?Await] ArgumentList[?Yield, ?Await] , ... AssignmentExpression[+In, ?Yield, ?Await] LeftHandSideExpression[Yield, Await] : NewExpression[?Yield, ?Await] CallExpression[?Yield, ?Await] 补充语法 处理生产CallExpression的实例时：CoverCallExpressionAndAsyncArrowHead，使用以下语法完善CoverCallExpressionAndAsyncArrowHead的解释： CallMemberExpression[Yield, Await] : MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await] 12.3.1 静态语义 12.3.1.1 静态语义：CoveredCallExpression CallExpression : CoverCallExpressionAndAsyncArrowHead 返回 the CallMemberExpression that 是 covered by CoverCallExpressionAndAsyncArrowHead. 12.3.1.2 静态语义：Contains 带有参数symbol。 MemberExpression : MemberExpression . IdentifierName 若 MemberExpression 包含 symbol 是 true, 返回 true. 若 symbol 是 ReservedWord, 返回 false. 若 symbol 是 Identifier，并且 symbol 的 StringValue 和 IdentifierName 的 StringValue 值相同 , 返回 true. 返回 false SuperProperty : super . IdentifierName 若 symbol 是 ReservedWord super, 返回 true. 若 symbol 是 ReservedWord, 返回 false. 若 symbol 是 Identifier，并且 symbol 的 StringValue 和 IdentifierName 的 StringValue 值相同 , 返回 true. 返回 false. CallExpression : CallExpression . IdentifierName 若 CallExpression 包含 symbol 是 true, 返回 true. 若 symbol 是 ReservedWord, 返回 false. 若 symbol 是 Identifier，并且 symbol 的 StringValue 和 IdentifierName 的 StringValue 值相同 , 返回 true. 返回 false. 12.3.1.3 静态语义：IsFunctionDefinition MemberExpression : MemberExpression [ Expression ] MemberExpression . IdentifierName MemberExpression TemplateLiteral SuperProperty MetaProperty new MemberExpression Arguments NewExpression : new NewExpression LeftHandSideExpression : CallExpression 返回 false 12.3.1.4 静态语义：IsDestructuring MemberExpression : PrimaryExpression 若 PrimaryExpression 是 ObjectLiteral 或 ArrayLiteral, 返回 true. 返回 false. MemberExpression : MemberExpression [ Expression ] MemberExpression . IdentifierName MemberExpression TemplateLiteral SuperProperty MetaProperty new MemberExpression Arguments NewExpression : new NewExpression LeftHandSideExpression : CallExpression 返回 false. 12.3.1.5 静态语义：IsIdentifierRef MemberExpression : MemberExpression [ Expression ] MemberExpression . IdentifierName MemberExpression TemplateLiteral SuperProperty MetaProperty new MemberExpression Arguments NewExpression : new NewExpression LeftHandSideExpression : CallExpression 返回 false. 12.3.1.6 静态语义：AssignmentTargetType CallExpression : CallExpression [ Expression ] CallExpression . IdentifierName MemberExpression : MemberExpression [ Expression ] MemberExpression . IdentifierName SuperProperty 返回 simple. CallExpression : CoverCallExpressionAndAsyncArrowHead SuperCall CallExpression Arguments CallExpression TemplateLiteral NewExpression : new NewExpression MemberExpression : MemberExpression TemplateLiteral new MemberExpression Arguments NewTarget : new . target 返回 invalid. 12.3.2 属性访问器 注：使用点符号按名称访问属性： MemberExpression . IdentifierName CallExpression . IdentifierName 或方括号表示法： MemberExpression [ Expression ] CallExpression [ Expression ] 点符号通过以下语法转换进行解释： MemberExpression . IdentifierName 在行为上与 MemberExpression [ ] 同样 CallExpression . IdentifierName 在行为上与 CallExpression [ ] 其中，\\是对IdentifierName的StringValue求值的结果。 12.3.2.1 运行时语义：Evaluation MemberExpression : MemberExpression [ Expression ] 令 baseReference 为MemberExpression的运算结果 令 baseValue 为 ? GetValue(baseReference). 令 propertyNameReference 为Expression的运算结果 令 propertyNameValue 为 ? GetValue(propertyNameReference). 令 bv 为 ? RequireObjectCoercible(baseValue). 令 propertyKey 为 ? ToPropertyKey(propertyNameValue). 若通过这个 MemberExpression 匹配到的是严格模式代码, 令 strict 为 true, 否则 令 strict 为 false. 返回类型为Reference的值，其基本值成分为bv，其引用名称成分为 propertyKey，其严格引用标志为strict。 MemberExpression : MemberExpression . IdentifierName 令 baseReference 为MemberExpression的运算结果 令 baseValue 为 ? GetValue(baseReference). 令 bv 为 ? RequireObjectCoercible(baseValue). 令 propertyNameString 为IdentifierName的StringValue 若通过这个 MemberExpression 匹配到的是严格模式代码, 令 strict 为 true, 否则 令 strict 为 false. 返回类型为Reference的值，其基本值成分为bv，其引用名称成分为 propertyKey，其严格引用标志为strict。 CallExpression : CallExpression [ Expression ] 除了所包含的CallExpression在步骤1中求值，以与MemberExpression：MemberExpression [Expression]完全相同的方式求值。 CallExpression : CallExpression . IdentifierName 除了所包含的CallExpression在步骤1中求值，以与MemberExpression：MemberExpression . IdentifierName 完全相同的方式求值。 12.3.3 new 运算符 12.3.3.1 运行时语义：Evaluation NewExpression : new NewExpression 返回 ? EvaluateNew(NewExpression, empty) MemberExpression : new MemberExpression Arguments 返回 ? EvaluateNew(MemberExpression, Arguments). 12.3.3.1.1 运行时语义：EvaluateNew ( constructExpr, arguments ) 抽象操作EvaluateNew带有参数ConstructExpr，而参数执行以下步骤： 断言: constructExpr 是 NewExpression 或 MemberExpression. 断言: arguments 是 empty 或 Arguments. 令 ref 为 constructExpr 的运算结果 令 constructor 为 ? GetValue(ref). 若 arguments 是 empty, 令 argList 为一个新的空列表 否则, a. 令 argList 为arguments的ArgumentListEvaluation b. ReturnIfAbrupt(argList). 若 IsConstructor(constructor) 是 false,抛出 TypeError 异常. 返回 ? Construct(constructor, argList). 12.3.4 函数回调 12.3.4.1 运行时语义：Evaluation CallExpression : CoverCallExpressionAndAsyncArrowHead 令 expr 为CoverCallExpressionAndAsyncArrowHead的CoveredCallExpression 令 memberExpr 为expr的MemberExpression 令 arguments 为expr的Arguments 令 ref 为memberExpr的运算结果 令 func 为 ? GetValue(ref). 若 Type(ref) 是 Reference 同时 IsPropertyReference(ref) 是 false 同时 GetReferencedName(ref) 是 \"eval\", 那么 若 SameValue(func, %eval%) 是 true, 那么 令 argList 为 ? arguments的ArgumentListEvaluation. 若 argList 没有元素, 返回 undefined. 令 evalText 为 argList 的第一个元素. 若匹配这个 CallExpression 的源代码是严格模式代码, 令 strictCaller 为 true. 否则，令 strictCaller 为 false. 令 evalRealm 为当前作用域记录项. 执行 ? HostEnsureCanCompileStrings(evalRealm, evalRealm). 返回 ? PerformEval(evalText, evalRealm, strictCaller, true). 令 thisCall 为这个 CallExpression. 令 tailCall 为 IsInTailPosition(thisCall). 返回 ? EvaluateCall(func, ref, arguments, tailCall). 执行步骤6.1.7的CallExpression执行是直接执行。 CallExpression : CallExpression Arguments 令 ref 为CallExpression的运算结果 令 func 为 ? GetValue(ref). 令 thisCall 为 this CallExpression. 令 tailCall 为 IsInTailPosition(thisCall). 返回 ? EvaluateCall(func, ref, Arguments, tailCall). 12.3.4.2 运行时语义：EvaluateCall ( func, ref, arguments, tailPosition ) 抽象操作EvaluateCall将值func，值ref，解析节点参数和布尔参数tailPosition用作参数。它执行以下步骤： 若 Type(ref) 是 Reference, 那么 若 IsPropertyReference(ref) 是 true, 那么 令 thisValue 为 GetThisValue(ref). 否则 ref 的基础是环境记录项, 令 refEnv 为 GetBase(ref). 令 thisValue 为 refEnv.WithBaseObject(). 否则 Type(ref) 不是 Reference, 令 thisValue 为 undefined. 令 argList 为arguments的ArgumentListEvaluation ReturnIfAbrupt(argList). 若 Type(func) 不是 Object,抛出 TypeError 异常. 若 IsCallable(func) 是 false,抛出 TypeError 异常. 若 tailPosition 是 true, 执行 PrepareForTailCall(). 令 result 为 Call(func, thisValue, argList). 断言: 若 tailPosition 是 true, 上述回调不会在此处返回, 相反，运算将会继续，就像以下的返回已经发生。 断言: 若 result 不是 abrupt completion, 那么 Type(result) 是 ECMAScript 语言类型. 返回 result. 12.3.5super 关键字 12.3.5.1 运行时语义：Evaluation SuperProperty : super [ Expression ] 令 env 为 GetThisEnvironment(). 令 actualThis 为 ? env.GetThisBinding(). 令 propertyNameReference 为Expression的运算结果 令 propertyNameValue 为 ? GetValue(propertyNameReference). 令 propertyKey 为 ? ToPropertyKey(propertyNameValue). 若通过这个 SuperProperty 匹配到的是严格模式代码, 令 strict 为 true, 否则 令 strict 为 false. 返回 ? MakeSuperPropertyReference(actualThis, propertyKey, strict). SuperProperty : super . IdentifierName 令 env 为 GetThisEnvironment(). 令 actualThis 为 ? env.GetThisBinding(). 令 propertyKey 为IdentifierName的StringValue 若通过这个 SuperProperty 匹配到的是严格模式代码, 令 strict 为 true, 否则 令 strict 为 false. 返回 ? MakeSuperPropertyReference(actualThis, propertyKey, strict). SuperCall : super Arguments 令 newTarget 为 GetNewTarget(). 断言: Type(newTarget) 是 Object. 令 func 为 ? GetSuperConstructor(). 令 argList 为Arguments的ArgumentListEvaluation ReturnIfAbrupt(argList). 令 result 为 ? Construct(func, argList, newTarget). 令 thisER 为 GetThisEnvironment(). 返回 ? thisER.BindThisValue(result). 12.3.5.2 运行时语义：GetSuperConstructor ( ) 抽象操作GetSuperConstructor执行以下步骤： 令 envRec 为 GetThisEnvironment(). 断言: envRec 是 a function Environment Record. 令 activeFunction 为 envRec.[[FunctionObject]]. 断言: activeFunction 是 an ECMAScript function object. 令 superConstructor 为 ! activeFunction.[[GetPrototypeOf]](). 若 IsConstructor(superConstructor) 是 false,抛出 TypeError 异常. 返回 superConstructor 12.3.5.3 运行时语义：MakeSuperPropertyReference ( actualThis, propertyKey, strict ) 抽象操作MakeSuperPropertyReference带有参数ActualThis，propertyKey和strict执行以下步骤： 令 env 为 GetThisEnvironment(). 断言: env.HasSuperBinding() 是 true. 令 baseValue 为 ? env.GetSuperBase(). 令 bv 为 ? RequireObjectCoercible(baseValue). 返回类型为Reference的值，它是super引用，其基本值部分是bv，其引用名称部分为propertyKey，其thisValue部分为ActualThis，其严格引用标志为strict 12.3.6 参数列表 注：对参数列表的求值将生成值列表。 12.3.6.1 运行时语义：ArgumentListEvaluation Arguments : ( ) 返回一个新的空列表 ArgumentList : AssignmentExpression 令 ref 为AssignmentExpression的运算结果 令 arg 为 ? GetValue(ref). 返回唯一项目是 arg的列表. ArgumentList : ... AssignmentExpression 令 list 为一个新的空列表 令 spreadRef 为AssignmentExpression的运算结果 令 spreadObj 为 ? GetValue(spreadRef). 令 iteratorRecord 为 ? GetIterator(spreadObj). 重复, 令 next 为 ? IteratorStep(iteratorRecord). 若 next 是 false, 返回 list. 令 nextArg 为 ? IteratorValue(next). 添加nextArg到列表的最后一个元素 ArgumentList : ArgumentList , AssignmentExpression 令 precedingArgs 为ArgumentList的ArgumentListEvaluation ReturnIfAbrupt(precedingArgs). 令 ref 为AssignmentExpression的运算结果 令 arg 为 ? GetValue(ref). 添加 arg 到 precedingArgs 的末尾. 返回 precedingArgs. ArgumentList : ArgumentList , ... AssignmentExpression 令 precedingArgs 为ArgumentList的ArgumentListEvaluation ReturnIfAbrupt(precedingArgs). 令 spreadRef 为AssignmentExpression的运算结果 令 iteratorRecord 为 ? GetIterator(? GetValue(spreadRef)). 重复, 令 next 为 ? IteratorStep(iteratorRecord). 若 next 是 false, 返回 precedingArgs. 令 nextArg 为 ? IteratorValue(next). 添加 nextArg 到 precedingArgs 的最后一个元素. 12.3.7 标记模板 注：带标签的模板是一个函数调用，其中调用的参数是从TemplateLiteral（12.2.9）派生的。实际参数包括模板对象（12.2.9.4）和通过执行嵌入在TemplateLiteral中的表达式产生的值。 12.3.7.1 运行时语义：Evaluation MemberExpression : MemberExpression TemplateLiteral 令 tagRef 为MemberExpression的运算结果 令 tagFunc 为 ? GetValue(tagRef). 令 thisCall 为这个 MemberExpression. 令 tailCall 为 IsInTailPosition(thisCall). 返回 ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall). CallExpression : CallExpression TemplateLiteral 令 tagRef 为CallExpression的运算结果 令 tagFunc 为 ? GetValue(tagRef). 令 thisCall 为 这个 CallExpression. 令 tailCall 为 IsInTailPosition(thisCall). 返回 ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall). 12.3.8 元属性 12.3.8.1 运行时语义：Evaluation NewTarget : new . target 返回 GetNewTarget(). 12.4 更新表达式 语法 UpdateExpression[Yield, Await] : LeftHandSideExpression[?Yield, ?Await] LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] ++ LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] -- ++ UnaryExpression[?Yield, ?Await] -- UnaryExpression[?Yield, ?Await] 12.4.1 静态语义：Early Errors UpdateExpression : LeftHandSideExpression ++ LeftHandSideExpression -- 如果LeftHandSideExpression的AssignmentTargetType是invalid，则是早期引用错误。 如果LeftHandSideExpression的AssignmentTargetType是strict，则这是早期的语法错误。 UpdateExpression : ++ UnaryExpression -- UnaryExpression 如果UnaryExpression的AssignmentTargetType是invalid，则是早期引用错误。 如果UnaryExpression的AssignmentTargetType是strict，则这是早期的语法错误。 12.4.2 静态语义：IsFunctionDefinition UpdateExpression : LeftHandSideExpression ++ LeftHandSideExpression -- ++ UnaryExpression -- UnaryExpression 返回 false. 12.4.3 静态语义：AssignmentTargetType UpdateExpression : LeftHandSideExpression ++ LeftHandSideExpression -- ++ UnaryExpression -- UnaryExpression 返回 invalid. 12.4.4 后缀自增运算符 12.4.4.1 运行时语义：Evaluation UpdateExpression : LeftHandSideExpression ++ 令 lhs 为LeftHandSideExpression的运算结果 令 oldValue 为 ? ToNumber(? GetValue(lhs)). 令 newValue 为使用与+运算符相同的规则将值1添加到oldValue的结果（参见 12.8.5） 执行 ? PutValue(lhs, newValue). 返回 oldValue 12.4.5 后缀自减运算符 12.4.5.1 运行时语义：Evaluation UpdateExpression : LeftHandSideExpression -- 令 lhs 为LeftHandSideExpression的运算结果 令 oldValue 为 ? ToNumber(? GetValue(lhs)). 令 newValue使用与-运算符相同的规则将值1添加到oldValue的结果（参见 12.8.5） 执行 ? PutValue(lhs, newValue). 返回 oldValue. 12.4.6 前缀自增运算符 12.4.6.1 运行时语义：Evaluation UpdateExpression : ++ UnaryExpression 令 expr 为UnaryExpression的运算结果 令 oldValue 为 ? ToNumber(? GetValue(expr)). 令 newValue 为使用与+运算符相同的规则将值1添加到oldValue的结果（参见 12.8.5） 执行 ? PutValue(expr, newValue). 返回 newValue. 12.4.7 前缀自减运算符 12.4.7.1 运行时语义：Evaluation UpdateExpression : -- UnaryExpression 令 expr 为UnaryExpression的运算结果 令 oldValue 为 ? ToNumber(? GetValue(expr)). 令 newValue 为与-运算符相同的规则将值1添加到oldValue的结果（参见 12.8.5） 执行 ? PutValue(expr, newValue). 返回 newValue. 12.5 一元运算符 语法 UnaryExpression[Yield, Await] : UpdateExpression[?Yield, ?Await] delete UnaryExpression[?Yield, ?Await] void UnaryExpression[?Yield, ?Await] typeof UnaryExpression[?Yield, ?Await] + UnaryExpression[?Yield, ?Await] - UnaryExpression[?Yield, ?Await] ~ UnaryExpression[?Yield, ?Await] ! UnaryExpression[?Yield, ?Await] [+Await] AwaitExpression[?Yield] 12.5.1 静态语义：IsFunctionDefinition UnaryExpression : delete UnaryExpression void UnaryExpression typeof UnaryExpression + UnaryExpression - UnaryExpression ~ UnaryExpression ! UnaryExpression AwaitExpression 返回 false. 12.5.2 静态语义：AssignmentTargetType UnaryExpression : delete UnaryExpression void UnaryExpression typeof UnaryExpression + UnaryExpression - UnaryExpression ~ UnaryExpression ! UnaryExpression AwaitExpression 返回 invalid 12.5.3delete 运算符 12.5.3.1 静态语义：Early Errors UnaryExpression : delete UnaryExpression 如果严格模式代码中包含UnaryExpression，并且派生的UnaryExpression为，则会出现语法错误。 PrimaryExpression : IdentifierReference . 如果派生的UnaryExpression为 PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 和CoverParenthesizedExpressionAndArrowParameterList最终派生一个短语，如果代替UnaryExpression使用，则会根据这些规则产生语法错误。该规则是递归应用的。 注意 最后一条规则意味着诸如delete（（（（foo）））之类的表达式会由于第一个规则的递归应用而产生早期错误。 12.5.3.2 运行时语义：Evaluation UnaryExpression : delete UnaryExpression 令 ref 为UnaryExpression的运算结果 ReturnIfAbrupt(ref). 若 Type(ref) 不是 Reference, 返回 true. 若 IsUnresolvableReference(ref) 是 true, 那么 断言: IsStrictReference(ref) 是 false. 返回 true. 若 IsPropertyReference(ref) 是 true, 那么 若 IsSuperReference(ref) 是 true,抛出 ReferenceError 异常. 令 baseObj 为 ! ToObject(GetBase(ref)). 令 deleteStatus 为 ? baseObj.[[Delete]](GetReferencedName(ref)). 若 deleteStatus 是 false 并且 IsStrictReference(ref) 是 true,抛出 TypeError 异常. 返回 deleteStatus. 否则 ref 是对环境记录绑定的引用， 令 bindings 为 GetBase(ref). 返回 ? bindings.DeleteBinding(GetReferencedName(ref)). 注意 在严格模式代码中发生删除运算符时，如果其UnaryExpression是对变量，函数参数或函数名称的直接引用，则会引发SyntaxError异常。另外，如果在严格模式代码内发生删除运算符，并且要删除的属性具有属性{[[Configurable]]：false}，则会引发TypeError异常。 12.5.4void 运算符 12.5.4.1 运行时语义：Evaluation UnaryExpression : void UnaryExpression 令 expr 为UnaryExpression的运算结果 执行 ? GetValue(expr). 返回 undefined. 注意 即使没有使用GetValue，也必须调用它，因为它可能会有明显的副作用。 12.5.5typeof 运算符 12.5.5.1 运行时语义：Evaluation UnaryExpression : typeof UnaryExpression 令 val 为UnaryExpression的运算结果 若 Type(val) 是 Reference, 那么 若 IsUnresolvableReference(val) 是 true, 返回 \"undefined\". 设置 val 为 ? GetValue(val). 返回字符串，根据Table 35. val类型 结果 Undefined \"undefined\" Null \"object\" Boolean \"boolean\" Number \"number\" String \"string\" Symbol \"symbol\" Object (普通且不实现[[Call]]) \"object\" Object (标准异类且不实现[[Call]]) \"object\" Object (实现[[Call]]) \"function\" Object (非标准异类且没有实现[[Call]]) 实现定义。 不能是“undefined”，“boolean”，“function”，“number”，“symbol”或“string”。 注意：不建议为非标准异类对象定义新类型的结果值。如果可能，应将“object”用于此类对象。 12.5.6 一元+ 运算符 注意 一元+运算符将其操作数转换为Number类型。 12.5.6.1 运行时语义：Evaluation UnaryExpression : + UnaryExpression 令 expr 为UnaryExpression的运算结果 返回 ? ToNumber(? GetValue(expr)). 12.5.7 一元- 运算符 注意 一元运算符将其操作数转换为数字类型，然后取反。取负+0产生-0，取负-0产生+0。 12.5.7.1 运行时语义：Evaluation UnaryExpression : - UnaryExpression 令 expr 为UnaryExpression的运算结果 令 oldValue 为 ? ToNumber(? GetValue(expr)). 若 oldValue 是 NaN, 返回 NaN. 返回否定oldValue的结果; 也就是说，计算一个具有相同大小但符号相反的数字。 12.5.8 按位非运算符 ( ~ ) 12.5.8.1 运行时语义：Evaluation UnaryExpression : ~ UnaryExpression 令 expr 为UnaryExpression的运算结果 令 oldValue 为 ? ToInt32(? GetValue(expr)). 返回对oldValue部分按位补码的结果。结果是一个有符号的32位整数。 12.5.9 逻辑非运算符( ! ) 12.5.9.1 运行时语义：Evaluation UnaryExpression : ! UnaryExpression 令 expr 为UnaryExpression的运算结果 令 oldValue 为 ToBoolean(? GetValue(expr)). 若 oldValue 是 true, 返回 false. 返回 true 12.6 指数运算符 语法 ExponentiationExpression[Yield, Await] : UnaryExpression[?Yield, ?Await] UpdateExpression[?Yield, ?Await] ** ExponentiationExpression[?Yield, ?Await] 12.6.1 静态语义：IsFunctionDefinition ExponentiationExpression : UpdateExpression ** ExponentiationExpression 返回 false 12.6.2 静态语义：AssignmentTargetType ExponentiationExpression : UpdateExpression ** ExponentiationExpression 返回 invalid. 12.6.3 运行时语义：Evaluation ExponentiationExpression : UpdateExpression ** ExponentiationExpression 令 left 为UpdateExpression的运算结果 令 leftValue 为 ? GetValue(left). 令 right 为ExponentiationExpression的运算结果 令 rightValue 为 ? GetValue(right). 令 base 为 ? ToNumber(leftValue). 令 exponent 为 ? ToNumber(rightValue). 返回将**运算符与12.6.4中指定的base和exponent相乘的结果。 12.6.4 使用** 运算符 返回将底数提高到幂指数的结果的与实现有关的近似值。 若 exponent 是 NaN, 结果是 NaN. 若 exponent 是 +0, 结果是 1, 即使 base 是 NaN. 若 exponent 是 -0, 结果是 1, 即使 base 是 NaN. 若 base 是 NaN 并且 exponent 是 nonzero, 结果是 NaN. 若 abs(base) > 1 并且 exponent 是 +∞, 结果是 +∞. 若 abs(base) > 1 并且 exponent 是 -∞, 结果是 +0. 若 abs(base) 是 1 并且 exponent 是 +∞, 结果是 NaN. 若 abs(base) 是 1 并且 exponent 是 -∞, 结果是 NaN. 若 abs(base) 0, 结果是 +∞. 若 base 是 +∞ 并且 exponent 0 并且 exponent 是奇数整数, 结果是 -∞. 若 base 是 -∞ 并且 exponent > 0 并且 exponent 不是奇数整数, 结果是 +∞. 若 base 是 -∞ 并且 exponent 0, 结果是 +0. 若 base 是 +0 并且 exponent 0 并且 exponent 是奇数整数, 结果是 -0. 若 base 是 -0 并且 exponent > 0 并且 exponent 不是奇数整数, 结果是 +0. 若 base 是 -0 并且 exponent 注意 当base为1或-1且指数为+ Infinity或-Infinity时，base **指数的结果与IEEE 754-2008不同。ECMAScript的第一版为此操作指定了NaN的结果，而IEEE 754-2008的更高版本则指定了1。出于兼容性原因，保留了历史ECMAScript行为。 12.7 乘数运算符 语法 MultiplicativeExpression[Yield, Await] : ExponentiationExpression[?Yield, ?Await] MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await] MultiplicativeOperator : one of * / % 12.7.1 静态语义：IsFunctionDefinition MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression 返回 false. 12.7.2 静态语义：AssignmentTargetType MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression 返回 invalid. 12.7.3 运行时语义：Evaluation MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression 令 left 为MultiplicativeExpression的运算结果 令 leftValue 为 ? GetValue(left). 令 right 为ExponentiationExpression的运算结果 令 rightValue 为 ? GetValue(right). 令 lnum 为 ? ToNumber(leftValue). 令 rnum 为 ? ToNumber(rightValue). 返回将12.7.3.1、12.7.3.2或12.7.3.3中指定的MultiplicativeOperator（*，/或％）应用于lnum和rnum的结果。 12.7.3.1 使用* 运算符 * MultiplicativeOperator执行乘法，产生其操作数的乘积。乘法具有交换律。由于有限的精度，乘法在ECMAScript中并不总是有结合律。 浮点乘法的结果受IEEE 754-2008二进制双精度算法的规则支配： 如果任一操作数为NaN，则结果为NaN。 如果两个操作数具有相同的符号，则结果的符号为正；如果两个操作数具有不同的符号，则结果为负。 无穷大乘以零会产生NaN。 无穷大与无穷大相乘会导致无穷大。该标志由上述规则确定。 无穷大与有限非零值的乘积导致有符号无穷大。该标志由上述规则确定。 在其余情况下，不涉及无穷大或NaN时，将使用IEEE 754-2008四舍五入到偶数模式来计算乘积并四舍五入到最接近的可表示值。如果幅度太大而无法表示，则结果是适当符号的无穷大。如果幅度太小而无法表示，则结果为适当符号的零。ECMAScript语言需要支持IEEE 754-2008所定义的渐进式下溢。 12.7.3.2 使用/ 运算符 / MultiplicativeOperator执行除法，产生其操作数的商。左操作数是除数，右操作数是除数。ECMAScript不执行整数除法。所有除法运算的操作数和结果均为双精度浮点数。除法的结果由IEEE 754-2008算法的规范确定： 如果任一操作数为NaN，则结果为NaN。 如果两个操作数具有相同的符号，则结果的符号为正；如果两个操作数具有不同的符号，则结果为负。 无限除以无限会得到NaN。 无穷大除以零会导致无穷大。该标志由上述规则确定。 无穷大除以非零有限值会导致有符号无穷大。该标志由上述规则确定。 有限值除以无穷大将得出零。该标志由上述规则确定。 将零除以零会产生NaN；将零除以任何其他有限值将得出零，其符号由上述规则确定。 非零有限值除以零会导致有符号无穷大。该标志由上述规则确定。 在其余情况下，既不涉及无穷大，也不涉及零，也不涉及NaN，则使用IEEE 754-2008四舍五入到偶数模式来计算商并四舍五入到最接近的可表示值。如果幅度太大而无法表示，则操作会溢出；结果是适当符号的无穷大。如果幅度太小而无法表示，则操作会下溢，并且结果为适当符号的零。ECMAScript语言需要支持IEEE 754-2008所定义的渐进式下溢。 12.7.3.3 使用% 运算符 ％MultiplicativeOperator从隐式除法中得出其其余操作数；左操作数是除数，右操作数是除数。 注意 在C和C ++中，其余运算符仅接受整数操作数；请参见在ECMAScript中，它也接受浮点操作数。 由％运算符计算的浮点余数运算的结果与IEEE 754-2008定义的“余数”运算不同。IEEE 754-2008“余数”运算是根据舍入除法而不是截断除法计算余数的，因此其行为与通常的整数余数运算符的行为并不相似。相反，ECMAScript语言在浮点运算上定义了％，其行为类似于Java整数余数运算符；可以将其与C库函数fmod进行比较。 ECMAScript浮点余数运算的结果由IEEE算术规则确定： 如果任一操作数为NaN，则结果为NaN。 结果的符号等于被除数的符号。 如果被除数是无穷大，或者除数是零，或者两者都是，则结果为NaN。如果除数是有限的，并且除数是无穷大，则结果等于除数。如果被除数为零，并且除数为非零且有限，则结果与被除数相同。在其余情况下，既不涉及无穷大，也不涉及零，也不涉及NaN，则除数n和除数d的浮点余数r由数学关系r = n-（d×q）定义，其中q是一个整数，仅当n / d为负时才为负，而只有当n / d为正时才为正，并且其大小应尽可能大而不会超过n和d的真数学商。使用IEEE 754-2008将r计算为四舍五入并舍入为最接近的可表示值，并舍入为偶数模式 12.8 加法运算符 语法 AdditiveExpression[Yield, Await] : MultiplicativeExpression[?Yield, ?Await] AdditiveExpression[?Yield, ?Await] + MultiplicativeExpression[?Yield, ?Await] AdditiveExpression[?Yield, ?Await] - MultiplicativeExpression[?Yield, ?Await] 12.8.1 静态语义：IsFunctionDefinition AdditiveExpression : AdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression 返回 false. 12.8.2 静态语义：AssignmentTargetType AdditiveExpression : AdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression 返回 invalid. 12.8.3 加法运算符( + ) 注意 加法运算符可以执行字符串连接或数字加法。 12.8.3.1 运行时语义：Evaluation AdditiveExpression : AdditiveExpression + MultiplicativeExpression 令 lref 为AdditiveExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为MultiplicativeExpression的运算结果 令 rval 为 ? GetValue(rref). 令 lprim 为 ? ToPrimitive(lval). 令 rprim 为 ? ToPrimitive(rval). 若 Type(lprim) 是 String or Type(rprim) 是 String, 那么 令 lstr 为 ? ToString(lprim). 令 rstr 为 ? ToString(rprim). 返回 lstr 和 rstr 的 string-concatenation. 令 lnum 为 ? ToNumber(lprim). 令 rnum 为 ? ToNumber(rprim). 返回将加法运算应用于lnum和rnum的结果。参见 12.8.5下的注意事项. 注1：在第5步和第6步中对ToPrimitive的调用中未提供任何提示。除Date对象外，所有标准对象都处理没有提示的情况，就好像给出了提示编号一样。Date对象处理提示的缺失，就像提示字符串已给出一样。异类对象可以其他某种方式处理提示的缺失。 注2：步骤7与抽象关系比较算法的步骤3不同，它使用逻辑或运算代替逻辑与运算。 12.8.4 减法运算符( - ) 12.8.4.1 运行时语义：Evaluation AdditiveExpression : AdditiveExpression - MultiplicativeExpression 令 lref 为AdditiveExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为MultiplicativeExpression的运算结果 令 rval 为 ? GetValue(rref). 令 lnum 为 ? ToNumber(lval). 令 rnum 为 ? ToNumber(rval). 返回将减法运算应用于lnum和rnum的结果。参见 12.8.5下的注意事项. 12.8.5 加法作用于数字 当将+运算符应用于两个数字类型的操作数时，它们将执行加法运算，从而产生操作数之和。-运算符执行减法运算，产生两个数字操作数的差。 加法是可交换的运算，但并不总是可结合的。 加法的结果使用IEEE 754-2008二进制双精度算法的规则确定： 如果任一操作数为NaN，则结果为NaN。 具有相反符号的两个无穷大之和为NaN。 同一符号的两个无穷大之和就是该符号的无穷大。 无穷大与有限值之和等于无穷操作数。 两个负零的总和为-0。两个正零或符号相反的两个零的总和为+0。 零和非零有限值之和等于非零操作数。 两个大小相同且符号相反的非零有限值的总和为+0。 在其余情况下，既不涉及无穷大，也不涉及零，也不涉及NaN，并且操作数具有相同的符号或具有不同的大小，则使用IEEE 754-2008舍入到最接近的值，计算总和并舍入到最接近的可表示值。，与偶数模式相关。如果幅度太大而无法表示，则操作会溢出结果就是适当符号的无穷大。ECMAScript语言需要逐步支持IEEE 754-2008定义的下溢。 注意 -运算符应用于两个数字类型的操作数时会进行减法运算，从而产生其操作数之差；左边的操作数是被减数，右边的操作数是被减数。给定数值操作数a和b，a - b总是产生与a +（-b）相同的结果 12.9 按位移运算符 语法 ShiftExpression[Yield, Await] : AdditiveExpression[?Yield, ?Await] ShiftExpression[?Yield, ?Await] > AdditiveExpression[?Yield, ?Await] ShiftExpression[?Yield, ?Await] >>> AdditiveExpression[?Yield, ?Await] 12.9.1 静态语义：IsFunctionDefinition ShiftExpression : ShiftExpression > AdditiveExpression ShiftExpression >>> AdditiveExpression 返回 false. 12.9.2 静态语义：AssignmentTargetType ShiftExpression : ShiftExpression > AdditiveExpression ShiftExpression >>> AdditiveExpression 返回 invalid. 12.9.3 左移位运算符( 注意 在左操作数上按右操作数指定的数量执行按位左移运算。 12.9.3.1 运行时语义：Evaluation ShiftExpression : ShiftExpression 令 lref 为ShiftExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为AdditiveExpression的运算结果 令 rval 为 ? GetValue(rref). 令 lnum 为 ? ToInt32(lval). 令 rnum 为 ? ToUint32(rval). 令 shiftCount 为屏蔽掉rnum的除最低有效5位以外的所有位的结果，即计算rnum和 0x1F。 返回将lnum左移shiftCount位的结果。结果是一个有符号的32位整数。 12.9.4 带号右移位运算符( >> ) 注意 对左操作数执行符号填充，按右操作数指定的数量进行右移。 12.9.4.1 运行时语义：Evaluation ShiftExpression : ShiftExpression >> AdditiveExpression 令 lref 为ShiftExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为AdditiveExpression的运算结果 令 rval 为 ? GetValue(rref). 令 lnum 为 ? ToInt32(lval). 令 rnum 为 ? ToUint32(rval). 令 shiftCount 为屏蔽掉rnum的除最低有效5位以外的所有位的结果，即计算rnum＆0x1F。 返回通过shiftCount位执行lnum的符号扩展右移的结果。最高有效位被传递。结果是一个有符号的32位整数 12.9.5 不带号右移位运算符( >>> ) 注意：对左操作数执行按右操作数指定的数量的零填充按位右移运算。 12.9.5.1 运行时语义：Evaluation ShiftExpression : ShiftExpression >>> AdditiveExpression 令 lref 为ShiftExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为AdditiveExpression的运算结果 令 rval 为 ? GetValue(rref). 令 lnum 为 ? ToUint32(lval). 令 rnum 为 ? ToUint32(rval). 令 shiftCount 为屏蔽掉rnum的除最低有效5位以外的所有位的结果，即计算 rnum 和 0x1F。 返回通过shiftCount位执行lnum的零填充右移的结果。空位用零填充，结果是32位无符号整数。 12.10 关系运算符 注1：关系运算符的求值结果始终为布尔类型，反映了运算符命名的关系是否在其两个操作数之间成立 语法 RelationalExpression[In, Yield, Await] : ShiftExpression[?Yield, ?Await] RelationalExpression[?In, ?Yield, ?Await] ShiftExpression[?Yield, ?Await] RelationalExpression[?In, ?Yield, ?Await] = ShiftExpression[?Yield, ?Await] RelationalExpression[?In, ?Yield, ?Await] instanceof ShiftExpression[?Yield, ?Await] [+In] RelationalExpression[+In, ?Yield, ?Await] in ShiftExpression[?Yield, ?Await] 注2：需要使用[In]语法参数，以避免将关系表达式中的in运算符与for语句中的in运算符混淆。 12.10.1 静态语义：IsFunctionDefinition RelationalExpression : RelationalExpression ShiftExpression RelationalExpression = ShiftExpression RelationalExpression instanceof ShiftExpression RelationalExpression in ShiftExpression 返回 false. 12.10.2 静态语义：AssignmentTargetType RelationalExpression : RelationalExpression ShiftExpression RelationalExpression = ShiftExpression RelationalExpression instanceof ShiftExpression RelationalExpression in ShiftExpression 返回 invalid. 12.10.3 运行时语义：Evaluation RelationalExpression : RelationalExpression 令 lref 为RelationalExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为ShiftExpression的运算结果 令 rval 为 ? GetValue(rref). 令 r 为执行抽象关系比较 lval ReturnIfAbrupt(r). 若 r 是 undefined, 返回 false. 否则, 返回 r. RelationalExpression : RelationalExpression > ShiftExpression 令 lref 为RelationalExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为ShiftExpression的运算结果 令 rval 为 ? GetValue(rref). 令 r 为在LeftFirst等于false的情况下执行抽象关系比较rval ReturnIfAbrupt(r). 若 r 是 undefined, 返回 false. 否则, 返回 r RelationalExpression : RelationalExpression 令 lref 为RelationalExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为ShiftExpression的运算结果 令 rval 为 ? GetValue(rref). 令 r 为在LeftFirst等于false的情况下执行抽象关系比较rval ReturnIfAbrupt(r). 若 r 是 true or undefined, 返回 false. 否则, 返回 true. RelationalExpression : RelationalExpression >= ShiftExpression 令 lref 为RelationalExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为ShiftExpression的运算结果 令 rval 为 ? GetValue(rref). 令 r 为执行抽象关系比较 lval ReturnIfAbrupt(r). 若 r 是 true or undefined, 返回 false. 否则, 返回 true. RelationalExpression : RelationalExpression instanceof ShiftExpression 令 lref 为RelationalExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为ShiftExpression的运算结果 令 rval 为 ? GetValue(rref). 返回 ? InstanceofOperator(lval, rval) RelationalExpression : RelationalExpression in ShiftExpression 令 lref 为RelationalExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为ShiftExpression的运算结果 令 rval 为 ? GetValue(rref). 若 Type(rval) 不是 Object,抛出 TypeError 异常. 返回 ? HasProperty(rval, ToPropertyKey(lval)). 12.10.4 运行时语义：InstanceofOperator ( V, target ) 抽象操作InstanceofOperator（V，target）实现了通用算法，可通过询问目标的@@ hasinstance方法来确定ECMAScript值V是否是对象目标的实例，或者如果不存在，则确定V的目标属性是否存在目标原型属性原型链。此抽象操作执行以下步骤： 若 Type(target) 不是 Object,抛出 TypeError 异常. 令 instOfHandler 为 ? GetMethod(target, @@hasInstance). 若 instOfHandler 不是 undefined, 那么 返回 ToBoolean(? Call(instOfHandler, target, « V »)). 若 IsCallable(target) 是 false,抛出 TypeError 异常. 返回 ? OrdinaryHasInstance(target, V). 注意 步骤4和5提供了与ECMAScript以前版本的兼容性，该版本未使用@@ hasInstance方法来定义instanceof运算符语义。如果对象未定义或继承@@ hasInstance，则它将使用默认的instanceof语义。 12.11 相等运算符 注意 计算相等运算符的结果始终是布尔类型，反映了该运算符命名的关系是否在其两个操作数之间成立。 语法 EqualityExpression[In, Yield, Await] : RelationalExpression[?In, ?Yield, ?Await] EqualityExpression[?In, ?Yield, ?Await] == RelationalExpression[?In, ?Yield, ?Await] EqualityExpression[?In, ?Yield, ?Await] != RelationalExpression[?In, ?Yield, ?Await] EqualityExpression[?In, ?Yield, ?Await] === RelationalExpression[?In, ?Yield, ?Await] EqualityExpression[?In, ?Yield, ?Await] !== RelationalExpression[?In, ?Yield, ?Await] 12.11.1 静态语义：IsFunctionDefinition EqualityExpression : EqualityExpression == RelationalExpression EqualityExpression != RelationalExpression EqualityExpression === RelationalExpression EqualityExpression !== RelationalExpression 返回 false. 12.11.2 静态语义：AssignmentTargetType EqualityExpression : EqualityExpression == RelationalExpression EqualityExpression != RelationalExpression EqualityExpression === RelationalExpression EqualityExpression !== RelationalExpression 返回 invalid. 12.11.3 运行时语义：Evaluation EqualityExpression : EqualityExpression == RelationalExpression 令 lref 为EqualityExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为RelationalExpression的运算结果 令 rval 为 ? GetValue(rref). 返回执行抽象相等比较 rval == lval 的结果。 EqualityExpression : EqualityExpression != RelationalExpression 令 lref 为EqualityExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为RelationalExpression的运算结果 令 rval 为 ? GetValue(rref). 令 r 为执行抽象相等比较 rval == lval 的结果。 若 r 是 true, 返回 false. 否则, 返回 true. EqualityExpression : EqualityExpression === RelationalExpression 令 lref 为EqualityExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为RelationalExpression的运算结果 令 rval 为 ? GetValue(rref). 返回执行严格相等比较 rval === lval 的结果。 EqualityExpression : EqualityExpression !== RelationalExpression 令 lref 为EqualityExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为RelationalExpression的运算结果 令 rval 为 ? GetValue(rref). 令 r 为执行严格相等比较 rval === lval 的结果。 若 r 是 true, 返回 false. 否则, 返回 true. 注1： 鉴于以上对平等的定义： ​ 可以通过以下方式强制进行字符串比较：“” + a ==“” + b。 ​ 可以通过以下方式强制进行数字比较：+ a == + b。 ​ 可以通过以下方式强制进行布尔比较：！a ==！b。 注2： 相等运算符维护以下不变式： ​ A != B 等于 !(A == B)。 ​ A == B 等于 B == A，除了A和B的取值顺序。 注3： 相等运算符并不总是可传递的。例如，可能有两个不同的String对象，每个对象代表相同的String值；==运算符将认为每个String对象都等于String值，但是两个String对象将彼此不相等。例如： ​ new String（\"a\"）==\"a\"和\"a\" == new String（\"a\"）均为true。 ​ new String（\"a\"）== new String（\"a\"）为false。 注4： 字符串比较对代码单元值的序列使用简单的相等性测试。没有尝试使用更复杂的，面向语义的字符或字符串相等性定义以及Unicode规范中定义的整理顺序。因此，根据Unicode标准规范相等的字符串值可以测试为不相等。实际上，该算法假定两个字符串都已经处于规范化形式 12.12 二进制按位运算符 语法 BitwiseANDExpression[In, Yield, Await] : EqualityExpression[?In, ?Yield, ?Await] BitwiseANDExpression[?In, ?Yield, ?Await] & EqualityExpression[?In, ?Yield, ?Await] BitwiseXORExpression[In, Yield, Await] : BitwiseANDExpression[?In, ?Yield, ?Await] BitwiseXORExpression[?In, ?Yield, ?Await] ^ BitwiseANDExpression[?In, ?Yield, ?Await] BitwiseORExpression[In, Yield, Await] : BitwiseXORExpression[?In, ?Yield, ?Await] BitwiseORExpression[?In, ?Yield, ?Await] | BitwiseXORExpression[?In, ?Yield, ?Await] 12.12.1 静态语义：IsFunctionDefinition BitwiseANDExpression : BitwiseANDExpression & EqualityExpression BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression 返回 false. 12.12.2 静态语义：AssignmentTargetType BitwiseANDExpression : BitwiseANDExpression & EqualityExpression BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression 返回 invalid. 12.12.3 运行时语义：Evaluation 生产A：A @ B，其中@是上述生产中按位运算符之一，其计算如下： 令 lref 为A的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为B的运算结果 令 rval 为 ? GetValue(rref). 令 lnum 为 ? ToInt32(lval). 令 rnum 为 ? ToInt32(rval). 返回将按位运算符@应用于lnum和rnum的结果。结果是一个有符号的32位整数。 12.13 二元逻辑运算符 语法 LogicalANDExpression[In, Yield, Await] : BitwiseORExpression[?In, ?Yield, ?Await] LogicalANDExpression[?In, ?Yield, ?Await] && BitwiseORExpression[?In, ?Yield, ?Await] LogicalORExpression[In, Yield, Await] : LogicalANDExpression[?In, ?Yield, ?Await] LogicalORExpression[?In, ?Yield, ?Await] || LogicalANDExpression[?In, ?Yield, ?Await] 注意 由&&或||产生的值运算符不一定是布尔类型。产生的值将始终是两个操作数表达式之一的值。 12.13.1 静态语义：IsFunctionDefinition LogicalANDExpression : LogicalANDExpression && BitwiseORExpression LogicalORExpression : LogicalORExpression || LogicalANDExpression 返回 false. 12.13.2 静态语义：AssignmentTargetType LogicalANDExpression : LogicalANDExpression && BitwiseORExpression LogicalORExpression : LogicalORExpression || LogicalANDExpression 返回 invalid. 12.13.3 运行时语义：Evaluation LogicalANDExpression : LogicalANDExpression && BitwiseORExpression 令 lref 为LogicalANDExpression的运算结果 令 lval 为 ? GetValue(lref). 令 lbool 为 ToBoolean(lval). 若 lbool 是 false, 返回 lval. 令 rref 为BitwiseORExpression的运算结果 返回 ? GetValue(rref). LogicalORExpression : LogicalORExpression || LogicalANDExpression 令 lref 为LogicalORExpression的运算结果 令 lval 为 ? GetValue(lref). 令 lbool 为 ToBoolean(lval). 若 lbool 是 true, 返回 lval. 令 rref 为LogicalANDExpression的运算结果 返回 ? GetValue(rref). 12.14 条件运算符 语法 ConditionalExpression[In, Yield, Await] : LogicalORExpression[?In, ?Yield, ?Await] LogicalORExpression[?In, ?Yield, ?Await] ? AssignmentExpression[+In, ?Yield, ?Await] : AssignmentExpression[?In, ?Yield, ?Await] 注意 ECMAScript中的ConditionalExpression的语法与C和Java中的略有不同，后者分别允许第二个子表达式为Expression，但将第三个表达式限制为ConditionalExpression。ECMAScript中这种差异的动机是允许赋值表达式由条件的任一分支支配，并消除以逗号表达式为中心表达式的令人困惑且相当无用的情况。 12.14.1 静态语义：IsFunctionDefinition ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression 返回 false. 12.14.2 静态语义：AssignmentTargetType ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression 返回 invalid. 12.14.3 运行时语义：Evaluation ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression 令 lref 为LogicalORExpression的运算结果 令 lval 为 ToBoolean(? GetValue(lref)). 若 lval 是 true, 那么 a. 令 trueRef 为运算第一个AssignmentExpression的结果。 b. 返回 ? GetValue(trueRef). 否则, a. 令 falseRef 为运算第二个AssignmentExpression的结果。 b. 返回 ? GetValue(falseRef). 12.15 赋值运算符 语法 AssignmentExpression[In, Yield, Await] : ConditionalExpression[?In, ?Yield, ?Await] [+Yield] YieldExpression[?In, ?Await] ArrowFunction[?In, ?Yield, ?Await] AsyncArrowFunction[?In, ?Yield, ?Await] LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await] LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await] AssignmentOperator : one of *= /= %= += -= >= >>>= &= ^= |= **= 12.15.1 静态语义：Early Errors AssignmentExpression : LeftHandSideExpression = AssignmentExpression 如果LeftHandSideExpression是ObjectLiteral或ArrayLiteral，并且LeftHandSideExpression没有覆盖AssignmentPattern，则这是语法错误。 如果LeftHandSideExpression既不是ObjectLiteral也不是ArrayLiteral且LeftHandSideExpression的AssignmentTargetType是invalid，则这是早期参考错误。 如果LeftHandSideExpression既不是ObjectLiteral也不是ArrayLiteral且LeftHandSideExpression的AssignmentTargetType是strict，则这是早期的语法错误。 AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression 如果LeftHandSideExpression的AssignmentTargetType是invalid，则是早期参考错误。 如果LeftHandSideExpression的AssignmentTargetType是strict，则这是早期的语法错误。 12.15.2 静态语义：IsFunctionDefinition AssignmentExpression : ArrowFunction AsyncArrowFunction 返回 true. AssignmentExpression : YieldExpression LeftHandSideExpression = AssignmentExpression LeftHandSideExpression AssignmentOperator AssignmentExpression 返回 false 12.15.3 静态语义：AssignmentTargetType AssignmentExpression : YieldExpression ArrowFunction AsyncArrowFunction LeftHandSideExpression = AssignmentExpression LeftHandSideExpression AssignmentOperator AssignmentExpression 返回 invalid. 12.15.4 运行时语义：Evaluation AssignmentExpression : LeftHandSideExpression = AssignmentExpression 若 LeftHandSideExpression 不是 ObjectLiteral 或 ArrayLiteral, 那么 令 lref 为LeftHandSideExpression的运算结果 ReturnIfAbrupt(lref). 若 IsAnonymousFunctionDefinition(AssignmentExpression) 和 LeftHandSideExpression 的 IsIdentifierRef 都为 true, 那么 令 rval 为对带有参数GetReferencedName(lref) 的 AssignmentExpression 执行 NamedEvaluation 的结果 否则,1. 令 rref 为AssignmentExpression的运算结果 2. 令 rval 为 ? GetValue(rref). 执行 ? PutValue(lref, rval). 返回 rval. 令 assignmentPattern 为被 LeftHandSideExpression 覆盖的 AssignmentPattern。 令 rref 为AssignmentExpression的运算结果 令 rval 为 ? GetValue(rref). 执行 ? 使用rval作为参数的 assignmentPattern 的 DestructuringAssignmentEvaluation 返回 rval. AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression 令 lref 为LeftHandSideExpression的运算结果 令 lval 为 ? GetValue(lref). 令 rref 为AssignmentExpression的运算结果 令 rval 为 ? GetValue(rref). 令 op 为 @ ，其中 AssignmentOperator 是 @=. 令 r 为将op应用于lval和Rval的结果，就像计算表达式lval OP rval一样。 执行 ? PutValue(lref, r). 返回 r. 注意： 如果在严格模式代码中发生分配，则如果第一个算法的步骤1.f或第二个算法的步骤7中的lref是不可解析的引用，则是运行时错误。如果是，则抛出ReferenceError异常。LeftHandSideExpression也可能不是对属性值为{[[Writable]]：false的数据属性的引用，对属性值为{[[Set]]：undefined}的访问器属性的引用，也不是对不存在的引用IsExtensible谓词为其返回false值的对象的属性。在这些情况下，将引发TypeError异常。 12.15.5 解构赋值 补充语法 在某些情况下，当处理生产AssignmentExpression的实例时：LeftHandSideExpression = AssignmentExpression，以下语法用于完善LeftHandSideExpression的解释。 AssignmentPattern[Yield, Await] : ObjectAssignmentPattern[?Yield, ?Await] ArrayAssignmentPattern[?Yield, ?Await] ObjectAssignmentPattern[Yield, Await] : { } { AssignmentRestProperty[?Yield, ?Await] } { AssignmentPropertyList[?Yield, ?Await] } { AssignmentPropertyList[?Yield, ?Await] , AssignmentRestProperty[?Yield, ?Await] opt } ArrayAssignmentPattern[Yield, Await] : [ Elisionopt AssignmentRestElement[?Yield, ?Await] opt ] [ AssignmentElementList[?Yield, ?Await] ] [ AssignmentElementList[?Yield, ?Await] , Elisionopt AssignmentRestElement[?Yield, ?Await] opt ] AssignmentRestProperty[Yield, Await] : ... DestructuringAssignmentTarget[?Yield, ?Await] AssignmentPropertyList[Yield, Await] : AssignmentProperty[?Yield, ?Await] AssignmentPropertyList[?Yield, ?Await] , AssignmentProperty[?Yield, ?Await] AssignmentElementList[Yield, Await] : AssignmentElisionElement[?Yield, ?Await] AssignmentElementList[?Yield, ?Await] , AssignmentElisionElement[?Yield, ?Await] AssignmentElisionElement[Yield, Await] : Elisionopt AssignmentElement[?Yield, ?Await] AssignmentProperty[Yield, Await] : IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await] opt PropertyName[?Yield, ?Await] : AssignmentElement[?Yield, ?Await] AssignmentElement[Yield, Await] : DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await] opt AssignmentRestElement[Yield, Await] : ... DestructuringAssignmentTarget[?Yield, ?Await] DestructuringAssignmentTarget[Yield, Await] : LeftHandSideExpression[?Yield, ?Await] 12.15.5.1 静态语义：Early Errors AssignmentProperty : IdentifierReference Initializer 如果IdentifierReference的AssignmentTargetType不是simple，则是语法错误 AssignmentRestProperty : ... DestructuringAssignmentTarget 如果DestructuringAssignmentTarget是ArrayLiteral或ObjectLiteral，则为语法错误 DestructuringAssignmentTarget : LeftHandSideExpression 如果LeftHandSideExpression是ObjectLiteral或ArrayLiteral，并且LeftHandSideExpression没有覆盖AssignmentPattern，则它是语法错误。 如果LeftHandSideExpression既不是ObjectLiteral也不是ArrayLiteral，并且AssignmentTargetType（LeftHandSideExpression）不是simple，则会出现语法错误。 12.15.5.2 运行时语义：DestructuringAssignmentEvaluation 带参数value。 ObjectAssignmentPattern : { } 执行 ? RequireObjectCoercible(value). 返回 NormalCompletion(empty). ObjectAssignmentPattern : { AssignmentPropertyList } { AssignmentPropertyList , } 执行 ? RequireObjectCoercible(value). 执行 ? 使用value作为参数的AssignmentPropertyList 的 PropertyDestructuringAssignmentEvaluation 返回 NormalCompletion(empty). ArrayAssignmentPattern : [ ] 令 iteratorRecord 为 ? GetIterator(value). 返回 ? IteratorClose(iteratorRecord, NormalCompletion(empty)). ArrayAssignmentPattern : [ Elision ] 令 iteratorRecord 为 ? GetIterator(value). 令 result 为使用 iteratorRecord 作为参数执行 Elision 的 IteratorDestructuringAssignmentEvaluation结果。 若 iteratorRecord.[[Done]] 是 false, 返回 ? IteratorClose(iteratorRecord, result). 返回 result. ArrayAssignmentPattern : [ Elision AssignmentRestElement ] 令 iteratorRecord 为 ? GetIterator(value). 若 Elision 存在, 那么 令 status 为使用 iteratorRecord 作为参数执行 Elision 的 IteratorDestructuringAssignmentEvaluation结果。 若 status 是 abrupt completion, 那么 断言: iteratorRecord.[[Done]] 是 true. 返回 Completion(status). 令 result 为使用 iteratorRecord 作为参数执行 AssignmentRestElement 的 IteratorDestructuringAssignmentEvaluation结果。 若 iteratorRecord.[[Done]] 是 false, 返回 ? IteratorClose(iteratorRecord, result). 返回 result. ArrayAssignmentPattern : [ AssignmentElementList ] 令 iteratorRecord 为 ? GetIterator(value). 令 result 为使用 iteratorRecord 作为参数执行 AssignmentRestElement 的 IteratorDestructuringAssignmentEvaluation结果。 若 iteratorRecord.[[Done]] 是 false, 返回 ? IteratorClose(iteratorRecord, result). 返回 result ArrayAssignmentPattern : [ AssignmentElementList , Elision AssignmentRestElement ] 令 iteratorRecord 为 ? GetIterator(value). 令 status 为使用 iteratorRecord 作为参数执行 AssignmentRestElement 的 IteratorDestructuringAssignmentEvaluation结果。 若 status 是 an abrupt completion, 那么 若 iteratorRecord.[[Done]] 是 false, 返回 ? IteratorClose(iteratorRecord, status). 返回 Completion(status). 若 Elision 存在, 那么 设置 status 为使用 iteratorRecord 作为参数执行 Elision 的 IteratorDestructuringAssignmentEvaluation结果。 若 status 是 an abrupt completion, 那么 断言: iteratorRecord.[[Done]] 是 true. 返回 Completion(status). 若 AssignmentRestElement 存在, 那么 设置 status 为使用 iteratorRecord 作为参数执行 AssignmentRestElement 的 IteratorDestructuringAssignmentEvaluation结果。 若 iteratorRecord.[[Done]] 是 false, 返回 ? IteratorClose(iteratorRecord, status). 返回 Completion(status). ObjectAssignmentPattern : { AssignmentRestProperty } 执行 ? RequireObjectCoercible(value). 令 excludedNames 为一个新的空列表 返回以value和excludeedNames为参数执行AssignmentRestProperty的RestDestructuringAssignmentEvaluation的结果。 ObjectAssignmentPattern : { AssignmentPropertyList , AssignmentRestProperty } 执行 ? RequireObjectCoercible(value). 令 excludedNames 为执行 ? 使用value作为参数的AssignmentPropertyList的PropertyDestructuringAssignmentEvaluation的结果 返回以value和excludeedNames为参数执行AssignmentRestProperty的RestDestructuringAssignmentEvaluation的结果。 12.15.5.3 运行时语义：PropertyDestructuringAssignmentEvaluation 带参数value 注意 以下操作收集所有已解构的属性名称的列表。 AssignmentPropertyList : AssignmentPropertyList , AssignmentProperty 令 propertyNames 为执行 ? 使用value作为参数的AssignmentPropertyList的PropertyDestructuringAssignmentEvaluation的结果 令 nextNames 为 执行 ? 以value为参数执行AssignmentRestProperty的RestDestructuringAssignmentEvaluation的结果。 将nextNames中的每个项目追加到propertyNames的末尾。 返回 propertyNames. AssignmentProperty : IdentifierReference Initializer 令 P 为IdentifierReference的StringValue 令 lref 为 ? ResolveBinding(P). 令 v 为 ? GetV(value, P). 若 Initializeropt 存在，并且 v 是 undefined, 那么 若 IsAnonymousFunctionDefinition(Initializer) 是 true, 那么 设置 v 为对带有参数 P 的 Intializer 执行 NamedEvaluation 的结果。 否则, 令 defaultValue 为Initializer的运算结果 设置 v to ? GetValue(defaultValue). 执行 ? PutValue(lref, v). 返回包含P的新列表. AssignmentProperty : PropertyName : AssignmentElement 令 name 为PropertyName的运算结果 ReturnIfAbrupt(name). 执行 ? 以value和name为参数的AssignedElement的KeyedDestructuringAssignmentEvaluation。 返回包含name的新列表. 12.15.5.4 运行时语义：RestDestructuringAssignmentEvaluation 具有参数value和excludeedNames。 AssignmentRestProperty : ... DestructuringAssignmentTarget 令 lref 为DestructuringAssignmentTarget的运算结果 ReturnIfAbrupt(lref). 令 restObj 为 ObjectCreate(%ObjectPrototype%). 执行 ? CopyDataProperties(restObj, value, excludedNames). 返回 PutValue(lref, restObj) 12.15.5.5 运行时语义：IteratorDestructuringAssignmentEvaluation 使用参数iteratorRecord。 AssignmentElementList : AssignmentElisionElement 返回使用iteratorRecord作为参数执行AssignmentElisionElement的IteratorDestructuringAssignmentEvaluation的结果。 AssignmentElementList : AssignmentElementList , AssignmentElisionElement 执行 ? 使用iteratorRecord作为参数的AssignmentElementList的IteratorDestructuringAssignmentEvaluation。 返回使用iteratorRecord作为参数执行AssignmentElisionElement的IteratorDestructuringAssignmentEvaluation的结果。 AssignmentElisionElement : AssignmentElement 返回用 iteratorRecord 作为参数执行 AssignmentElement 的 IteratorDestructuringAssignmentEvaluation 的结果 AssignmentElisionElement : Elision AssignmentElement 执行 ? 以IteratorRecord作为参数的Elision的IteratorDestructuringAssignmentEvaluation。 返回用 iteratorRecord 作为参数执行 AssignmentElement 的 IteratorDestructuringAssignmentEvaluation 的结果 Elision : , 若 iteratorRecord.[[Done]] 是 false, 那么 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 返回 NormalCompletion(empty). Elision : Elision , 执行 ? 以IteratorRecord作为参数的Elision的IteratorDestructuringAssignmentEvaluation。 若 iteratorRecord.[[Done]] 是 false, 那么 a. 令 next 为 IteratorStep(iteratorRecord). b. 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. c. ReturnIfAbrupt(next). d. 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 返回 NormalCompletion(empty) AssignmentElement : DestructuringAssignmentTarget Initializer 若 DestructuringAssignmentTarget 不是 ObjectLiteral 或 ArrayLiteral, 那么 令 lref 为DestructuringAssignmentTarget的运算结果 ReturnIfAbrupt(lref). 若 iteratorRecord.[[Done]] 是 false, 那么 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 否则, 令 value 为 IteratorValue(next). 若 value 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(value). 若 iteratorRecord.[[Done]] 是 true, 令 value 为 undefined. 若 Initializer 存在，并且 value 是 undefined, 那么 若 IsAnonymousFunctionDefinition(Initializer) 和 DestructuringAssignmentTarget 的 IsIdentifierRef 都是 true, 那么 令 v 为使用GetReferencedName(lref)参数对Initializer执行NamedEvaluation的结果 否则, 令 defaultValue 为Initializer的运算结果 令 v 为 ? GetValue(defaultValue). 否则, 令 v 为 value. 若 DestructuringAssignmentTarget 是 ObjectLiteral 或 ArrayLiteral, 那么 令 nestedAssignmentPattern 为 AssignmentPattern，即是被 DestructuringAssignmentTarget 涵盖的。 返回以v为参数执行nestedAssignmentPattern的DestructuringAssignmentEvaluation的结果。 返回 ? PutValue(lref, v). 注意 在访问迭代器或执行初始化器之前，通过执行不是析构模式的DestructuringAssignmentTarget来保持从左到右的执行顺序。 AssignmentRestElement : ... DestructuringAssignmentTarget 若 DestructuringAssignmentTarget 不是 ObjectLiteral 或 ArrayLiteral, 那么 令 lref 为DestructuringAssignmentTarget的运算结果 ReturnIfAbrupt(lref). 令 A 为 ! ArrayCreate(0). 令 n 为 0. 重复, 当 iteratorRecord.[[Done]] 是 false, 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 否则, 令 nextValue 为 IteratorValue(next). 若 nextValue 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(nextValue). 令 status 为 CreateDataProperty(A, ! ToString(n), nextValue). 断言: status 是 true. n 增加 1. 若 DestructuringAssignmentTarget 不是 ObjectLiteral 或 ArrayLiteral, 那么 返回 ? PutValue(lref, A). 令 nestedAssignmentPattern 为 the AssignmentPattern，即是被 DestructuringAssignmentTarget 涵盖的 返回以A为参数执行nestedAssignmentPattern的DestructuringAssignmentEvaluation的结果。 12.15.5.6 运行时语义：KeyedDestructuringAssignmentEvaluation 具有参数value和propertyName。 AssignmentElement : DestructuringAssignmentTarget Initializer 若 DestructuringAssignmentTarget 不是 ObjectLiteral 或 ArrayLiteral, 那么 令 lref 为DestructuringAssignmentTarget的运算结果 ReturnIfAbrupt(lref). 令 v 为 ? GetV(value, propertyName). 若 Initializer 存在，并且 v 是 undefined, 那么 若 IsAnonymousFunctionDefinition(Initializer) 和 DestructuringAssignmentTarget 的 IsIdentifierRef 都为 true, 那么 令 rhsValue 为使用GetReferencedName(lref)参数对Initializer执行NamedEvaluation的结果。 否则, 令 defaultValue 为Initializer的运算结果 令 rhsValue 为 ? GetValue(defaultValue). 否则, 令 rhsValue 为 v. 若 DestructuringAssignmentTarget 是 ObjectLiteral 或 ArrayLiteral, 那么 令 assignmentPattern 为 the AssignmentPattern，即是被 DestructuringAssignmentTarget 涵盖的 返回使用rhsValue作为的执行DestructuringAssignmentEvaluation of AssignmentPattern的结果。 返回 ? PutValue(lref, rhsValue). 12.16 逗号运算符 语法 Expression[In, Yield, Await] : AssignmentExpression[?In, ?Yield, ?Await] Expression[?In, ?Yield, ?Await] , AssignmentExpression[?In, ?Yield, ?Await] 12.16.1 静态语义：IsFunctionDefinition Expression : Expression , AssignmentExpression 返回 false. 12.16.2 静态语义：AssignmentTargetType Expression : Expression , AssignmentExpression 返回 invalid. 12.16.3 运行时语义：Evaluation Expression : Expression , AssignmentExpression 令 lref 为Expression的运算结果 执行 ? GetValue(lref). 令 rref 为AssignmentExpression的运算结果 返回 ? GetValue(rref). 注意 即使没有使用GetValue，也必须调用它，因为它可能会有明显的副作用。 ECMAScript语言：表达式 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,expressions,ECMAScript语言：表达式 "},"statements-declarations.html":{"url":"statements-declarations.html","title":"13 ECMAScript语言：语句和声明","keywords":"","body":"13 ECMAScript语言：语句和声明 语法 Statement[Yield, Await, Return] : BlockStatement[?Yield, ?Await, ?Return] VariableStatement[?Yield, ?Await] EmptyStatement ExpressionStatement[?Yield, ?Await] IfStatement[?Yield, ?Await, ?Return] BreakableStatement[?Yield, ?Await, ?Return] ContinueStatement[?Yield, ?Await] BreakStatement[?Yield, ?Await] [+Return] ReturnStatement[?Yield, ?Await] WithStatement[?Yield, ?Await, ?Return] LabelledStatement[?Yield, ?Await, ?Return] ThrowStatement[?Yield, ?Await] TryStatement[?Yield, ?Await, ?Return] DebuggerStatement Declaration[Yield, Await] : HoistableDeclaration[?Yield, ?Await, ~Default] ClassDeclaration[?Yield, ?Await, ~Default] LexicalDeclaration[+In, ?Yield, ?Await] HoistableDeclaration[Yield, Await, Default] : FunctionDeclaration[?Yield, ?Await, ?Default] GeneratorDeclaration[?Yield, ?Await, ?Default] AsyncFunctionDeclaration[?Yield, ?Await, ?Default] AsyncGeneratorDeclaration[?Yield, ?Await, ?Default] BreakableStatement[Yield, Await, Return] : IterationStatement[?Yield, ?Await, ?Return] SwitchStatement[?Yield, ?Await, ?Return] 13.1 语句和声明 13.1.1 静态语义：ContainsDuplicateLabels 带有参数labelSet。 Statement : VariableStatement EmptyStatement ExpressionStatement ContinueStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement 返回 false. 13.1.2 静态语义：ContainsUndefinedBreakTarget 带有参数labelSet。 Statement: VariableStatement EmptyStatement ExpressionStatement ContinueStatement ReturnStatement ThrowStatement DebuggerStatement 返回 false. 13.1.3 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet。 Statement: VariableStatement EmptyStatement ExpressionStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement 返回 false. BreakableStatement:IterationStatement 令 newIterationSet 为附加了labelSet的所有元素的迭代集的副本。 返回包含带有参数newIterationSet和«»的IterationStatement的UndefinedContinueTarget。 13.1.4 静态语义：DeclarationPart HoistableDeclaration : FunctionDeclaration 返回 FunctionDeclaration. HoistableDeclaration : GeneratorDeclaration 返回 GeneratorDeclaration. HoistableDeclaration : AsyncFunctionDeclaration 返回 AsyncFunctionDeclaration. HoistableDeclaration : AsyncGeneratorDeclaration 返回 AsyncGeneratorDeclaration. Declaration : ClassDeclaration 返回 ClassDeclaration. Declaration : LexicalDeclaration 返回 LexicalDeclaration. 13.1.5 静态语义：VarDeclaredNames Statement : EmptyStatement ExpressionStatement ContinueStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement 返回一个新的空列表. 13.1.6 静态语义：VarScopedDeclarations Statement : EmptyStatement ExpressionStatement ContinueStatement BreakStatement ReturnStatement ThrowStatement DebuggerStatement 返回一个新的空列表. 13.1.7 运行时语义：LabelledEvaluation 使用参数 labelSet BreakableStatement:IterationStatement 令 stmtResult 为使用参数labelSet执行IterationStatement的LabelledEvaluation的结果 若 stmtResult.[[Type]] 是 break，那么 若 stmtResult.[[Target]] 是 empty，那么 若 stmtResult.[[Value]] 是 empty, 设置 stmtResult 为 NormalCompletion(undefined). 否则，设置 stmtResult 为 NormalCompletion(stmtResult.[[Value]]). 返回 Completion(stmtResult). BreakableStatement:SwitchStatement 令 stmtResult 为 SwitchStatement 的运算结果 若 stmtResult.[[Type]] 是 break，那么 若 stmtResult.[[Target]] 是 empty，那么 若 stmtResult.[[Value]] 是 empty, 设置 stmtResult 为 NormalCompletion(undefined). 否则，设置 stmtResult 为 NormalCompletion(stmtResult.[[Value]]). 返回 Completion(stmtResult). 注：BreakableStatement 是可以通过未标记的BreakStatement退出 13.1.8 运行时语义：Evaluation HoistableDeclaration : GeneratorDeclaration AsyncFunctionDeclaration AsyncGeneratorDeclaration 返回 NormalCompletion(empty). HoistableDeclaration : FunctionDeclaration 返回 FunctionDeclaration 的运算结果 BreakableStatement: IterationStatement SwitchStatement 令 newLabelSet 为一个新的空列表. 返回使用参数newLabelSet执行此BreakableStatement的LabelledEvaluation的结果 13.2 块 语法 BlockStatement[Yield, Await, Return] : Block[?Yield, ?Await, ?Return] Block[Yield, Await, Return] : { StatementList[?Yield, ?Await, ?Return] opt } StatementList[Yield, Await, Return] : StatementListItem[?Yield, ?Await, ?Return] StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return] StatementListItem[Yield, Await, Return] : Statement[?Yield, ?Await, ?Return] Declaration[?Yield, ?Await] 13.2.1 静态语义：Early Errors Block : { StatementList } 如果StatementList的LexicallyDeclaredNames包含任何重复的条目，则是语法错误。 如果StatementList的LexicallyDeclaredNames中的任何元素也出现在StatementList的VarDeclaredNames中，则是语法错误。 13.2.2 静态语义：ContainsDuplicateLabels 使用参数 labelSet Block : { } 返回 false. StatementList : StatementList StatementListItem 令 hasDuplicates 为带有参数labelSet的StatementList的ContainsDuplicateLabels。 若 hasDuplicates 是 true，返回 true. 返回带有参数labelSet的 StatementListItem 的ContainsDuplicateLabels。 StatementListItem : Declaration 返回 false. 13.2.3 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet Block : { } 返回 false. StatementList : StatementList StatementListItem 令 hasUndefinedLabels 为带有参数labelSet的StatementList的ContainsUndefinedBreakTarget。 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 labelSet 的 StatementListItem 的 ContainsUndefinedBreakTarget StatementListItem : Declaration 返回 false. 13.2.4 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet Block : { } 返回 false. StatementList : StatementList StatementListItem 令 hasUndefinedLabels 为带有参数 iterationSet 和 « » 的 StatementList 的 ContainsUndefinedContinueTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 iterationSet 和 « » 的 StatementListItem 的 ContainsUndefinedContinueTarget StatementListItem : Declaration 返回 false. 13.2.5 静态语义：LexicallyDeclaredNames Block : { } 返回一个新的空列表. StatementList : StatementList StatementListItem 令 names 为 StatementList 的 LexicallyDeclaredNames 在 names 后追加 StatementListItem 的 LexicallyDeclaredNames 的元素 返回 names. StatementListItem : Statement 若 Statement 是 Statement : LabelledStatement ，返回 LabelledStatement 的 LexicallyDeclaredNames 返回一个新的空列表. StatementListItem : Declaration 返回 Declaration 的 BoundNames 13.2.6 静态语义：LexicallyScopedDeclarations StatementList : StatementList StatementListItem 令 declarations 为 StatementList 的 LexicallyScopedDeclarations 在 declarations 后追加 StatementListItem 的 LexicallyScopedDeclarations 元素 返回 declarations. StatementListItem : Statement 若 Statement 是 Statement : LabelledStatement ，返回 LabelledStatement 的 LexicallyScopedDeclarations 返回一个新的空列表. StatementListItem : Declaration 返回包含 Declaration 的 DeclarationPart 的新列表 13.2.7 静态语义：TopLevelLexicallyDeclaredNames StatementList : StatementList StatementListItem 令 names 为 StatementList 的 TopLevelLexicallyDeclaredNames 在 names 后追加 StatementListItem 的 TopLevelLexicallyDeclaredNames 元素 返回 names. StatementListItem : Statement 返回一个新的空列表. StatementListItem : Declaration 若 Declaration 是 Declaration : HoistableDeclaration ，那么 返回 « ». 返回 Declaration 的 BoundNames 注：在函数或脚本的顶层，函数声明被视为var声明，而不是词法声明。 13.2.8 静态语义：TopLevelLexicallyScopedDeclarations Block : { } 返回一个新的空列表. StatementList : StatementList StatementListItem 令 declarations 为 StatementList 的 TopLevelLexicallyScopedDeclarations 在 declarations 后追加 StatementListItem 的 TopLevelLexicallyScopedDeclarations 元素 返回 declarations. StatementListItem : Statement 返回一个新的空列表. StatementListItem : Declaration 若 Declaration 是 Declaration : HoistableDeclaration ，那么 返回 « ». 返回包含 Declaration 的新列表 13.2.9 静态语义：TopLevelVarDeclaredNames Block : { } 返回一个新的空列表. StatementList : StatementList StatementListItem 令 names 为 StatementList 的 TopLevelVarDeclaredNames 在 names 后追加 StatementListItem 的 TopLevelVarDeclaredNames 元素 返回 names. StatementListItem : Declaration 若 Declaration 是 Declaration : HoistableDeclaration ，那么 返回 HoistableDeclaration 的 BoundNames 返回一个新的空列表. StatementListItem : Statement 若 Statement 是 Statement : LabelledStatement ，返回 Statement 的 TopLevelVarDeclaredNames 返回 Statement 的 VarDeclaredNames 注：在函数或脚本的顶层，内部函数声明被视为var声明。 13.2.10 静态语义：TopLevelVarScopedDeclarations Block : { } 返回一个新的空列表 StatementList : StatementList StatementListItem 令 declarations 为 StatementList 的 TopLevelVarScopedDeclarations 在 declarations 后追加 StatementListItem 的 TopLevelVarScopedDeclarations 元素 返回 declarations. StatementListItem : Statement 若 Statement 是 Statement : LabelledStatement ，返回 Statement 的 TopLevelVarScopedDeclarations 返回 Statement 的 VarScopedDeclarations StatementListItem : Declaration 若 Declaration 是 Declaration : HoistableDeclaration ，那么 令 declaration 为 HoistableDeclaration 的 DeclarationPart 返回 « declaration ». 返回一个新的空列表. 13.2.11 静态语义：VarDeclaredNames Block : { } 返回一个新的空列表. StatementList : StatementList StatementListItem 令 names 为 StatementList 的 VarDeclaredNames 在 names 后追加 StatementListItem 的 VarDeclaredNames 元素 返回 names. StatementListItem : Declaration 返回一个新的空列表. 13.2.12 静态语义：VarScopedDeclarations Block : { } 返回一个新的空列表. StatementList : StatementList StatementListItem 令 declarations 为 StatementList 的 VarScopedDeclarations 在 declarations 后追加 StatementListItem 的 VarScopedDeclarations 元素 返回 declarations. StatementListItem : Declaration 返回一个新的空列表. 13.2.13 运行时语义：Evaluation Block : { } 返回 NormalCompletion(empty) Block : { StatementList } 令 oldEnv 为运行时执行上下文的词法环境. 令 blockEnv 为 NewDeclarativeEnvironment(oldEnv). 执行 BlockDeclarationInstantiation(StatementList, blockEnv). 设置运行时执行上下文的词法环境 为 blockEnv. 令 blockValue 为 StatementList 的运算结果 设置运行时执行上下文的词法环境 为 oldEnv. 返回 blockValue. 注1：无论控制如何离开Block，词法环境总是恢复到原来的状态。 StatementList : StatementList StatementListItem 令 sl 为 StatementList 的运算结果 ReturnIfAbrupt(sl). 令 s 为 StatementListItem 的运算结果 返回 Completion(UpdateEmpty(s, sl)). 注2： StatementList的值是StatementList中最后一个值生成项的值。例如，对val函数的以下调用都返回值1： eval(\"1;;;;;\") eval(\"1;{}\") eval(\"1;var a;\") 13.2.14 运行时语义：BlockDeclarationInstantiation ( code, env ) 注：在计算块Block或CaseBlock时，将创建新的声明式环境记录，并在环境记录中实例化块中声明的每个块作用域变量、常量、函数或类的绑定。 BlockDeclarationInstantiation使用参数code和env执行如下。code是与块的主体相对应的Parse节点。Env是创建绑定的词汇环境。 令 envRec 为 env 的环境记录项. 断言: envRec 是声明环境记录项. 令 declarations 为 code 的 LexicallyScopedDeclarations 对于declarations中的元素d，执行 对于d的绑定名称中的元素d，执行 若 d 的 IsConstantDeclaration 是 true，那么 执行 ! envRec.CreateImmutableBinding(dn, true). 否则， 执行 ! envRec.CreateMutableBinding(dn, false). 若 d 是 FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, 或 AsyncGeneratorDeclaration，那么 令 fn 为 d 的绑定名称的唯一元素 令 fo 为使用参数env为d执行InstantiateFunctionObject的结果 执行 envRec.InitializeBinding(fn, fo). 13.3 声明和变量语句 13.3.1 Let 和 Const 声明 注：let 和 const 声明定义范围为运行时的执行上下文的词法环境的变量。实例化其包含的词法环境时创建了变量，但可能无法以任何方式对其进行访问直到运算变量的LexicalBinding。由带有初始化程序的LexicalBinding定义的变量被分配给在评估LexicalBinding时而不是在创建变量时，其初始化程序的AssignmentExpression的值。如果let声明中的LexicalBinding没有初始化程序，则在运算LexicalBinding时会为变量分配undefined的值。 语法 LexicalDeclaration[In, Yield, Await] : LetOrConst BindingList[?In, ?Yield, ?Await] ; LetOrConst : let const BindingList[In, Yield, Await] : LexicalBinding[?In, ?Yield, ?Await] BindingList[?In, ?Yield, ?Await] , LexicalBinding[?In, ?Yield, ?Await] LexicalBinding[In, Yield, Await] : BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await] opt BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await] 13.3.1.1 静态语义：Early Errors LexicalDeclaration : LetOrConst BindingList ; 如果BindingList的BoundNames包含“ let”，则是语法错误。 如果BindingList的BoundNames包含任何重复的条目，则是语法错误。 LexicalBinding : BindingIdentifier Initializer 如果没有初始化程序，并且包含此LexicalBinding的LexicalDeclaration的IsConstantDeclaration为true，则为语法错误。 13.3.1.2 静态语义：BoundNames LexicalDeclaration : LetOrConst BindingList ; 返回 BindingList 的 BoundNames BindingList : BindingList , LexicalBinding 令 names 为 BindingList 的 BoundNames 在 names 后追加 LexicalBinding 的 BoundNames 元素 返回 names LexicalBinding : BindingIdentifier Initializer 返回 BindingIdentifier 的 BoundNames LexicalBinding : BindingPattern Initializer 返回 BindingPattern 的 BoundNames 13.3.1.3 静态语义：IsConstantDeclaration LexicalDeclaration : LetOrConst BindingList ; 返回 LetOrConst 的 IsConstantDeclaration LetOrConst : let 返回 false LetOrConst : const 返回 true. 13.3.1.4 运行时语义：Evaluation LexicalDeclaration : LetOrConst BindingList ; 令 next 为 BindingList 的运算结果 ReturnIfAbrupt(next). 返回 NormalCompletion(empty). BindingList : BindingList , LexicalBinding 令 next 为 BindingList 的运算结果 ReturnIfAbrupt(next). 返回 LexicalBinding 的运算结果 LexicalBinding : BindingIdentifier 令 lhs 为 ResolveBinding(StringValue of BindingIdentifier). 返回 InitializeReferencedBinding(lhs, undefined). 注：静态语义规则确保LexicalBinding的这种形式永远不会在const声明中发生。 LexicalBinding : BindingIdentifier Initializer 令 bindingId 为 BindingIdentifier 的 StringValue 令 lhs 为 ResolveBinding(bindingId). 若 IsAnonymousFunctionDefinition(Initializer) 是 true，那么 令 value 为使用参数bindingId为Initializer执行NamedEvaluation的结果 否则， 令 rhs 为 Initializer 的运算结果 令 value 为 ? GetValue(rhs). 返回 InitializeReferencedBinding(lhs, value). LexicalBinding : BindingPattern Initializer 令 rhs 为 Initializer 的运算结果 令 value 为 ? GetValue(rhs). 令 env 为运行时执行上下文的词法环境. 返回使用value和env作为参数对BindingPattern执行BindingInitialization的结果 13.3.2 变量语句 注：var语句声明范围为运行时的执行上下文的VariableEnvironment的变量。 Var变量在实例化其包含的词法环境时创建，并在创建时初始化为undefined。在任何VariableEnvironment的范围内，一个公共的BindingIdentifier可能会出现在多个VariableDeclaration中，但是这些声明仅共同定义了一个变量。由VariableDeclaration与Initializer定义的变量在执行VariableDeclaration时（而不是在创建变量时）被分配其Initializer的AssignmentExpression的值。 语法 VariableStatement[Yield, Await] : var VariableDeclarationList[+In, ?Yield, ?Await] ; VariableDeclarationList[In, Yield, Await] : VariableDeclaration[?In, ?Yield, ?Await] VariableDeclarationList[?In, ?Yield, ?Await] , VariableDeclaration[?In, ?Yield, ?Await] VariableDeclaration[In, Yield, Await] : BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await] opt BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await] 13.3.2.1 静态语义：BoundNames VariableDeclarationList : VariableDeclarationList , VariableDeclaration 令 names 为 VariableDeclarationList 的 BoundNames 在 names 后追加 VariableDeclaration 的 BoundNames 元素 返回 names. VariableDeclaration : BindingIdentifier Initializer 返回 BindingIdentifier 的 BoundNames VariableDeclaration : BindingPattern Initializer 返回 BindingPattern 的 BoundNames 13.3.2.2 静态语义：VarDeclaredNames VariableStatement : var VariableDeclarationList ; 返回 VariableDeclarationList 的 BoundNames 13.3.2.3 静态语义：VarScopedDeclarations VariableDeclarationList : VariableDeclaration 返回包含 VariableDeclaration. 的新列表 VariableDeclarationList : VariableDeclarationList , VariableDeclaration 令 declarations 为 VariableDeclarationList 的 VarScopedDeclarations 将VariableDeclaration追加到declarations. 返回 declarations. 13.3.2.4 运行时语义：Evaluation VariableStatement : var VariableDeclarationList ; 令 next 为 VariableDeclarationList 的运算结果 ReturnIfAbrupt(next). 返回 NormalCompletion(empty) VariableDeclarationList : VariableDeclarationList , VariableDeclaration 令 next 为 VariableDeclarationList 的运算结果 ReturnIfAbrupt(next). 返回 evaluating VariableDeclaration 的结果 VariableDeclaration : BindingIdentifier 返回 NormalCompletion(empty). VariableDeclaration : BindingIdentifier Initializer 令 bindingId 为 BindingIdentifier 的 StringValue 令 lhs 为 ? ResolveBinding(bindingId). 若 IsAnonymousFunctionDefinition(Initializer) 是 true，那么 a. 令 value 为使用参数bindingId为Initializer执行NamedEvaluation的结果 否则， a. 令 rhs 为 Initializer 的运算结果 b. 令 value 为 ? GetValue(rhs). 返回 ? PutValue(lhs, value). 注：如果VariableDeclaration嵌套在with语句中，并且VariableDeclaration中的BindingIdentifier与with语句的对象Environment Record的绑定对象的属性名称相同，则第6步将为该属性分配值，而不是分配给VariableEnvironment绑定标识符的 VariableDeclaration : BindingPattern Initializer 令 rhs 为 Initializer 的运算结果 令 rval 为 ? GetValue(rhs). 返回为传递rval和undefined为参数的BindingPattern执行BindingInitialization的结果 13.3.3 绑定模式解构 语法 BindingPattern[Yield, Await] : ObjectBindingPattern[?Yield, ?Await] ArrayBindingPattern[?Yield, ?Await] ObjectBindingPattern[Yield, Await] : { } { BindingRestProperty[?Yield, ?Await] } { BindingPropertyList[?Yield, ?Await] } { BindingPropertyList[?Yield, ?Await] , BindingRestProperty[?Yield, ?Await] opt } ArrayBindingPattern[Yield, Await] : [ Elisionopt BindingRestElement[?Yield, ?Await] opt ] [ BindingElementList[?Yield, ?Await] ] [ BindingElementList[?Yield, ?Await] , Elisionopt BindingRestElement[?Yield, ?Await] opt ] BindingRestProperty[Yield, Await] : ... BindingIdentifier[?Yield, ?Await] BindingPropertyList[Yield, Await] : BindingProperty[?Yield, ?Await] BindingPropertyList[?Yield, ?Await] , BindingProperty[?Yield, ?Await] BindingElementList[Yield, Await] : BindingElisionElement[?Yield, ?Await] BindingElementList[?Yield, ?Await] , BindingElisionElement[?Yield, ?Await] BindingElisionElement[Yield, Await] : Elisionopt BindingElement[?Yield, ?Await] BindingProperty[Yield, Await] : SingleNameBinding[?Yield, ?Await] PropertyName[?Yield, ?Await] : BindingElement[?Yield, ?Await] BindingElement[Yield, Await] : SingleNameBinding[?Yield, ?Await] BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await] opt SingleNameBinding[Yield, Await] : BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await] opt BindingRestElement[Yield, Await] : ... BindingIdentifier[?Yield, ?Await] ... BindingPattern[?Yield, ?Await] 13.3.3.1 静态语义：BoundNames ObjectBindingPattern : { } 返回一个新的空列表. ArrayBindingPattern : [ Elision ] 返回一个新的空列表. ArrayBindingPattern : [ Elision BindingRestElement ] 返回 BindingRestElement 的 BoundNames ArrayBindingPattern : [ BindingElementList , Elision ] 返回 BindingElementList 的 BoundNames ArrayBindingPattern : [ BindingElementList , Elision BindingRestElement ] 令 names 为 BindingElementList 的 BoundNames 在 names 后追加 BindingRestElement 的 BoundNames 元素 返回 names. BindingPropertyList : BindingPropertyList , BindingProperty 令 names 为 BindingPropertyList 的 BoundNames 在 names 后追加 BindingProperty 的 BoundNames 元素 返回 names. BindingElementList : BindingElementList , BindingElisionElement 令 names 为 BindingElementList 的 BoundNames 在 names 后追加 BindingElisionElement 的 BoundNames 元素 返回 names. BindingElisionElement : Elision BindingElement 返回 BindingElement 的 BoundNames BindingProperty : PropertyName : BindingElement 返回 BindingElement 的 BoundNames SingleNameBinding : BindingIdentifier Initializer 返回 BindingIdentifier 的 BoundNames BindingElement : BindingPattern Initializer 返回 BindingPattern 的 BoundNames 13.3.3.2 静态语义：ContainsExpression ObjectBindingPattern : { } 返回 false. ArrayBindingPattern : [ Elision ] 返回 false. ArrayBindingPattern : [ Elision BindingRestElement ] 返回 BindingRestElement 的 ContainsExpression ArrayBindingPattern : [ BindingElementList , Elision ] 返回 BindingElementList 的 ContainsExpression ArrayBindingPattern : [ BindingElementList , Elision BindingRestElement ] 令 has 为 BindingElementList 的 ContainsExpression 若 has 是 true，返回 true. 返回 BindingRestElement 的 ContainsExpression BindingPropertyList : BindingPropertyList , BindingProperty 令 has 为 BindingPropertyList 的 ContainsExpression 若 has 是 true，返回 true. 返回 BindingProperty 的 ContainsExpression BindingElementList : BindingElementList , BindingElisionElement 令 has 为 BindingElementList 的 ContainsExpression 若 has 是 true，返回 true. 返回 BindingElisionElement 的 ContainsExpression BindingElisionElement : Elision BindingElement 返回 BindingElement 的 ContainsExpression BindingProperty : PropertyName : BindingElement 令 has 为 PropertyName 的 IsComputedPropertyKey 若 has 是 true，返回 true. 返回 BindingElement 的 ContainsExpression BindingElement : BindingPattern Initializer 返回 true. SingleNameBinding : BindingIdentifier 返回 false. SingleNameBinding : BindingIdentifier Initializer 返回 true. BindingRestElement : ... BindingIdentifier 返回 false. BindingRestElement : ... BindingPattern 返回 BindingPattern 的 ContainsExpression 13.3.3.3 静态语义：HasInitializer BindingElement : BindingPattern 返回 false BindingElement : BindingPattern Initializer 返回 true. SingleNameBinding : BindingIdentifier 返回 false. SingleNameBinding : BindingIdentifier Initializer 返回 true. 13.3.3.4 静态语义：IsSimpleParameterList BindingElement : BindingPattern 返回 false. BindingElement : BindingPattern Initializer 返回 false. SingleNameBinding : BindingIdentifier 返回 true SingleNameBinding : BindingIdentifier Initializer 返回 false. 13.3.3.5 运行时语义：BindingInitialization 使用参数value和environment 注：当为环境传递undefined时，表明应该使用PutValue操作来分配初始化值。非严格函数的形式参数列表就是这种情况。在那种情况下，形式参数绑定是预先初始化的，以便处理多个具有相同名称的参数的可能性。 BindingPattern : ObjectBindingPattern 执行 ? RequireObjectCoercible(value). 返回使用value和environment作为参数对ObjectBindingPattern执行BindingInitialization的结果 BindingPattern : ArrayBindingPattern 令 iteratorRecord 为 ? GetIterator(value). 令 result 为使用iteratorRecord和环境作为参数的ArrayBindingPattern的IteratorBindingInitialization。 若 iteratorRecord.[[Done]] 是 false，返回 ? IteratorClose(iteratorRecord, result). 返回 result. ObjectBindingPattern : { } 返回 NormalCompletion(empty) ObjectBindingPattern : { BindingPropertyList } { BindingPropertyList , } 执行 ? 使用value和environment作为参数的BindingPropertyList的PropertyBindingInitialization。 返回 NormalCompletion(empty). ObjectBindingPattern : { BindingRestProperty } 令 excludedNames 为一个新的空列表. 返回使用value，environment和excludeedNames作为参数执行BindingRestProperty的RestBindingInitialization的结果 ObjectBindingPattern : { BindingPropertyList , BindingRestProperty } 令 excludedNames 为 执行 ? 使用value和environment作为参数的BindingPropertyList的PropertyBindingInitialization的结果 返回以value，environment和excludeedNames作为参数执行BindingRestProperty的初始化的结果 13.3.3.6 运行时语义：PropertyBindingInitialization 使用参数value和environment 注：它们收集所有绑定属性名称的列表，而不仅仅是空完成。 BindingPropertyList : BindingPropertyList , BindingProperty 令 boundNames 为 执行 ? 使用value和environment作为参数的BindingPropertyList的PropertyBindingInitialization。 令 nextNames 为 执行 ? 使用value和environment作为参数的BindingProperty的PropertyBindingInitialization。 将nextNames中的每一个项目追加到 boundNames 的末尾 返回 boundNames. BindingProperty : SingleNameBinding 令 name 为 string，即是SingleNameBinding 的 BoundNames的唯一元素 执行 ? 使用value和environment和name作为参数的SingleNameBinding的KeyedBindingInitialization。 返回包含 name 的新列表 BindingProperty : PropertyName : BindingElement 令 P 为 PropertyName 的运算结果 ReturnIfAbrupt(P). 执行 ? 以value、environment和P作为参数的BindingElement的KeyedBindingInitialization。 返回包含 P 的新列表 13.3.3.7 运行时语义：RestBindingInitialization 使用参数value, environment和excludedNames BindingRestProperty : ... BindingIdentifier 令 lhs 为 ? ResolveBinding(StringValue of BindingIdentifier, environment). 令 restObj 为 ObjectCreate(%ObjectPrototype%). 执行 ? CopyDataProperties(restObj, value, excludedNames). 若 environment 是 undefined，返回 PutValue(lhs, restObj). 返回 InitializeReferencedBinding(lhs, restObj). 13.3.3.8 运行时语义：IteratorBindingInitialization 使用参数iteratorRecord和environment 注：当为环境传递undefined时，表明应该使用PutValue操作来分配初始化值。非严格函数的形式参数列表就是这种情况。在那种情况下，形式参数绑定是预先初始化的，以便处理多个具有相同名称的参数的可能性。 ArrayBindingPattern : [ ] 返回 NormalCompletion(empty). ArrayBindingPattern : [ Elision ] 返回以iteratorRecord作为参数执行Elision的IteratorDestructuringAssignmentEvaluation的结果 ArrayBindingPattern : [ Elision BindingRestElement ] 若 Elision 存在，那么 执行 ? 以iteratorRecord作为参数的Elision的IteratorDestructuringAssignmentEvaluation 返回使用iteratorRecord和environment作为参数对BindingRestElement执行IteratorBindingInitialization的结果 ArrayBindingPattern : [ BindingElementList ] 返回使用iteratorRecord和environment作为参数对BindingElementList执行IteratorBindingInitialization的结果。 ArrayBindingPattern : [ BindingElementList , ] 返回使用iteratorRecord和environment作为参数对BindingElementList执行IteratorBindingInitialization的结果 ArrayBindingPattern : [ BindingElementList , Elision ] 执行 ? 带有IteratorRecord和environment作为参数的BindingElementList的IteratorBindingInitialization。 返回以iteratorRecord作为参数执行Elision的IteratorDestructuringAssignmentEvaluation的结果 ArrayBindingPattern : [ BindingElementList , Elision BindingRestElement ] 执行 ? 带有IteratorRecord和environment作为参数的BindingElementList的IteratorBindingInitialization。 若 Elision 存在，那么 执行 ? 以iteratorRecord作为参数的Elision的IteratorDestructuringAssignmentEvaluation 返回使用iteratorRecord和environment环境作为参数对BindingRestElement执行IteratorBindingInitialization的结果 BindingElementList : BindingElisionElement 返回使用iteratorRecord和environment环境作为参数对BindingElisionElement执行IteratorBindingInitialization的结果 BindingElementList : BindingElementList , BindingElisionElement 执行 ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments. 返回使用iteratorRecord和environment作为参数对BindingElisionElement执行IteratorBindingInitialization的结果 BindingElisionElement : BindingElement 返回使用iteratorRecord和environment作为参数执行BindingElement的IteratorBindingInitialization。 BindingElisionElement : Elision BindingElement 执行 ? 以iteratorRecord作为参数的Elision的IteratorDestructuringAssignmentEvaluation 返回使用iteratorRecord和environment作为参数执行BindingElement的IteratorBindingInitialization的结果 BindingElement : SingleNameBinding 返回使用iteratorRecord和环境作为参数对SingleNameBinding执行IteratorBindingInitialization的结果 SingleNameBinding : BindingIdentifier Initializer 令 bindingId 为 BindingIdentifier 的 StringValue 令 lhs 为 ? ResolveBinding(bindingId, environment). 若 iteratorRecord.[[Done]] 是 false，那么 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 否则， 令 v 为 IteratorValue(next). 若 v 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(v). 若 iteratorRecord.[[Done]] 是 true, 令 v 为 undefined. 若 Initializer 存在 并且 v 是 undefined，那么 若 IsAnonymousFunctionDefinition(Initializer) 是 true，那么 设置 v 为使用参数bindingId为Initializer执行NamedEvaluation的结果 否则， 令 defaultValue 为 Initializer 的运算结果 设置 v 为 ? GetValue(defaultValue). 若 environment 是 undefined，返回 ? PutValue(lhs, v). 返回 InitializeReferencedBinding(lhs, v). BindingElement : BindingPattern Initializer 若 iteratorRecord.[[Done]] 是 false，那么 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 否则， 令 v 为 IteratorValue(next). 若 v 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(v). 若 iteratorRecord.[[Done]] 是 true, 令 v 为 undefined. 若 Initializer 存在 并且 v 是 undefined，那么 令 defaultValue 为 Initializer 的运算结果 设置 v 为 ? GetValue(defaultValue). 返回使用v和environment作为参数执行BindingPattern的BindingInitialization的结果 BindingRestElement : ... BindingIdentifier 令 lhs 为 ? ResolveBinding(StringValue of BindingIdentifier, environment). 令 A 为 ! ArrayCreate(0). 令 n 为 0. 重复， 若 iteratorRecord.[[Done]] 是 false，那么 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 若 iteratorRecord.[[Done]] 是 true，那么 若 environment 是 undefined，返回 ? PutValue(lhs, A). 返回 InitializeReferencedBinding(lhs, A). 令 nextValue 为 IteratorValue(next). 若 nextValue 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(nextValue). 令 status 为 CreateDataProperty(A, ! ToString(n), nextValue). 断言: status 是 true. n增加1. BindingRestElement : ... BindingPattern 令 A 为 ! ArrayCreate(0). 令 n 为 0. 重复， 若 iteratorRecord.[[Done]] 是 false，那么 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 若 iteratorRecord.[[Done]] 是 true，那么 使用A和environment作为参数执行BindingPattern的BindingInitialization的结果。 令 nextValue 为 IteratorValue(next). 若 nextValue 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(nextValue). 令 status 为 CreateDataProperty(A, ! ToString(n), nextValue). 断言: status 是 true. n增加1. 13.3.3.9 运行时语义：KeyedBindingInitialization 使用参数value, environment,和propertyName 注：当为环境传递undefined时，表明应该使用PutValue操作来分配初始化值。非严格函数的形式参数列表就是这种情况。在那种情况下，形式参数绑定是预先初始化的，以便处理多个具有相同名称的参数的可能性。 BindingElement : BindingPattern Initializer 令 v 为 ? GetV(value, propertyName). 若 Initializer 存在，并且 v 是 undefined，那么 令 defaultValue 为 Initializer 的运算结果 设置 v 为 ? GetValue(defaultValue). 返回通过将v和environment作为参数对BindingPattern执行BindingInitialization的结果 SingleNameBinding : BindingIdentifier Initializer 令 bindingId 为 BindingIdentifier 的 StringValue 令 lhs 为 ? ResolveBinding(bindingId, environment). 令 v 为 ? GetV(value, propertyName). 若 Initializer 存在，并且 v 是 undefined，那么 若 IsAnonymousFunctionDefinition(Initializer) 是 true，那么 设置 v 为使用参数bindingId为Initializer执行NamedEvaluation的结果 否则， 令 defaultValue 为 Initializer 的运算结果 设置 v 为 ? GetValue(defaultValue). 若 environment 是 undefined，返回 ? PutValue(lhs, v). 返回 InitializeReferencedBinding(lhs, v). 13.4 空语句 语法 EmptyStatement : ; 13.4.1 运行时语义：Evaluation EmptyStatement : ; 返回 NormalCompletion(empty). 13.5 表达式语句 语法 ExpressionStatement[Yield, Await] : [lookahead ∉ { { , function , async [no LineTerminator here] function , class , let [ }] Expression[+In, ?Yield, ?Await] ; 注：ExpressionStatement不能以U+007B（{）开头，因为这可能会使它与Block产生歧义。 ExpressionStatement不能以function或class关键字开头，因为这会使它与FunctionDeclaration，GeneratorDeclaration或ClassDeclaration产生歧义。 ExpressionStatement不能以异步函数开头，因为这会使它与AsyncFunctionDeclaration或AsyncGeneratorDeclaration产生歧义。 ExpressionStatement不能以两个令牌序列let [开头，因为这会使它与let LexicalDeclaration产生歧义，后者的第一个LexicalBinding是ArrayBindingPattern。 13.5.1 运行时语义：Evaluation ExpressionStatement : Expression ; 令 exprRef 为 Expression 的运算结果 返回 ? GetValue(exprRef). 13.6 if 语句 语法 IfStatement[Yield, Await, Return] : if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] else Statement[?Yield, ?Await, ?Return] if ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] 如果相关 if 的选择不明确，则每个 else 应与最接近的 if 相关联，否则该 if 没有相应的 else 13.6.1 静态语义：Early Errors IfStatement : if ( Expression ) Statement else Statement if ( Expression ) Statement 如果 IsLabelled 函数（语句）为 true，则出现语法错误 注：仅当实现了 B.3.2 中指定的扩展时，才需要应用此规则。 13.6.2 静态语义：ContainsDuplicateLabels 使用参数 labelSet IfStatement : if ( Expression ) Statement else Statement 令 hasDuplicate 为包含第一个带有参数labelSet的Statement的DuplicateLabels。 若 hasDuplicate 是 true，返回 true. 返回包含第二个带有参数labelSet的Statement的DuplicateLabel。 IfStatement : if ( Expression ) Statement 返回带有参数 labelSet 的 Statement 的 ContainsDuplicateLabels 13.6.3 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet IfStatement : if ( Expression ) Statement else Statement 令 hasUndefinedLabels 为包含参数labelSet的第一个语句的ContainsUndefinedBreakTarget。 若 hasUndefinedLabels 是 true，返回 true. 返回包含第二个带有参数labelSet的语句的UndefinedBreakTarget。 IfStatement : if ( Expression ) Statement 返回带有参数 labelSet 的 Statement 的 ContainsUndefinedBreakTarget 13.6.4 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet IfStatement : if ( Expression ) Statement else Statement 令 hasUndefinedLabels 为包含第一个Statement的UndefinedContinueTarget，其参数为iterationSet和«»。 若 hasUndefinedLabels 是 true，返回 true. 返回包含第二个Statement的UndefinedContinueTarget，其参数为iterationSet和«»。 IfStatement : if ( Expression ) Statement 返回带有参数 iterationSet 和 « » 的 Statement 的 ContainsUndefinedContinueTarget 13.6.5 静态语义：VarDeclaredNames IfStatement : if ( Expression ) Statement else Statement 令 names 为第一条语句的VarDeclaredNames。 在 names 后追加第一条语句的VarDeclaredNames的元素 返回 names. IfStatement : if ( Expression ) Statement 返回 Statement 的 VarDeclaredNames 13.6.6 静态语义：VarScopedDeclarations IfStatement : if ( Expression ) Statement else Statement 令 declarations 为第一条语句的VarScopedDeclarations。 在 declarations 后追加第二条语句的VarScopedDeclarations的元素 返回 declarations. IfStatement : if ( Expression ) Statement 返回 Statement 的 VarScopedDeclarations 13.6.7 运行时语义：Evaluation IfStatement : if ( Expression ) Statement else Statement 令 exprRef 为 Expression 的运算结果 令 exprValue 为 ToBoolean(? GetValue(exprRef)). 若 exprValue 是 true，那么 a. 令 stmtCompletion 为第一条语句的运算结果 否则， a. 令 stmtCompletion 为第二条语句的运算结果 返回 Completion(UpdateEmpty(stmtCompletion, undefined)) IfStatement : if ( Expression ) Statement 令 exprRef 为 Expression 的运算结果 令 exprValue 为 ToBoolean(? GetValue(exprRef)). 若 exprValue 是 false，那么 a. 返回 NormalCompletion(undefined). 否则， a. 令 stmtCompletion 为 Statement 的运算结果 b. 返回 Completion(UpdateEmpty(stmtCompletion, undefined)). 13.7 迭代语句 语法 IterationStatement[Yield, Await, Return] : do Statement[?Yield, ?Await, ?Return] while ( Expression[+In, ?Yield, ?Await] ) ; while ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] for ( [lookahead ∉ { let [ }] Expression[~In, ?Yield, ?Await] opt ; Expression[+In, ?Yield, ?Await] opt ; Expression[+In, ?Yield, ?Await] opt ) Statement[?Yield, ?Await, ?Return] for ( var VariableDeclarationList[~In, ?Yield, ?Await] ; Expression[+In, ?Yield, ?Await] opt ; Expression[+In, ?Yield, ?Await] opt ) Statement[?Yield, ?Await, ?Return] for ( LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await] opt ; Expression[+In, ?Yield, ?Await] opt ) Statement[?Yield, ?Await, ?Return] for ( [lookahead ∉ { let [ }] LeftHandSideExpression[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] for ( var ForBinding[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] for ( ForDeclaration[?Yield, ?Await] in Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] for ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] for ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] for ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] [+Await] for await ( [lookahead ≠ let] LeftHandSideExpression[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] [+Await] for await ( var ForBinding[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] [+Await] for await ( ForDeclaration[?Yield, ?Await] of AssignmentExpression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] ForDeclaration[Yield, Await] : LetOrConst ForBinding[?Yield, ?Await] ForBinding[Yield, Await] : BindingIdentifier[?Yield, ?Await] BindingPattern[?Yield, ?Await] 注：本节由附录B.3.6扩展。 13.7.1 语义 13.7.1.1 静态语义：Early Errors IterationStatement : do Statement while ( Expression ) ; while ( Expression ) Statement for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement for ( LeftHandSideExpression in Expression ) Statement for ( var ForBinding in Expression ) Statement for ( ForDeclaration in Expression ) Statement for ( LeftHandSideExpression of AssignmentExpression ) Statement for ( var ForBinding of AssignmentExpression ) Statement for ( ForDeclaration of AssignmentExpression ) Statement for await ( LeftHandSideExpression of AssignmentExpression ) Statement for await ( var ForBinding of AssignmentExpression ) Statement for await ( ForDeclaration of AssignmentExpression ) Statement It 是 a Syntax Error if IsLabelledFunction(Statement) 是 true. 注：本节由附录B.3.6扩展。仅当实施了B.3.2中指定的扩展时，才需要应用此规则。 13.7.1.2 运行时语义：LoopContinues ( completion, labelSet ) 通过以下步骤定义带有参数完成和labelSet的抽象操作LoopContinues： 若 completion.[[Type]] 是 normal，返回 true. 若 completion.[[Type]] 不是 continue，返回 false. 若 completion.[[Target]] 是 empty，返回 true. 若 completion.[[Target]] 是labelSet的元素，返回 true. 返回 false. 注：在IterationStatement的Statement部分内，可以使用ContinueStatement开始新的迭代。 13.7.2 do-while 语句 13.7.2.1 静态语义：ContainsDuplicateLabels 使用参数 labelSet IterationStatement : do Statement while ( Expression ) ; 返回带有参数 labelSet 的 Statement 的 ContainsDuplicateLabels 13.7.2.2 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet IterationStatement : do Statement while ( Expression ) ; 返回带有参数 labelSet 的 Statement 的 ContainsUndefinedBreakTarget 13.7.2.3 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet IterationStatement : do Statement while ( Expression ) ; 返回带有参数 iterationSet 和 « » 的 Statement 的 ContainsUndefinedContinueTarget 13.7.2.4 静态语义：VarDeclaredNames IterationStatement : do Statement while ( Expression ) ; 返回 Statement 的 VarDeclaredNames 13.7.2.5 静态语义：VarScopedDeclarations IterationStatement : do Statement while ( Expression ) ; 返回 Statement 的 VarScopedDeclarations 13.7.2.6 运行时语义：LabelledEvaluation 使用参数 labelSet IterationStatement : do Statement while ( Expression ) ; 令 V 为 undefined. 重复， 令 stmtResult 为 Statement 的运算结果 若 LoopContinues(stmtResult, labelSet) 是 false，返回 Completion(UpdateEmpty(stmtResult, V)). 若 stmtResult.[[Value]] 不是 empty, 设置 V 为 stmtResult.[[Value]]. 令 exprRef 为 Expression 的运算结果 令 exprValue 为 ? GetValue(exprRef). 若 ToBoolean(exprValue) 是 false，返回 NormalCompletion(V). 13.7.3 while 语句 13.7.3.1 静态语义：ContainsDuplicateLabels 使用参数 labelSet IterationStatement : while ( Expression ) Statement 返回带有参数 labelSet 的 Statement 的 ContainsDuplicateLabels 13.7.3.2 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet IterationStatement : while ( Expression ) Statement 返回带有参数 labelSet 的 Statement 的 ContainsUndefinedBreakTarget 13.7.3.3 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet IterationStatement : while ( Expression ) Statement 返回带有参数 iterationSet 和 « » 的 Statement 的 ContainsUndefinedContinueTarget 13.7.3.4 静态语义：VarDeclaredNames IterationStatement : while ( Expression ) Statement 返回 Statement 的 VarDeclaredNames 13.7.3.5 静态语义：VarScopedDeclarations IterationStatement : while ( Expression ) Statement 返回 Statement 的 VarScopedDeclarations 13.7.3.6 运行时语义：LabelledEvaluation 使用参数 labelSet IterationStatement : while ( Expression ) Statement 令 V 为 undefined. 重复， 令 exprRef 为 Expression 的运算结果 令 exprValue 为 ? GetValue(exprRef). 若 ToBoolean(exprValue) 是 false，返回 NormalCompletion(V). 令 stmtResult 为 Statement 的运算结果 若 LoopContinues(stmtResult, labelSet) 是 false，返回 Completion(UpdateEmpty(stmtResult, V)). 若 stmtResult.[[Value]] 不是 empty, 设置 V 为 stmtResult.[[Value]]. 13.7.4 for 语句 13.7.4.1 静态语义：Early Errors IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement 如果LexicalDeclaration的BoundNames的任何元素也出现在语句的VarDeclaredNames中，则是语法错误 13.7.4.2 静态语义：ContainsDuplicateLabels 使用参数 labelSet IterationStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement 返回带有参数 labelSet 的 Statement 的 ContainsDuplicateLabels 13.7.4.3 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet IterationStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement 返回包含带有参数labelSet的语句的ContainsUndefinedBreakTarget。 13.7.4.4 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet IterationStatement : for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement 返回带有参数 iterationSet 和 « » 的 Statement 的 ContainsUndefinedContinueTarget 13.7.4.5 静态语义：VarDeclaredNames IterationStatement : for ( Expression ; Expression ; Expression ) Statement 返回 Statement 的 VarDeclaredNames IterationStatement : for ( var VariableDeclarationList ; Expression ; Expression ) Statement 令 names 为 VariableDeclarationList 的 BoundNames 在 names 后追加 Statement 的 VarDeclaredNames 元素 返回 names. IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement 返回 Statement 的 VarDeclaredNames 13.7.4.6 静态语义：VarScopedDeclarations IterationStatement : for ( Expression ; Expression ; Expression ) Statement 返回 Statement 的 VarScopedDeclarations IterationStatement : for ( var VariableDeclarationList ; Expression ; Expression ) Statement 令 declarations 为 VariableDeclarationList 的 VarScopedDeclarations 在 declarations 后追加 Statement 的 VarScopedDeclarations 元素 返回 declarations. IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement 返回 Statement 的 VarScopedDeclarations 13.7.4.7 运行时语义：LabelledEvaluation 使用参数 labelSet IterationStatement : for ( Expression ; Expression ; Expression ) Statement 若 the first Expression 存在，那么 令 exprRef 为 the first Expression 的运算结果 执行 ? GetValue(exprRef). 返回 ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet). IterationStatement : for ( var VariableDeclarationList ; Expression ; Expression ) Statement 令 varDcl 为 VariableDeclarationList 的运算结果 ReturnIfAbrupt(varDcl). 返回 ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet). IterationStatement : for ( LexicalDeclaration Expression ; Expression ) Statement 令 oldEnv 为运行时执行上下文的词法环境. 令 loopEnv 为 NewDeclarativeEnvironment(oldEnv). 令 loopEnvRec 为 loopEnv 的环境记录项 令 isConst 为 执行 LexicalDeclaration 的 IsConstantDeclaration 的结果 令 boundNames 为 LexicalDeclaration 的 BoundNames 对于每一个 boundNames 的 dn 元素, 执行 若 isConst 是 true，那么 执行 ! loopEnvRec.CreateImmutableBinding(dn, true). 否则， 执行 ! loopEnvRec.CreateMutableBinding(dn, false). 设置运行时执行上下文的词法环境 为 loopEnv. 令 forDcl 为 LexicalDeclaration 的运算结果 若 forDcl 是 abrupt completion，那么 设置运行时执行上下文的词法环境 为 oldEnv. 返回 Completion(forDcl). 若 isConst 是 false, 令 perIterationLets 为 boundNames; 否则令 perIterationLets 为 « ». 令 bodyResult 为 ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet). 设置运行时执行上下文的词法环境 为 oldEnv. 返回 Completion(bodyResult) 13.7.4.8 运行时语义：ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet ) 带有参数test，increment，stmt，perIterationBindings和labelSet的抽象操作ForBodyEvaluation如下执行： 令 V 为 undefined. 执行 ? CreatePerIterationEnvironment(perIterationBindings). 重复， 若 test 不是 [empty]，那么 令 testRef 为 test 的运算结果 令 testValue 为 ? GetValue(testRef). 若 ToBoolean(testValue) 是 false，返回 NormalCompletion(V). 令 result 为 stmt 的运算结果 若 LoopContinues(result, labelSet) 是 false，返回 Completion(UpdateEmpty(result, V)). 若 result.[[Value]] 不是 empty, 设置 V 为 result.[[Value]]. 执行 ? CreatePerIterationEnvironment(perIterationBindings). 若 increment 不是 [empty]，那么 令 incRef 为 increment 的运算结果 执行 ? GetValue(incRef). 13.7.4.9 运行时语义：CreatePerIterationEnvironment ( perIterationBindings ) 具有参数perIterationBindings的抽象操作CreatePerIterationEnvironment的执行方式如下： 若 perIterationBindings 有任何元素，那么 令 lastIterationEnv 为运行时执行上下文的词法环境. 令 lastIterationEnvRec 为 lastIterationEnv 的环境记录项 令 outer 为 lastIterationEnv 的外部环境引用 断言: outer 不是 null. 令 thisIterationEnv 为 NewDeclarativeEnvironment(outer). 令 thisIterationEnvRec 为 thisIterationEnv 的环境记录项 对于 perIterationBindings 的每一个 bn 元素, 执行 执行 ! thisIterationEnvRec.CreateMutableBinding(bn, false). 令 lastValue 为 ? lastIterationEnvRec.GetBindingValue(bn, true). 执行 thisIterationEnvRec.InitializeBinding(bn, lastValue). 设置运行时执行上下文的词法环境 为 thisIterationEnv. 返回 undefined. 13.7.5 for-in, for-of, 和for-await-of 语句 13.7.5.1 静态语义：Early Errors IterationStatement : for ( LeftHandSideExpression in Expression ) Statement for ( LeftHandSideExpression of AssignmentExpression ) Statement for await ( LeftHandSideExpression of AssignmentExpression ) Statement 如果LeftHandSideExpression是ObjectLiteral或ArrayLiteral，并且LeftHandSideExpression没有覆盖AssignmentPattern，则它是语法错误。 如果LeftHandSideExpression是ObjectLiteral或ArrayLiteral，并且如果LeftHandSideExpression覆盖了AssignmentPattern，则不应用以下规则。而是使用AssignmentPattern的Early Error规则。 如果LeftHandSideExpression的AssignmentTargetType不是simple，则是语法错误。 如果LeftHandSideExpression为CoverParenthesizedExpressionAndArrowParameterList : (Expression)，如果该短语替换了LeftHandSideExpression，则Expression会根据这些规则派生一个语法错误。该规则是递归应用的。 注：最后一条规则意味着即使括号括在Expression上，也要应用其他规则。 IterationStatement : for ( ForDeclaration in Expression ) Statement for ( ForDeclaration of AssignmentExpression ) Statement for await ( ForDeclaration of AssignmentExpression ) Statement 如果 ForDeclaration 的 BoundNames 包含\"let\"，则是语法错误。 如果 ForDeclaration 的 BoundNames 的任何元素也出现在语句的 VarDeclaredNames 中，则是语法错误。 如果 ForDeclaration 的 BoundNames 包含任何重复的条目，则是语法错误。 13.7.5.2 静态语义：BoundNames ForDeclaration : LetOrConst ForBinding 返回 ForBinding 的 BoundNames 13.7.5.3 静态语义：ContainsDuplicateLabels 使用参数 labelSet IterationStatement : for ( LeftHandSideExpression in Expression ) Statement for ( var ForBinding in Expression ) Statement for ( ForDeclaration in Expression ) Statement for ( LeftHandSideExpression of AssignmentExpression ) Statement for ( var ForBinding of AssignmentExpression ) Statement for ( ForDeclaration of AssignmentExpression ) Statement for await ( LeftHandSideExpression of AssignmentExpression ) Statement for await ( var ForBinding of AssignmentExpression ) Statement for await ( ForDeclaration of AssignmentExpression ) Statement 返回带有参数 labelSet 的 Statement 的 ContainsDuplicateLabels 注：本节由附录B.3.6扩展。 13.7.5.4 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet IterationStatement : for ( LeftHandSideExpression in Expression ) Statement for ( var ForBinding in Expression ) Statement for ( ForDeclaration in Expression ) Statement for ( LeftHandSideExpression of AssignmentExpression ) Statement for ( var ForBinding of AssignmentExpression ) Statement for ( ForDeclaration of AssignmentExpression ) Statement for await ( LeftHandSideExpression of AssignmentExpression ) Statement for await ( var ForBinding of AssignmentExpression ) Statement for await ( ForDeclaration of AssignmentExpression ) Statement 注：本节由附录B.3.6扩展。 13.7.5.5 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet IterationStatement : for ( LeftHandSideExpression in Expression ) Statement for ( var ForBinding in Expression ) Statement for ( ForDeclaration in Expression ) Statement for ( LeftHandSideExpression of AssignmentExpression ) Statement for ( var ForBinding of AssignmentExpression ) Statement for ( ForDeclaration of AssignmentExpression ) Statement for await ( LeftHandSideExpression of AssignmentExpression ) Statement for await ( var ForBinding of AssignmentExpression ) Statement for await ( ForDeclaration of AssignmentExpression ) Statement 返回带有参数 iterationSet 和 « » 的 Statement 的 ContainsUndefinedContinueTarget 注：本节由附录B.3.6扩展。 13.7.5.6 静态语义：IsDestructuring ForDeclaration : LetOrConst ForBinding 返回 ForBinding 的 IsDestructuring ForBinding : BindingIdentifier 返回 false ForBinding : BindingPattern 返回 true. 注：本节由附录B.3.6扩展。 13.7.5.7 静态语义：VarDeclaredNames IterationStatement : for ( LeftHandSideExpression in Expression ) Statement 返回 Statement 的 VarDeclaredNames IterationStatement : for ( var ForBinding in Expression ) Statement 令 names 为 ForBinding 的 BoundNames 在 names 后追加 Statement 的 VarDeclaredNames 元素 返回 names. IterationStatement : for ( ForDeclaration in Expression ) Statement 返回 Statement 的 VarDeclaredNames IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement for await ( LeftHandSideExpression of AssignmentExpression ) Statement 返回 Statement 的 VarDeclaredNames IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement for await ( var ForBinding of AssignmentExpression ) Statement 令 names 为 ForBinding 的 BoundNames 在 names 后追加 Statement 的 VarDeclaredNames 元素 返回 names. IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement for await ( ForDeclaration of AssignmentExpression ) Statement 返回 Statement 的 VarDeclaredNames 注：本节由附录B.3.6扩展。 13.7.5.8 静态语义：VarScopedDeclarations IterationStatement : for ( LeftHandSideExpression in Expression ) Statement 返回 Statement 的 VarScopedDeclarations IterationStatement : for ( var ForBinding in Expression ) Statement 令 declarations 为 包含 ForBinding 的列表. 在 declarations 后追加 Statement 的 VarScopedDeclarations 元素 返回 declarations. IterationStatement : for ( ForDeclaration in Expression ) Statement for await ( LeftHandSideExpression of AssignmentExpression ) Statement 返回 Statement 的 VarScopedDeclarations IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement for await ( var ForBinding of AssignmentExpression ) Statement 返回 Statement 的 VarScopedDeclarations IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement for await ( var ForBinding of AssignmentExpression ) Statement 令 declarations 为 包含 ForBinding 的列表. 在 declarations 后追加 Statement 的 VarScopedDeclarations 元素 返回 declarations. IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement for await ( ForDeclaration of AssignmentExpression ) Statement 返回 Statement 的 VarScopedDeclarations 注：本节由附录B.3.6扩展。 13.7.5.9 运行时语义：BindingInitialization 使用参数value和environment 注：为环境传递undefined，以指示应该使用PutValue操作来分配初始化值。 var语句和某些非严格函数的形式参数列表就是这种情况（请参见9.2.15）。在这些情况下，在评估其初始值设定项之前会先悬挂并预初始化词法绑定 ForDeclaration : LetOrConst ForBinding 返回为ForBinding执行BindingInitialization的结果，将 value 和 enviroment 作为参数传递。 13.7.5.10 运行时语义：BindingInstantiation 使用参数 environment ForDeclaration : LetOrConst ForBinding 令 envRec 为 environment 的环境记录项 断言: envRec 是声明环境记录项. 对于 ForBinding 的每一个 BoundNames 的 name 元素, 执行 若 LetOrConst 的 IsConstantDeclaration 是 true，那么 执行 ! envRec.CreateImmutableBinding(name, true). 否则， 执行 ! envRec.CreateMutableBinding(name, false). 13.7.5.11 运行时语义：LabelledEvaluation 使用参数 labelSet IterationStatement : for ( LeftHandSideExpression in Expression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(« », Expression, enumerate). 返回 ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet). IterationStatement : for ( var ForBinding in Expression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(« », Expression, enumerate). 返回 ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet). IterationStatement : for ( ForDeclaration in Expression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate). 返回 ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet). IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate). 返回 ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet). IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate). 返回 ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet). IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate). 返回 ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet). IterationStatement : for await ( LeftHandSideExpression of AssignmentExpression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate). 返回 ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet, async). IterationStatement : for await ( var ForBinding of AssignmentExpression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate). 返回 ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet, async). IterationStatement : for await ( ForDeclaration of AssignmentExpression ) Statement 令 keyResult 为 ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, asynciterate). 返回 ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet, async). 注：本节由附录B.3.6扩展。 13.7.5.12 运行时语义：ForIn/OfHeadEvaluation ( TDZnames, expr, iterationKind ) 抽象操作ForIn / OfHeadEvaluation用TDZnames，expr和erationKind自变量调用。 erationKind的值可以是枚举，迭代或异步迭代。 令 oldEnv 为运行时执行上下文的词法环境. 若 TDZnames 不是空列表，那么 断言: TDZnames 没有重复的条目。 令 TDZ 为 NewDeclarativeEnvironment(oldEnv). 令 TDZEnvRec 为 TDZ 的环境记录项. 对于TDZnames中的 name 字符串，执行 执行 ! TDZEnvRec.CreateMutableBinding(name, false). 设置运行时执行上下文的词法环境 为 TDZ. 令 exprRef 为 expr 的运算结果 设置运行时执行上下文的词法环境 为 oldEnv. 令 exprValue 为 ? GetValue(exprRef). 若 iterationKind 是 enumerate，那么 若 exprValue 是 undefined 或 null，那么 返回 Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }. 令 obj 为 ! ToObject(exprValue). 返回 ? EnumerateObjectProperties(obj). 否则， 断言: iterationKind 是 iterate. 若 iterationKind 是 async-iterate, 令 iteratorHint 为 async. 否则，令 iteratorHint 为 sync. 返回 ? GetIterator(exprValue, iteratorHint). 13.7.5.13 运行时语义：ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [ , iteratorKind ] ) 抽象操作 ForIn/OfBodyEvaluation使用参数 lhs、stmt、iteratorRecord、iterationKind、lhsKind、labelSet 和可选参数iteratorKind 调用。lhsKind 的值是assignment、varBinding 或词法绑定。iteratorKind 的值是sync的或async的。 若 iteratorKind 不存在, 设置 iteratorKind 为 sync. 令 oldEnv 为运行时执行上下文的词法环境. 令 V 为 undefined. 令 destructuring 为 lhs 的 IsDestructuring 若 destructuring 是 true 并且如果 lhsKind 是 assignment，那么 断言: lhs 是 LeftHandSideExpression. 令AssignmentPattern为lhs涵盖的AssignmentPattern。 重复， 令 nextResult 为 ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « »). 若 iteratorKind 是 async，那么 设置 nextResult 为 ? Await(nextResult). 若 Type(nextResult) 不是 Object, 抛出 TypeError 异常. 令 done 为 ? IteratorComplete(nextResult). 若 done 是 true，返回 NormalCompletion(V). 令 nextValue 为 ? IteratorValue(nextResult). 若 lhsKind 是 assignment 或 varBinding，那么 若 destructuring 是 false，那么 令 lhsRef 为运算 lhs（可能被重复求值） 的结果 否则， 断言: lhsKind 是 lexicalBinding. 断言: lhs 是 ForDeclaration. 令 iterationEnv 为 NewDeclarativeEnvironment(oldEnv). 为LHS执行BindingInstantiation，将iterationEnv作为参数传递。 设置运行时执行上下文的词法环境 为 iterationEnv. 若 destructuring 是 false，那么 断言: lhs 绑定一个名字 令 lhsName 为 lhs 的 BoundNames 的唯一元素 令 lhsRef 为 ! ResolveBinding(lhsName). 若 destructuring 是 false，那么 若 lhsRef 是 abrupt completion，那么 令 status 为 lhsRef. 否则如果 lhsKind 是 lexicalBinding，那么 令 status 为 InitializeReferencedBinding(lhsRef, nextValue). 否则， 令 status 为 PutValue(lhsRef, nextValue). 否则， 若 lhsKind 是 assignment，那么 令 status 为使用nextValue作为参数，执行AssignmentPattern的DestructuringAssignmentEvaluation的结果 否则如果 lhsKind 是 varBinding，那么 断言: lhs 是 ForBinding. 令 status 为 lhs 传递 nextValue 和 undefined 作为参数，执行 BindingInitialization 的结果。 否则， 断言: lhsKind 是 lexicalBinding. 断言: lhs 是 a ForDeclaration. 令 status 为 lhs 传递 nextValue 和 iterationEnv 作为参数，执行BindingInitialization的结果。 若 status 是 abrupt completion，那么 设置运行时执行上下文的词法环境 为 oldEnv. 若 iteratorKind 是 async，返回 ? AsyncIteratorClose(iteratorRecord, status). 若 iterationKind 是 enumerate，那么 返回 status. 否则， 断言: iterationKind 是 iterate. 返回 ? IteratorClose(iteratorRecord, status). 令 result 为 stmt 的运算结果 设置运行时执行上下文的词法环境 为 oldEnv. 若 LoopContinues(result, labelSet) 是 false，那么 若 iterationKind 是 enumerate，那么 返回 Completion(UpdateEmpty(result, V)). 否则， 断言: iterationKind 是 iterate. 设置 status 为 UpdateEmpty(result, V). 若 iteratorKind 是 async，返回 ? AsyncIteratorClose(iteratorRecord, status). 返回 ? IteratorClose(iteratorRecord, status). 若 result.[[Value]] 不是 empty, 设置 V 为 result.[[Value]]. 13.7.5.14 运行时语义：Evaluation ForBinding : BindingIdentifier 令 bindingId 为 BindingIdentifier 的 StringValue 返回 ? ResolveBinding(bindingId). 13.7.5.15 EnumerateObjectProperties ( O ) 当使用参数OF调用抽象操作枚举对象属性时，将执行以下步骤： 断言: Type(O) 是 Object. 返回一个Iterator对象（25.1.1.2），其下一个方法迭代O的enumerableproperties的所有字符串值键。ECMAScript代码永远不能直接访问该迭代器对象。没有指定枚举属性的机制和顺序，但必须符合以下指定的规则。 迭代器的throw和return方法为null，并且永远不会调用。迭代器的next方法处理对象属性，以确定是否应将属性键作为迭代器值返回。返回的属性键不包括作为符号的键。在枚举过程中可能会删除目标对象的属性。在迭代器的next方法处理之前删除的属性将被忽略。如果在枚举过程中将新属性添加到目标对象，则不能保证新添加的属性将在活动枚举中进行处理。在任何枚举中，属性名称最多由迭代器的next方法返回。 枚举目标对象的属性包括递归枚举其原型的属性和原型的原型，等等。但是，如果原型的属性与迭代器的next方法已经处理过的属性具有相同的名称，则不会处理原型的属性。在确定原型对象的属性是否已被处理时，不考虑[[Enumerable]]属性的值。原型对象的可枚举属性名称必须通过调用EnumerateObjectProperties并将原型对象作为参数来获得。 EnumerateObjectProperties必须通过调用目标对象的[[OwnPropertyKeys]]内部方法来获取目标对象自己的属性键。目标对象的属性属性必须通过调用其[[GetOwnProperty]]内部方法来获取。 注：以下是符合这些规则的ECMAScript生成器函数的参考性定义： function* EnumerateObjectProperties(obj) { const visited = new Set(); for (const Reflect 的 keyownKeys(obj)) { if (typeof key === \"symbol\") continue; const desc = Reflect.getOwnPropertyDescriptor(obj, key); if (desc) { visited.add(key); if (desc.enumerable) yield key; } } const proto = Reflect.getPrototypeOf(obj); if (proto === null) return; for (const protoKey of EnumerateObjectProperties(proto)) { if (!visited.has(protoKey)) yield protoKey; } } 13.8 continue 语句 语法 ContinueStatement[Yield, Await] : continue ; continue [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ; 13.8.1 静态语义：Early Errors ContinueStatement : continue ; ContinueStatement : continue LabelIdentifier ; 如果此ContinueStatement没有在IterationStatement中直接或间接（但不跨越函数边界）嵌套，则为语法错误。 13.8.2 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet ContinueStatement : continue ; 返回 false. ContinueStatement : continue LabelIdentifier ; 若 LabelIdentifier 的 StringValue 不是 iterationSet 元素，返回 true. 返回 false. 13.8.3 运行时语义：Evaluation ContinueStatement : continue ; 返回 Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: empty }. ContinueStatement : continue LabelIdentifier ; 令 label 为 LabelIdentifier 的 StringValue 返回 Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: label }. 13.9 break 语句 语法 BreakStatement[Yield, Await] : break ; break [no LineTerminator here] LabelIdentifier[?Yield, ?Await] ; 13.9.1 静态语义：Early Errors BreakStatement : break ; 如果此BreakStatement没有在IterationStatement或SwitchStatement中直接或间接（但不跨越函数边界）嵌套，则为语法错误。 13.9.2 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet BreakStatement : break ; 返回 false. BreakStatement : break LabelIdentifier ; 若 LabelIdentifier 的 StringValue 不是 labelSet 元素，返回 true. 返回 false. 13.9.3 运行时语义：Evaluation BreakStatement : break ; 返回 Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }. BreakStatement : break LabelIdentifier ; 令 label 为 LabelIdentifier 的 StringValue 返回 Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: label }. 13.10 return 语句 语法 ReturnStatement[Yield, Await] : return ; return [no LineTerminator here] Expression[+In, ?Yield, ?Await] ; 注：return语句使函数停止执行，并且在大多数情况下，将值返回给调用方。如果省略Expression，则返回值是不确定的。否则，返回值是Expression的值。根据周围的上下文，return语句实际上可能不会将值返回给调用方。例如，在try块中，可以在评估fially块期间将return语句的完成记录替换为另一个完成记录。 13.10.1 运行时语义：Evaluation ReturnStatement : return ; 返回 Completion { [[Type]]: return, [[Value]]: undefined, [[Target]]: empty }. ReturnStatement : return Expression ; 令 exprRef 为 Expression 的运算结果 令 exprValue 为 ? GetValue(exprRef). 若 ! GetGeneratorKind() 是 async, 设置 exprValue 为 ? Await(exprValue). 返回 Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }. 13.11 with 语句 语法 WithStatement[Yield, Await, Return] : with ( Expression[+In, ?Yield, ?Await] ) Statement[?Yield, ?Await, ?Return] 注：with语句将已计算对象的对象环境记录添加到正在运行的执行上下文的词法环境中。然后，它使用此扩充词法环境执行一条语句。最后，它还原了原始词汇环境。 13.11.1 静态语义：Early Errors WithStatement : with ( Expression ) Statement 如果与此模式匹配的代码包含在严格模式代码中，则是语法错误。 如果IsLabelledFunction（Statement）为true，则为语法错误。 注：如果实现了B.3.2中指定的扩展，则仅需应用第二条规则。 13.11.2 静态语义：ContainsDuplicateLabels 使用参数 labelSet WithStatement : with ( Expression ) Statement 返回 ContainsDuplicateLabels of Statement with argument labelSe 13.11.3 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSe WithStatement : with ( Expression ) Statement 返回带有参数 labelSet 的 Statement 的 ContainsUndefinedBreakTarget 13.11.4 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet WithStatement : with ( Expression ) Statement 返回带有参数 iterationSet 和 « » 的 Statement 的 ContainsUndefinedContinueTarget 13.11.5 静态语义：VarDeclaredNames WithStatement : with ( Expression ) Statement 返回 Statement 的 VarDeclaredNames 13.11.6 静态语义：VarScopedDeclarations WithStatement : with ( Expression ) Statement 返回 Statement 的 VarScopedDeclarations 13.11.7 运行时语义：Evaluation WithStatement : with ( Expression ) Statement 令 val 为 Expression 的运算结果 令 obj 为 ? ToObject(? GetValue(val)). 令 oldEnv 为运行时执行上下文的词法环境. 令 newEnv 为 NewObjectEnvironment(obj, oldEnv). 设置 the withEnvironment flag of newEnv's EnvironmentRecord 为 true. 设置运行时执行上下文的词法环境 为 newEnv. 令 C 为 Statement 的运算结果 设置运行时执行上下文的词法环境 为 oldEnv. 返回 Completion(UpdateEmpty(C, undefined)). 注：无论控件是如何离开嵌入的Statement的，无论是正常还是通过某种形式的突然完成或异常，LexicalEnvironment始终都会恢复为其以前的状态。 13.12 switch 语句 语法 SwitchStatement[Yield, Await, Return] : switch ( Expression[+In, ?Yield, ?Await] ) CaseBlock[?Yield, ?Await, ?Return] CaseBlock[Yield, Await, Return] : { CaseClauses[?Yield, ?Await, ?Return] opt } { CaseClauses[?Yield, ?Await, ?Return] opt DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return] opt } CaseClauses[Yield, Await, Return] : CaseClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return] CaseClause[Yield, Await, Return] : case Expression[+In, ?Yield, ?Await] : StatementList[?Yield, ?Await, ?Return] opt DefaultClause[Yield, Await, Return] : default : StatementList[?Yield, ?Await, ?Return] opt 13.12.1 静态语义：Early Errors SwitchStatement : switch ( Expression ) CaseBlock 如果CaseBlock的LexicallyDeclaredNames包含任何重复的条目，则是语法错误。 如果CaseBlock的LexicallyDeclaredNames中的任何元素也出现在CaseBlock的VarDeclaredNames中，则是语法错误。 13.12.2 静态语义：ContainsDuplicateLabels 使用参数 labelSet SwitchStatement : switch ( Expression ) CaseBlock 返回带有参数 labelSet 的 CaseBlock 的 ContainsDuplicateLabels CaseBlock : { } 返回 false CaseBlock : { CaseClauses DefaultClause CaseClauses } 若 the first CaseClauses 存在，那么 令 hasDuplicates 为包含第一个带有参数labelSet的CaseClauses的DuplicateLabel。 若 hasDuplicates 是 true，返回 true. 令 hasDuplicates 为带有参数 labelSet 的 DefaultClause 的 ContainsDuplicateLabels 若 hasDuplicates 是 true，返回 true. 若 the second CaseClauses 不存在，返回 false. 返回带有参数labelSet的第二个CaseClauses的ContainsDuplicateLabel CaseClauses : CaseClauses CaseClause 令 hasDuplicates 为带有参数 labelSet 的 CaseClauses 的 ContainsDuplicateLabels 若 hasDuplicates 是 true，返回 true. 返回带有参数 labelSet 的 CaseClause 的 ContainsDuplicateLabels CaseClause : case Expression : StatementList 若 the StatementList 存在，返回带有参数 labelSet 的 StatementList 的 ContainsDuplicateLabels 返回 false. DefaultClause : default : StatementList 若 the StatementList 存在，返回带有参数 labelSet 的 StatementList 的 ContainsDuplicateLabels 返回 false 13.12.3 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet SwitchStatement : switch ( Expression ) CaseBlock 返回带有参数 labelSet 的 CaseBlock 的 ContainsUndefinedBreakTarget CaseBlock : { } 返回 false. CaseBlock : { CaseClauses DefaultClause CaseClauses } 若 the first CaseClauses 存在，那么 令 hasUndefinedLabels 为带有参数labelSet的第一个CaseClauses的ContainsUndefinedBreakTarget若 hasUndefinedLabels 是 true，返回 true. 令 hasUndefinedLabels 为带有参数 labelSet 的 DefaultClause 的 ContainsUndefinedBreakTarget 若 hasUndefinedLabels 是 true，返回 true. 若 the second CaseClauses 不存在，返回 false. 返回带有参数labelSet的第二个CaseClauses的ContainsUndefinedBreakTarget。 CaseClauses : CaseClauses CaseClause 令 hasUndefinedLabels 为带有参数 labelSet 的 CaseClauses 的 ContainsUndefinedBreakTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 labelSet 的 CaseClause 的 ContainsUndefinedBreakTarget CaseClause : case Expression : StatementList 若 the StatementList 存在，返回带有参数 labelSet 的 StatementList 的 ContainsUndefinedBreakTarget 返回 false. DefaultClause : default : StatementList 若 the StatementList 存在，返回带有参数 labelSet 的 StatementList 的 ContainsUndefinedBreakTarget 返回 false. 13.12.4 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet SwitchStatement : switch ( Expression ) CaseBlock 返回带有参数 iterationSet 和 « » 的 CaseBlock 的 ContainsUndefinedContinueTarget CaseBlock : { } 返回 false CaseBlock : { CaseClauses DefaultClause CaseClauses } 若 the first CaseClauses 存在，那么 令 hasUndefinedLabels 为包含第一个CaseClauses的UndefinedContinueTarget，带有参数erationSet和«» 若 hasUndefinedLabels 是 true，返回 true. 令 hasUndefinedLabels 为 ContainsUndefinedContinueTarget of DefaultClause with arguments iterationSet and «». 若 hasUndefinedLabels 是 true，返回 true. 若 the second CaseClauses 不存在，返回 false. 返回 ContainsUndefinedContinueTarget of the second CaseClauses with arguments iterationSet and « ». CaseClauses : CaseClauses CaseClause 令 hasUndefinedLabels 为带有参数 iterationSet 和 « » 的 CaseClauses 的 ContainsUndefinedContinueTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 iterationSet 和 « » 的 CaseClause 的 ContainsUndefinedContinueTarget CaseClause : case Expression : StatementList 若 the StatementList 存在，返回带有参数 iterationSet 和 « » 的 StatementList 的 ContainsUndefinedContinueTarget 返回 false. DefaultClause : default : StatementList 若 the StatementList 存在，返回带有参数 iterationSet 和 « » 的 StatementList 的 ContainsUndefinedContinueTarget 返回 false. 13.12.5 静态语义：LexicallyDeclaredNames CaseBlock : { } 返回一个新的空列表. CaseBlock : { CaseClauses DefaultClause CaseClauses } 若 the first CaseClauses 存在, 令 name 为第一个CaseClauses的LexicallyDeclaredNames。 否则， 令 names 为一个新的空列表. 在 names 后追加 DefaultClause 的 LexicallyDeclaredNames 元素 若 the second CaseClauses 不存在，返回 names 返回将第二个CaseClauses的LexicallyDeclaredNames元素添加到names之后的结果。 CaseClauses : CaseClauses CaseClause 令 names 为 CaseClauses 的 LexicallyDeclaredNames 在 names 后追加 CaseClause 的 LexicallyDeclaredNames 元素 返回 names. CaseClause : case Expression : StatementList 若 the StatementList 存在，返回 StatementList 的 LexicallyDeclaredNames 返回一个新的空列表. DefaultClause : default : StatementList 若 the StatementList 存在，返回 StatementList 的 LexicallyDeclaredNames 返回一个新的空列表. 13.12.6 静态语义：LexicallyScopedDeclarations CaseBlock : { } 返回一个新的空列表. CaseBlock : { CaseClauses DefaultClause CaseClauses } 若 the first CaseClauses 存在, 令 declarations 为第一个CaseClauses的LexicallyScopedDeclarations。 否则， 令 declarations 为一个新的空列表. 在 declarations 后追加 DefaultClause 的 LexicallyScopedDeclarations 元素 若 the second CaseClauses 不存在，返回 declarations. 返回在declarations之后附加第二个CaseClauses的LexicalScopedDeclarations的元素的结果 CaseClauses : CaseClauses CaseClause 令 declarations 为 CaseClauses 的 LexicallyScopedDeclarations 在 declarations 后追加 CaseClause 的 LexicallyScopedDeclarations 元素 返回 declarations CaseClause : case Expression : StatementList 若 the StatementList 存在，返回 StatementList 的 LexicallyScopedDeclarations 返回一个新的空列表. DefaultClause : default : StatementList 若 the StatementList 存在，返回 StatementList 的 LexicallyScopedDeclarations 返回一个新的空列表. 13.12.7 静态语义：VarDeclaredNames SwitchStatement : switch ( Expression ) CaseBlock 返回 CaseBlock 的 VarDeclaredNames CaseBlock : { } 返回一个新的空列表. CaseBlock : { CaseClauses DefaultClause CaseClauses } 若 the first CaseClauses 存在, 令 names 为第一个CaseClauses的VarDeclaredNames。 否则， 令 names 为一个新的空列表. 在 names 后追加 DefaultClause 的 VarDeclaredNames 元素 若 the second CaseClauses 不存在，返回 names. 返回在names后面附加第二个CaseClauses的VarDeclaredNames的元素的结果 CaseClauses : CaseClauses CaseClause 令 names 为 CaseClauses 的 VarDeclaredNames 在 names 后追加 CaseClause 的 VarDeclaredNames 元素 返回 names. CaseClause : case Expression : StatementList 若 the StatementList 存在，返回 StatementList 的 VarDeclaredNames 返回一个新的空列表. DefaultClause : default : StatementList 若 the StatementList 存在，返回 StatementList 的 VarDeclaredNames 返回一个新的空列表. 13.12.8 静态语义：VarScopedDeclarations SwitchStatement : switch ( Expression ) CaseBlock 返回 CaseBlock 的 VarScopedDeclarations CaseBlock : { } 返回一个新的空列表. CaseBlock : { CaseClauses DefaultClause CaseClauses } 若 the first CaseClauses 存在, 令 declarations 为 第一个CaseClauses的VarScopedDeclaration。 否则， 令 declarations 为一个新的空列表. 在 declarations 后追加 DefaultClause 的 VarScopedDeclarations 元素 若 the second CaseClauses 不存在，返回 declarations. 返回在声明后追加第二个CaseClauses的VarScopedDeclarations的元素的结果 CaseClauses : CaseClauses CaseClause 令 declarations 为 CaseClauses 的 VarScopedDeclarations 在 declarations 后追加 CaseClause 的 VarScopedDeclarations 元素 返回 declarations. CaseClause : case Expression : StatementList 若 the StatementList 存在，返回 StatementList 的 VarScopedDeclarations 返回一个新的空列表. DefaultClause : default : StatementList 若 the StatementList 存在，返回 StatementList 的 VarScopedDeclarations 返回一个新的空列表. 13.12.9 运行时语义：CaseBlockEvaluation 使用参数 input CaseBlock : { } 返回 NormalCompletion(undefined). CaseBlock : { CaseClauses } 令 V 为 undefined. 令 A 为源文本顺序排列的CaseClauses中的CaseClause项目列表 令 found 为 false. 对于A中的CaseClause C，执行 若 found 是 false，那么 设置 found 为 ? CaseClauseIsSelected(C, input). 若 found 是 true，那么 令 R 为 C 的运算结果 若 R.[[Value]] 不是 empty, 设置 V 为 R.[[Value]]. 若 R 是 abrupt completion，返回 Completion(UpdateEmpty(R, V)). 返回 NormalCompletion(V). CaseBlock : { CaseClauses DefaultClause CaseClauses } 令 V 为 undefined. 若 the first CaseClauses 存在，那么 令 A 为第一个CaseClauses中的CaseClause项目列表，按源文本顺序排列。 否则， 令 A 为 « ». 令 found 为 false. 对于A中的CaseClause C，执行 若 found 是 false，那么 设置 found 为 ? CaseClauseIsSelected(C, input). 若 found 是 true，那么 令 R 为 C 的运算结果 若 R.[[Value]] 不是 empty, 设置 V 为 R.[[Value]]. 若 R 是 abrupt completion，返回 Completion(UpdateEmpty(R, V)). 令 foundInB 为 false. 若 the second CaseClauses 存在，那么 令 B 为第二个CaseClauses中的CaseClause项目列表，按源文本顺序。 否则， 令 B 为 « ». 若 found 是 false，那么 对于B中的CaseClause C，执行 若 foundInB 是 false，那么 设置 foundInB 为 ? CaseClauseIsSelected(C, input). 若 foundInB 是 true，那么 令 R 为 CaseClause C 的运算结果 若 R.[[Value]] 不是 empty, 设置 V 为 R.[[Value]]. 若 R 是 abrupt completion，返回 Completion(UpdateEmpty(R, V)). 若 foundInB 是 true，返回 NormalCompletion(V). 令 R 为 DefaultClause 的运算结果 若 R.[[Value]] 不是 empty, 设置 V 为 R.[[Value]]. 若 R 是 abrupt completion，返回 Completion(UpdateEmpty(R, V)). 对于在B中的每一个 CaseClause C (注: 这是第二个CaseClauses的另一个完整版本), 执行 令 R 为 CaseClause C 的运算结果 若 R.[[Value]] 不是 empty, 设置 V 为 R.[[Value]]. 若 R 是 abrupt completion，返回 Completion(UpdateEmpty(R, V)). 返回 NormalCompletion(V). 13.12.10 运行时语义：CaseClauseIsSelected ( C, input ) 给定CaseClause C和值输入，抽象操作CaseClauseIsSelected确定C是否与输入匹配。 断言: C 是产生式的一个实例 CaseClause : case Expression : StatementList . 令 exprRef 为运算 C 的 Expression 的结果 令 clauseSelector 为 ? GetValue(exprRef). 返回执行严格平等比较 input === ClauseSelector 的结果 注：此操作不执行C的StatementList（如果有）。 CaseBlock算法使用其返回值来确定要开始执行的StatementList。 13.12.11 运行时语义：Evaluation SwitchStatement : switch ( Expression ) CaseBlock 令 exprRef 为 Expression 的运算结果 令 switchValue 为 ? GetValue(exprRef). 令 oldEnv 为运行时执行上下文的词法环境. 令 blockEnv 为 NewDeclarativeEnvironment(oldEnv). 执行 BlockDeclarationInstantiation(CaseBlock, blockEnv). 设置运行时执行上下文的词法环境 为 blockEnv. 令 R 为 performing带有参数 switchValue 的 CaseBlock 的 CaseBlockEvaluation 的结果 设置运行时执行上下文的词法环境 为 oldEnv. 返回 R 注：无论控件如何离开SwitchStatement，LexicalEnvironment始终会恢复为其以前的状态。 CaseClause : case Expression : 返回 NormalCompletion(empty). CaseClause : case Expression : StatementList 返回 StatementList 的运算结果 DefaultClause : default : 返回 NormalCompletion(empty). DefaultClause : default : StatementList 返回 StatementList 的运算结果 13.13 带标签的语句 语法 LabelledStatement[Yield, Await, Return] : LabelIdentifier[?Yield, ?Await] : LabelledItem[?Yield, ?Await, ?Return] LabelledItem[Yield, Await, Return] : Statement[?Yield, ?Await, ?Return] FunctionDeclaration[?Yield, ?Await, ~Default] 注：声明可以以标签为前缀。带标签的语句仅与带标签的break和Continue语句结合使用。 ECMAScript没有goto语句。语句可以是LabelledStatement的一部分，它本身可以是LabelledStatement的一部分，依此类推。在描述单个语句的语义时，以这种方式引入的标签统称为“当前标签集”。 13.13.1 静态语义：Early Errors LabelledItem : FunctionDeclaration 如果任何源文本与该规则匹配，则是语法错误。 注：B.3.2提供了该规则的替代定义。 13.13.2 静态语义：ContainsDuplicateLabels 使用参数 labelSet LabelledStatement : LabelIdentifier : LabelledItem 令 label 为 LabelIdentifier 的 StringValue 若 label 是 an element of labelSet，返回 true. 令 newLabelSet 为附加了label的labelSet的副本。 返回带有参数 newLabelSet 的 LabelledItem 的 ContainsDuplicateLabels LabelledItem : FunctionDeclaration 返回 false. 13.13.3 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet LabelledStatement : LabelIdentifier : LabelledItem 令 label 为 LabelIdentifier 的 StringValue 令 newLabelSet 为附加了label的labelSet的副本。 返回带有参数 newLabelSet 的 LabelledItem 的 ContainsUndefinedBreakTarget LabelledItem : FunctionDeclaration 返回 false. 13.13.4 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet LabelledStatement : LabelIdentifier : LabelledItem 令 label 为 LabelIdentifier 的 StringValue 令 newLabelSet 为附加了label的labelSet的副本。 返回带有参数 iterationSet 和 newLabelSet 的 LabelledItem 的 ContainsUndefinedContinueTarget LabelledItem : FunctionDeclaration 返回 false. 13.13.5 静态语义：IsLabelledFunction ( stmt ) 具有参数stmt的抽象操作IsLabelledFunction执行以下步骤： 若 stmt 不是 LabelledStatement，返回 false. 令 item 为 stmt 的 LabelledItem 若 item 是 LabelledItem : FunctionDeclaration ，返回 true. 令 subStmt 为 item 的 Statement 返回 IsLabelledFunction(subStmt). 13.13.6 静态语义：LexicallyDeclaredNames LabelledStatement : LabelIdentifier : LabelledItem 返回 LabelledItem 的 LexicallyDeclaredNames LabelledItem : Statement 返回一个新的空列表. LabelledItem : FunctionDeclaration 返回 FunctionDeclaration 的 BoundNames 13.13.7 静态语义：LexicallyScopedDeclarations LabelledStatement : LabelIdentifier : LabelledItem 返回 LabelledItem 的 LexicallyScopedDeclarations LabelledItem : Statement 返回一个新的空列表. LabelledItem : FunctionDeclaration 返回包含 FunctionDeclaration 的新列表 13.13.8 静态语义：TopLevelLexicallyDeclaredNames LabelledStatement : LabelIdentifier : LabelledItem 返回一个新的空列表. 13.13.9 静态语义：TopLevelLexicallyScopedDeclarations LabelledStatement : LabelIdentifier : LabelledItem 返回一个新的空列表. 13.13.10 静态语义：TopLevelVarDeclaredNames LabelledStatement : LabelIdentifier : LabelledItem 返回 LabelledItem 的 TopLevelVarDeclaredNames LabelledItem : Statement 若 Statement 是 Statement : LabelledStatement ，返回 Statement 的 TopLevelVarDeclaredNames 返回 Statement 的 VarDeclaredNames LabelledItem : FunctionDeclaration 返回 FunctionDeclaration 的 BoundNames 13.13.11 静态语义：TopLevelVarScopedDeclarations LabelledStatement : LabelIdentifier : LabelledItem 返回 LabelledItem 的 TopLevelVarScopedDeclarations LabelledItem : Statement 若 Statement 是 Statement : LabelledStatement ，返回 Statement 的 TopLevelVarScopedDeclarations 返回 Statement 的 VarScopedDeclarations LabelledItem : FunctionDeclaration 返回包含 FunctionDeclaration 的新列表 13.13.12 静态语义：VarDeclaredNames LabelledStatement : LabelIdentifier : LabelledItem 返回 LabelledItem 的 VarDeclaredNames LabelledItem : FunctionDeclaration 返回一个新的空列表。 13.13.13 静态语义：VarScopedDeclarations LabelledStatement : LabelIdentifier : LabelledItem 返回 LabelledItem 的 VarScopedDeclarations LabelledItem : FunctionDeclaration 返回一个新的空列表. 13.13.14 运行时语义：LabelledEvaluation 使用参数 labelSet LabelledStatement : LabelIdentifier : LabelledItem 令 label 为 LabelIdentifier 的 StringValue 将label附加为labelSet的元素 令 stmtResult 为带有参数 labelSet 的 LabelledItem 的 LabelledEvaluation 若 stmtResult.[[Type]] 是 break 并且 SameValue(stmtResult.[[Target]], label) 是 true，那么 设置 stmtResult 为 NormalCompletion(stmtResult.[[Value]]). 返回 Completion(stmtResult). LabelledItem : Statement 若 Statement 是 LabelledStatement 或 BreakableStatement，那么 返回带有参数 labelSet 的 Statement 的 LabelledEvaluation 否则， 返回 Statement 的运算结果 LabelledItem : FunctionDeclaration 返回 FunctionDeclaration 的运算结果 13.13.15 运行时语义：Evaluation LabelledStatement : LabelIdentifier : LabelledItem 令 newLabelSet 为一个新的空列表. 返回带参数newLabelSet的LabelledStatement的LabelledEvaluation。 13.14 throw 语句 语法 ThrowStatement[Yield, Await] : throw [no LineTerminator here] Expression[+In, ?Yield, ?Await] ; 13.14.1 运行时语义：Evaluation ThrowStatement : throw Expression ; 令 exprRef 为 Expression 的运算结果 令 exprValue 为 ? GetValue(exprRef). 返回 ThrowCompletion(exprValue). 13.15 try 语句 语法 TryStatement[Yield, Await, Return] : try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] try Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return] try Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return] Catch[Yield, Await, Return] : catch ( CatchParameter[?Yield, ?Await] ) Block[?Yield, ?Await, ?Return] catch Block[?Yield, ?Await, ?Return] Finally[Yield, Await, Return] : finally Block[?Yield, ?Await, ?Return] CatchParameter[Yield, Await] : BindingIdentifier[?Yield, ?Await] BindingPattern[?Yield, ?Await] 注：try语句包含一段代码，在其中可能发生异常情况，例如运行时错误或throw语句。 catch子句提供异常处理代码。当catch子句捕获异常时，其CatchParameter绑定到该异常。 13.15.1 静态语义：Early Errors Catch : catch ( CatchParameter ) Block 如果CatchParameter的BoundNames包含任何重复的元素，则是语法错误。 如果CatchParameter的BoundNames的任何元素也出现在Block的LexicallyDeclaredNames中，则是语法错误。 如果CatchParameter的BoundNames的任何元素也出现在Block的VarDeclaredNames中，则是语法错误。 注：在B.3.5中给出了这种生产的另一种静态语义。 13.15.2 静态语义：ContainsDuplicateLabels 使用参数 labelSet TryStatement : try Block Catch 令 hasDuplicates 为带有参数 labelSet 的 Block 的 ContainsDuplicateLabels 若 hasDuplicates 是 true，返回 true. 返回带有参数 labelSet 的 Catch 的 ContainsDuplicateLabels TryStatement : try Block Finally 令 hasDuplicates 为带有参数 labelSet 的 Block 的 ContainsDuplicateLabels 若 hasDuplicates 是 true，返回 true. 返回带有参数 labelSet 的 Finally 的 ContainsDuplicateLabels TryStatement : try Block Catch Finally 令 hasDuplicates 为带有参数 labelSet 的 Block 的 ContainsDuplicateLabels 若 hasDuplicates 是 true，返回 true. 令 hasDuplicates 为带有参数 labelSet 的 Catch 的 ContainsDuplicateLabels 若 hasDuplicates 是 true，返回 true. 返回带有参数 labelSet 的 Finally 的 ContainsDuplicateLabels Catch : catch ( CatchParameter ) Block 返回带有参数 labelSet 的 Block 的 ContainsDuplicateLabels 13.15.3 静态语义：ContainsUndefinedBreakTarget 使用参数 labelSet TryStatement : try Block Catch 令 hasUndefinedLabels 为带有参数 labelSet 的 Block 的 ContainsUndefinedBreakTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 labelSet 的 Catch 的 ContainsUndefinedBreakTarget TryStatement : try Block Finally 令 hasUndefinedLabels 为带有参数 labelSet 的 Block 的 ContainsUndefinedBreakTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 labelSet 的 Finally 的 ContainsUndefinedBreakTarget TryStatement : try Block Catch Finally 令 hasUndefinedLabels 为带有参数 labelSet 的 Block 的 ContainsUndefinedBreakTarget 若 hasUndefinedLabels 是 true，返回 true. 令 hasUndefinedLabels 为带有参数 labelSet 的 Catch 的 ContainsUndefinedBreakTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 labelSet 的 Finally 的 ContainsUndefinedBreakTarget Catch : catch ( CatchParameter ) Block 返回带有参数 labelSet 的 Block 的 ContainsUndefinedBreakTarget 13.15.4 静态语义：ContainsUndefinedContinueTarget 使用参数iterationSet和labelSet TryStatement : try Block Catch 令 hasUndefinedLabels 为带有参数 iterationSet 和 « » 的 Block 的 ContainsUndefinedContinueTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 iterationSet 和 « » 的 Catch 的 ContainsUndefinedContinueTarget TryStatement : try Block Finally 令 hasUndefinedLabels 为带有参数 iterationSet 和 « » 的 Block 的 ContainsUndefinedContinueTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 iterationSet 和 « » 的 Finally 的 ContainsUndefinedContinueTarget TryStatement : try Block Catch Finally 令 hasUndefinedLabels 为带有参数 iterationSet 和 « » 的 Block 的 ContainsUndefinedContinueTarget 若 hasUndefinedLabels 是 true，返回 true. 令 hasUndefinedLabels 为带有参数 iterationSet 和 « » 的 Catch 的 ContainsUndefinedContinueTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 iterationSet 和 « » 的 Finally 的 ContainsUndefinedContinueTarget Catch : catch ( CatchParameter ) Block 返回带有参数 iterationSet 和 « » 的 Block 的 ContainsUndefinedContinueTarget 13.15.5 静态语义：VarDeclaredNames TryStatement : try Block Catch 令 names 为 Block 的 VarDeclaredNames 在 names 后追加 Catch 的 VarDeclaredNames 元素 返回 names. TryStatement : try Block Finally 令 names 为 Block 的 VarDeclaredNames 在 names 后追加 Finally 的 VarDeclaredNames 元素 返回 names. TryStatement : try Block Catch Finally 令 names 为 Block 的 VarDeclaredNames 在 names 后追加 Catch 的 VarDeclaredNames 元素 在 names 后追加 Finally 的 VarDeclaredNames 元素 返回 names. Catch : catch ( CatchParameter ) Block 返回 Block 的 VarDeclaredNames 13.15.6 静态语义：VarScopedDeclarations TryStatement : try Block Catch 令 declarations 为 Block 的 VarScopedDeclarations 在 declarations 后追加 Catch 的 VarScopedDeclarations 元素 返回 declarations. TryStatement : try Block Finally 令 declarations 为 Block 的 VarScopedDeclarations 在 declarations 后追加 Finally 的 VarScopedDeclarations 元素 返回 declarations. TryStatement : try Block Catch Finally 令 declarations 为 Block 的 VarScopedDeclarations 在 declarations 后追加 Catch 的 VarScopedDeclarations 元素 在 declarations 后追加 Finally 的 VarScopedDeclarations 元素 返回 declarations. Catch : catch ( CatchParameter ) Block 返回 Block 的 VarScopedDeclarations 13.15.7 运行时语义：CatchClauseEvaluation 使用参数 thrownValue Catch : catch ( CatchParameter ) Block 令 oldEnv 为运行时执行上下文的词法环境. 令 catchEnv 为 NewDeclarativeEnvironment(oldEnv). 令 catchEnvRec 为 catchEnv的环境记录项. 对于 CatchParameter 的每一个 BoundNames 的 argName，执行 执行 ! catchEnvRec.CreateMutableBinding(argName, false). 设置运行时执行上下文的词法环境 为 catchEnv. 令 status 为通过将thrownValue和catchEnv作为参数对CatchParameter执行BindingInitialization的结果。 若 status 是 abrupt completion，那么 设置运行时执行上下文的词法环境为 oldEnv. 返回 Completion(status). 令 B 为 Block 的运算结果 设置运行时执行上下文的词法环境 为 oldEnv. 返回 Completion(B). Catch : catch Block 返回 evaluating Block 的结果 注：无论控制如何离开LexicalEnvironment，始终将其恢复为以前的状态。 13.15.8 运行时语义：Evaluation TryStatement : try Block Catch 令 B 为 Block 的运算结果 若 B.[[Type]] 是 throw, 令 C 为带有参数 B 的 Catch 的 CatchClauseEvaluation[[Value]]. 否则， 令 C 为 B. 返回 Completion(UpdateEmpty(C, undefined)). TryStatement : try Block Finally 令 B 为 Block 的运算结果 令 F 为 Finally 的运算结果 若 F.[[Type]] 是 normal, 设置 F 为 B. 返回 Completion(UpdateEmpty(F, undefined)). TryStatement : try Block Catch Finally 令 B 为 Block 的运算结果 若 B.[[Type]] 是 throw, 令 C 为带有参数 B 的 Catch 的 CatchClauseEvaluation[[Value]]. 否则，令 C 为 B. 令 F 为 Finally 的运算结果 若 F.[[Type]] 是 normal, 设置 F 为 C. 返回 Completion(UpdateEmpty(F, undefined)). 13.16 debugger 语句 语法 DebuggerStatement : debugger ; 13.16.1 运行时语义：Evaluation 注：运算DebuggerStatement可能会使实现在调试器下运行时导致断点。如果调试器不存在或未处于活动状态，则此语句无效。 若实现定义的调试工具可用并且已启用，那么 执行实现定义的调试操作。 令result为实现定义的完成值。 否则， 令 result 为 NormalCompletion(empty). 返回 result. ECMAScript语言：语句和声明 ES10,ES中文,ES翻译,ES2019,ES文档,ES规范,ECMAScript10,ECMAScript中文,ECMAScript翻译,ECMAScript2019,ECMAScript文档,ECMAScript规范,ECMAScript语言：语句和声明,statements-and-declaraions"},"functions-and-classes.html":{"url":"functions-and-classes.html","title":"14 ECMAScript语言：函数和类","keywords":"","body":"14 ECMAScript语言：函数和类 注：各种ECMAScript语言元素导致创建ECMAScript函数对象（9.2）。对此类函数的运算始于其[[Call]]内部方法（9.2.1）的执行。 14.1 函数定义 语法 FunctionDeclaration[Yield, Await, Default] : function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] } [+Default] function ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] } FunctionExpression : function BindingIdentifier[~Yield, ~Await] opt ( FormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] } UniqueFormalParameters[Yield, Await] : FormalParameters[?Yield, ?Await] FormalParameters[Yield, Await] : [empty] FunctionRestParameter[?Yield, ?Await] FormalParameterList[?Yield, ?Await] FormalParameterList[?Yield, ?Await] , FormalParameterList[?Yield, ?Await] , FunctionRestParameter[?Yield, ?Await] FormalParameterList[Yield, Await] : FormalParameter[?Yield, ?Await] FormalParameterList[?Yield, ?Await] , FormalParameter[?Yield, ?Await] FunctionRestParameter[Yield, Await] : BindingRestElement[?Yield, ?Await] FormalParameter[Yield, Await] : BindingElement[?Yield, ?Await] FunctionBody[Yield, Await] : FunctionStatementList[?Yield, ?Await] FunctionStatementList[Yield, Await] : StatementList[?Yield, ?Await, +返回] opt 14.1.1 指令序言和严格使用指令 指令序言是最长的ExpressionStatements序列，出现在FunctionBody，ScriptBody或ModuleBody的初始StatementListItems或ModuleItems上，并且序列中的每个ExpressionStatement完全由StringLiteral标记后跟一个分号组成。分号可以显式显示，也可以通过自动分号插入来插入。指令序言可能是空序列。 使用严格指令是指令序言中的ExpressionStatement，其StringLiteral是 \"use strict\" 或 'use strict'的确切代码单元序列。使用严格指令可能不包含EscapeSequence或LineContinuation。 指令序言中可能包含多个严格使用指令。但是，若发生这种情况，则实现可能会发出警告。 注：指令序言的ExpressionStatement语句通常在包含产生式的求值过程中进行计算。实现可以为ExpressionStatement定义实现特定的含义，这些含义不是“使用严格”指令，而是在指令序言中出现。若存在适当的通知机制，则若实现在指令序言中遇到不是Use Strict指令且没有实现定义的含义的ExpressionStatement，则该实现应发出警告。 14.1.2 静态语义：Early Errors FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody } FunctionDeclaration : function ( FormalParameters ) { FunctionBody } FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody } 若与此产生式匹配的源代码是严格模式代码，则应用 UniqueFormalParameters: FormalParameters 的早期错误规则。 若与此产生式匹配的源代码是严格模式代码，那么若BindingIdentifier是存在的，并且BindingIdentifier的StringValue是\"eval\"或\"arguments\"，那么这就是一个语法错误。 若FunctionBody的ContainsUseStrict为真，FormalParameters的IsSimpleParameterList为假，则为语法错误。 若FormalParameters的BoundNames的任何元素也出现在FunctionBody的LexicallyDeclaredNames中，这是一个语法错误。 若包含SuperProperty的FormalParameters为真，则为语法错误。 若包含SuperProperty的FunctionBody为真，则为语法错误。 若包含SuperCall的FormalParameters为真，则为语法错误。 若包含SuperCall的FunctionBody为真，则为语法错误。 注 1：FunctionBody的LexicallyDeclaredNames不包括使用var或函数声明绑定的标识符 UniqueFormalParameters : FormalParameters 若FormalParameters的BoundNames包含任何重复的元素，则是语法错误。 FormalParameters : FormalParameterList 若FormalParameterList的IsSimpleParameterList为false，并且FormalParameterList的BoundNames包含任何重复元素，则是语法错误。 注 2：仅对于具有简单参数列表且未在严格模式代码中定义的函数，允许FormalParameterList中多次出现同一BindingIdentifier。 FunctionBody : FunctionStatementList 若FunctionStatementList的LexicallyDeclaredNames包含任何重复的条目，则是语法错误。 若FunctionStatementList的LexicallyDeclaredNames的任何元素也出现在FunctionStatementList的VarDeclaredNames中，则是语法错误。 若FunctionStatementList的ContainsDuplicateLabels和参数«»为true，则为语法错误。 若FunctionStatementList的ContainsUndefinedBreakTarget带有参数«»，则为语法错误。 若FunctionStatementList的ContainsUndefinedContinueTarget带有参数«»，并且«»为true，则为语法错误。 14.1.3 静态语义：BoundNames FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody } 返回 the BindingIdentifier 的 BoundNames FunctionDeclaration : function ( FormalParameters ) { FunctionBody } 返回 « \"*default*\" ». 注 \"*default*\"在本规范中用作使用导出声明定义的可提升匿名函数的合成名称。 FormalParameters : [empty] 返回一个新的空列表 FormalParameters : FormalParameterList , FunctionRestParameter 令 names 为 FormalParameterList 的 BoundNames 在 names 后追加 FunctionRestParameter 的 BoundNames。 返回 names. FormalParameterList : FormalParameterList , FormalParameter 令 names 为 FormalParameterList 的 BoundNames 在 names 后追加 FormalParameter 的 BoundNames 返回 names. 14.1.4 静态语义：包含 带有参数 symbol. FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody } FunctionDeclaration : function ( FormalParameters ) { FunctionBody } FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody } 返回 false. 注：依赖于子结构的静态语义规则通常不会考虑函数定义。 14.1.5 静态语义：ContainsExpression FormalParameters : [empty] 返回 false. FormalParameters : FormalParameterList , FunctionRestParameter 若 FormalParameterList 的 ContainsExpression 是 true, 返回 true. 返回 FunctionRestParameter 的 ContainsExpression FormalParameterList : FormalParameterList , FormalParameter 若 FormalParameterList 的 ContainsExpression 是 true, 返回 true. 返回 FormalParameter 的 ContainsExpression 14.1.6 静态语义：ContainsUseStrict FunctionBody : FunctionStatementList 若 FunctionStatementList的指令序言包含一个使用严格的指令, 返回 true; 否则, 返回 false. 14.1.7 静态语义：ExpectedArgumentCount FormalParameters : [empty] 返回 0. FormalParameters : FormalParameterList , FunctionRestParameter 返回 FormalParameterList 的 ExpectedArgumentCount 注：FormalParameterList的ExpetedArgumentCount是REST参数左边的FormalParameters数，或者是带有初始化器的第一个FormalParameter数。在带有初始化器的第一个参数之后，允许使用没有初始化器的FormalParameters，但是这些参数被认为是可选的，undefined为它们的默认值。 FormalParameterList : FormalParameterList , FormalParameter 令 count 为 FormalParameterList 的 ExpectedArgumentCount 若FormAlParameterList的HasInitializer设定为true，或者FormAlParameter的HasInitializer设定为true, 返回 count. 返回 count + 1. 14.1.8 静态语义：HasInitializer FormalParameterList : FormalParameterList , FormalParameter 若 FormalParameterList 的 HasInitializer 是 true, 返回 true. 返回 FormalParameter 的 HasInitializer 14.1.9 静态语义：HasName FunctionExpression : function ( FormalParameters ) { FunctionBody } 返回 false. FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody } 返回 true. 14.1.10 静态语义：IsAnonymousFunctionDefinition ( expr ) 抽象操作IsAnonyousFunctionDefinition确定其参数是否是不绑定名称的函数定义。参数expr是AssignmentExpression或Initializer的结果。采取了以下步骤： 若 expr 的 IsFunctionDefinition 是 false, 返回 false. 令 hasName 为 expr 的 HasName 的结果 若 hasName 是 true, 返回 false. 返回 true. 14.1.11 静态语义：IsConstantDeclaration FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody } FunctionDeclaration : function ( FormalParameters ) { FunctionBody } 返回 false. 14.1.12 静态语义：IsFunctionDefinition FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody } 返回 true. 14.1.13 静态语义：IsSimpleParameterList FormalParameters : [empty] 返回 true. FormalParameters : FormalParameterList , FunctionRestParameter 返回 false FormalParameterList : FormalParameterList , FormalParameter 若 FormalParameterList 的 IsSimpleParameterList 是 false, 返回 false. 返回 FormalParameter 的 IsSimpleParameterList FormalParameter : BindingElement 返回 BindingElement 的 IsSimpleParameterList 14.1.14 静态语义：LexicallyDeclaredNames FunctionStatementList : [empty] 返回一个新的空列表 FunctionStatementList : StatementList 返回 TopLevelLexicallyDeclaredNames of StatementList 14.1.15 静态语义：LexicallyScopedDeclarations FunctionStatementList : [empty] 返回一个新的空列表. FunctionStatementList : StatementList 返回 the StatementList 的 TopLevelLexicallyScopedDeclarations 14.1.16 静态语义：VarDeclaredNames FunctionStatementList : [empty] 返回一个新的空列表. FunctionStatementList : StatementList 返回 StatementList 的 TopLevelVarDeclaredNames 14.1.17 静态语义：VarScopedDeclarations FunctionStatementList : [empty] 返回一个新的空列表. FunctionStatementList : StatementList 返回 the StatementList 的 TopLevelVarScopedDeclarations 14.1.18 运行时语义：EvaluateBody 带有参数 functionObject 和 argumentsList列表. FunctionBody : FunctionStatementList 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList). 返回运算 FunctionStatementList 的结果 14.1.19 运行时语义：IteratorBindingInitialization 带有参数 iteratorRecord 和 environment 注 1：当为环境传递undefined时，表明应该使用PutValue操作来分配初始化值。非严格函数的形式参数列表就是这种情况。在那种情况下，形式参数绑定是预先初始化的，以便处理多个具有相同名称的参数的可能性。 FormalParameters : [empty] 返回 NormalCompletion(empty). FormalParameters : FormalParameterList , FunctionRestParameter 执行 ? 使用iteratorRecord和环境作为参数的FormalParameterList的IteratorBindingInitialization 返回使用iteratorRecord和环境作为参数对FunctionRestParameter执行IteratorBindingInitialization的结果。 FormalParameterList : FormalParameterList , FormalParameter 执行 ? 使用iteratorRecord和环境作为参数的FormalParameterList的IteratorBindingInitialization。 返回使用iteratorRecord和环境作为参数对FormalParameter执行IteratorBindingInitialization的结果。 FormalParameter : BindingElement 若 BindingElement 的 ContainsExpression 是 false, 返回使用iteratorRecord和环境作为参数对BindingElement执行IteratorBindingInitialization的结果。 令 currentContext 为运行时上下文. 令 originalEnv 为 currentContext 的 VariableEnvironment 断言: currentContext的VariableEnvironment和LexicalEnvironment相同。 断言: environment和originalEnv相同。 令 paramVarEnv 为 NewDeclarativeEnvironment(originalEnv). 设置currentContext的VariableEnvironment为paramVarEnv 设置currentContext的LexicalEnvironment为paramVarEnv 令 result 为使用iteratorRecord和environment作为参数对BindingElement执行IteratorBindingInitialization的结果。 设置currentContext的VariableEnvironment为originalEnv 设置currentContext的LexicalEnvironment为originalEnv 返回 result. 注 2 仅当BindingElement包含直接运算时，才使用在步骤6中创建的新环境记录。 FunctionRestParameter : BindingRestElement 若 BindingRestElement 的 ContainsExpression 是 false, 返回使用iteratorRecord和environment作为参数对BindingRestElement执行IteratorBindingInitialization的结果。 令 currentContext 为 运行时上下文. 令 originalEnv 为 currentContext 的 VariableEnvironment 断言: currentContext的VariableEnvironment和LexicalEnvironment相同。 断言: environment和originalEnv相同。 令 paramVarEnv 为 NewDeclarativeEnvironment(originalEnv). 设置currentContext的VariableEnvironment为paramVarEnv 设置currentContext的LexicalEnvironment为paramVarEnv 令 result 为使用iteratorRecord和environment作为参数对BindingRestElement执行IteratorBindingInitialization的结果。 设置currentContext的VariableEnvironment为originalEnv 设置currentContext的LexicalEnvironment为originalEnv 返回 result. 注 3：仅当BindingRestElement包含直接运算时，才使用在步骤6中创建的新环境记录。 14.1.20 运行时语义：InstantiateFunctionObject 带有参数 scope. FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody } 若 FunctionDeclaration 的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 name 为 BindingIdentifier 的 StringValue 令 F 为 FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict). 执行 MakeConstructor(F). 执行 SetFunctionName(F, name). 设置 F.[[SourceText]] 为由FunctionDeclaration匹配的源文本。 返回 F. FunctionDeclaration : function ( FormalParameters ) { FunctionBody } 令 F 为 FunctionCreate(Normal, FormalParameters, FunctionBody, scope, true). 执行 MakeConstructor(F). 执行 SetFunctionName(F, \"default\"). 设置 F.[[SourceText]]由FunctionDeclaration匹配的源文本。 返回 F 注：匿名FunctionDeclaration只能作为 export default 声明的一部分出现，因此其函数代码始终是严格模式代码。 14.1.21 运行时语义：NamedEvaluation 带有参数 name. FunctionExpression : function ( FormalParameters ) { FunctionBody } 令 closure 为运算 this 的结果FunctionExpression. 执行 SetFunctionName(closure, name). 返回 closure. 14.1.22 运行时语义：Evaluation FunctionDeclaration : function BindingIdentifier ( FormalParameters ) { FunctionBody } 返回 NormalCompletion(empty). 注 1：B.3.3中提供了另一种语义 FunctionDeclaration : function ( FormalParameters ) { FunctionBody } 返回 NormalCompletion(empty). FunctionExpression : function ( FormalParameters ) { FunctionBody } 若 FunctionExpression 的函数代码是严格模式代码， 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的 LexicalEnvironment。 令 closure 为 FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict). 执行 MakeConstructor(closure). 设置 closure.[[SourceText]] 为由 FunctionExpression 匹配的源文本。 返回 closure. FunctionExpression : function BindingIdentifier ( FormalParameters ) { FunctionBody } 若 FunctionExpression 的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的 LexicalEnvironment. 令 funcEnv 为 NewDeclarativeEnvironment(scope). 令 envRec 为 funcEnv' 的环境记录项. 令 name 为 BindingIdentifier 的 StringValue 执行 envRec.CreateImmutableBinding(name, false). 令 closure 为 FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict). 执行 MakeConstructor(closure). 执行 SetFunctionName(closure, name). 设置 closure.[[SourceText]] 为由FunctionExpression匹配的源文本。 执行 envRec.InitializeBinding(name, closure). 返回 closure 注 2：可以从FunctionExpression的FunctionBody内部引用FunctionExpression中的BindingIdentifier，以允许该函数以递归方式调用其自身。但是，与FunctionDeclaration中的功能不同，FunctionExpression中的BindingIdentifier不能从其引用，也不影响包围FunctionExpression的作用域。 注 3：将为使用FunctionDeclaration或FunctionExpression定义的每个函数自动创建一个原型属性，以允许将该函数用作构造函数。 FunctionStatementList : [empty] 返回 NormalCompletion(undefined). 14.2 箭头函数定义 语法 ArrowFunction[In, Yield, Await] : ArrowParameters[?Yield, ?Await] [no LineTerminator here] => ConciseBody[?In] ArrowParameters[Yield, Await] : BindingIdentifier[?Yield, ?Await] CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] ConciseBody[In] : [lookahead ≠ {] AssignmentExpression[?In, ~Yield, ~Await] { FunctionBody[~Yield, ~Await] } 补充语法 当产生式 ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList 公认以下语法用于完善对 CoverParenthesizedExpressionAndArrowParameterList: ArrowFormalParameters[Yield]: (StrictFormalParameters[?Yield]) 14.2.1 静态语义：Early Errors ArrowFunction : ArrowParameters => ConciseBody 若 ArrowParameters 包含 YieldExpression 是 true，则为语法错误 若 ArrowParameters 包含AwaitExpression 是 true，则为语法错误 若 ConciseBody 的 ContainsUseStrict 是 true 并且 ArrowParameters 的 IsSimpleParameterList 是 false，则为语法错误 若ConciseBody的LexicallyDeclaredNames中也出现ArrowParameters的BoundNames的任何元素，则是语法错误。 ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList 若CoverParenthesizedExpressionAndArrowParameterList没有覆盖ArrowFormalParameters，则是语法错误。 ArrowFormalParameters及其派生生产式的所有早期错误规则也适用于CoverParenthesizedExpressionAndArrowParameterList的CoveredFormalsList。 14.2.2 静态语义：BoundNames ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList 令 formals 为 CoverParenthesizedExpressionAndArrowParameterList 的 CoveredFormalsList 返回 the formals 的 BoundNames 14.2.3 静态语义：包含 带有参数 symbol ArrowFunction : ArrowParameters => ConciseBody 若 symbol 不是 NewTarget, SuperProperty, SuperCall, super 或 this其中之一, 返回 false. 若 ArrowParameters 包含 symbol 是 true, 返回 true. 返回 ConciseBody 包含 symbol. 注：通常，包含不会在大多数函数形式中出现。但是，Contains用于检测ArrowFunction中的new.target，this和super用法。 ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList 令 formals 为 CoverParenthesizedExpressionAndArrowParameterList 的 CoveredFormalsList 返回 formals 包含 symbol. 14.2.4 静态语义：ContainsExpression ArrowParameters : BindingIdentifier 返回 false. 14.2.5 静态语义：ContainsUseStrict ConciseBody : AssignmentExpression 返回 false. 14.2.6 静态语义：ExpectedArgumentCount ArrowParameters : BindingIdentifier 返回 1. 14.2.7 静态语义：HasName ArrowFunction : ArrowParameters => ConciseBody 返回 false. 14.2.8 静态语义：IsSimpleParameterList ArrowParameters : BindingIdentifier 返回 true. ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList 令 formals 为 CoverParenthesizedExpressionAndArrowParameterList 的 CoveredFormalsList 返回 formals 的 IsSimpleParameterList 14.2.9 静态语义：CoveredFormalsList ArrowParameters : BindingIdentifier 返回 this ArrowParameters. CoverParenthesizedExpressionAndArrowParameterList : ( Expression ) ( ) ( ... BindingIdentifier ) ( ... BindingPattern ) ( Expression , ... BindingIdentifier ) ( Expression , ... BindingPattern ) 返回CoverParenthesizedExpressionAndArrowParameterList涵盖的ArrowFormalParameters 14.2.10 静态语义：LexicallyDeclaredNames ConciseBody : AssignmentExpression 返回一个新的空列表. 14.2.11 静态语义：LexicallyScopedDeclarations ConciseBody : AssignmentExpression 返回一个新的空列表. 14.2.12 静态语义：VarDeclaredNames ConciseBody : AssignmentExpression 返回一个新的空列表. 14.2.13 静态语义：VarScopedDeclarations ConciseBody : AssignmentExpression 返回一个新的空列表. 14.2.14 运行时语义：IteratorBindingInitialization 带有参数 iteratorRecord 和 environment. 注：当为环境传递undefined时，表明应该使用PutValue操作来分配初始化值。非严格函数的形式参数列表就是这种情况。在那种情况下，形式参数绑定是预先初始化的，以便处理多个具有相同名称的参数的可能性。 ArrowParameters : BindingIdentifier 断言: iteratorRecord.[[Done]] 是 false. 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 否则, 令 v 为 IteratorValue(next). 若 v 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(v). 若 iteratorRecord.[[Done]] 是 true, 令 v 为 undefined. 返回使用v和environment作为参数对BindingIdentifier执行BindingInitialization的结果。 14.2.15 运行时语义：EvaluateBody 带有参数 functionObject 和 argumentsList列表. ConciseBody : AssignmentExpression 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList). 令 exprRef 为运算 AssignmentExpression 的结果 令 exprValue 为 ? GetValue(exprRef). 返回 Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }. 14.2.16 运行时语义：NamedEvaluation 带有参数 name. ArrowFunction : ArrowParameters => ConciseBody 令 closure 为运算此ArrowFunction的结果. 执行 SetFunctionName(closure, name). 返回 closure. 14.2.17 运行时语义：Evaluation ArrowFunction : ArrowParameters => ConciseBody 若此ArrowFunction的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 parameters 为 ArrowParameters 的 CoveredFormalsList 令 closure 为 FunctionCreate(Arrow, parameters, ConciseBody, scope, strict). 设置 closure.[[SourceText]] 为ArrowFunction匹配的源文本. 返回 closure. 注：ArrowFunction没有为arguments，super，this或new.target定义本地绑定。 ArrowFunction中对arguments，super，this或new.target的任何引用都必须解析为词法包围环境中的绑定。通常，这将是立即封闭函数的函数环境。即使ArrowFunction可能包含对super的引用，也无法通过执行MakeMethod将第4步中创建的函数对象制成方法。引用super的ArrowFunction始终包含在nonArrowFunction中，并且可以通过ArrowFunction的函数对象捕获的范围来访问实现super的必要状态。 14.3 方法定义 语法 MethodDefinition[Yield, Await] : PropertyName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, ~Await] ) { FunctionBody[~Yield, ~Await] } GeneratorMethod[?Yield, ?Await] AsyncMethod[?Yield, ?Await] AsyncGeneratorMethod[?Yield, ?Await] get PropertyName[?Yield, ?Await] ( ) { FunctionBody[~Yield, ~Await] } set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] } PropertySetParameterList : FormalParameter[~Yield, ~Await] 14.3.1 静态语义：Early Errors MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody } 若FunctionBody的ContainsUseStrict为true并且UniqueFormalParameters的IsSimpleParameterList为false，则为语法错误 若FunctionBody的LexicallyDeclaredNames中还出现UniqueFormalParameters的BoundNames的任何元素，则是语法错误。 MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody } 若PropertySetParameterList的BoundNames包含任何重复的元素，则为语法错误 若FunctionBody的ContainsUseStrict为true，PropertySetParameterList的IsSimpleParameterList为false，则为语法错误。 若FunctionBody的LexicallyDeclaredNames中还出现了PropertySetParameterList的BoundNames的任何元素，则是语法错误。 14.3.2 静态语义：ComputedProperty包含 带有参数 symbol. MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody } get PropertyName ( ) { FunctionBody } set PropertyName ( PropertySetParameterList ) { FunctionBody } 返回具有symbol参数的PropertyName的ComputedPropertyContains结果。 14.3.3 静态语义：ExpectedArgumentCount PropertySetParameterList : FormalParameter 若 FormalParameter 的 HasInitializer 是 true, 返回 0. 返回 1. 14.3.4 静态语义：HasDirectSuper MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody } 若 UniqueFormalParameters 包含 SuperCall 是 true, 返回 true. 返回 FunctionBody 包含SuperCall. MethodDefinition : get PropertyName ( ) { FunctionBody } 返回 FunctionBody 包含SuperCall MethodDefinition : 设置 PropertyName ( PropertySetParameterList ) { FunctionBody } 若 PropertySetParameterList 包含SuperCall 是 true, 返回 true. 返回 FunctionBody 包含SuperCall. 14.3.5 静态语义：PropName MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody } get PropertyName ( ) { FunctionBody } 设置 PropertyName ( PropertySetParameterList ) { FunctionBody } 返回 PropertyName 的 PropName 14.3.6 静态语义：SpecialMethod MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody } 返回 false. MethodDefinition : GeneratorMethod AsyncMethod AsyncGeneratorMethod get PropertyName ( ) { FunctionBody } 设置 PropertyName ( PropertySetParameterList ) { FunctionBody } 返回 true. 14.3.7 运行时语义：DefineMethod 带有参数 object 和 optional parameter functionPrototype. MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody } 令 propKey 为运算 PropertyName 的结果 ReturnIfAbrupt(propKey). 若此MethodDefinition的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为 运行时上下文的 LexicalEnvironment. 若 functionPrototype 作为参数存在, 那么 令 kind 为 Normal. 令 prototype 为 functionPrototype. 否则, 令 kind 为 Method. 令 prototype 为内部对象 %FunctionPrototype%. 令 closure 为 FunctionCreate(kind, UniqueFormalParameters, FunctionBody, scope, strict, prototype). 执行 MakeMethod(closure, object). 设置 closure.[[SourceText]] 为MethodDefinition匹配的源文本. 返回 the Record { [[Key]]: propKey, [[Closure]]: closure }. 14.3.8 运行时语义：PropertyDefinitionEvaluation 带有参数 object 和 enumerable. MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody } 令 methodDef 为带参数对象的MethodDefinition的DefineMethod。 ReturnIfAbrupt(methodDef). 执行 SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]). 令 desc 为 the PropertyDescriptor { [[Value]]: methodDef.[[Closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }. 返回 ? DefinePropertyOrThrow(object, methodDef.[[Key]], desc) MethodDefinition : get PropertyName ( ) { FunctionBody } 令 propKey 为运算 PropertyName 的结果 ReturnIfAbrupt(propKey). 若此MethodDefinition的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为 运行时上下文的 LexicalEnvironment. 令 formalParameterList 为产生式的一个实例 FormalParameters : [empty] . 令 closure 为 FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict). 执行 MakeMethod(closure, object). 执行 SetFunctionName(closure, propKey, \"get\"). 设置 closure.[[SourceText]] 为MethodDefinition匹配的源文本. 令 desc 为 the PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }. 返回 ? DefinePropertyOrThrow(object, propKey, desc). MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody } 令 propKey 为运算 PropertyName 的结果 ReturnIfAbrupt(propKey). 若此MethodDefinition的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为 运行时上下文的 LexicalEnvironment. 令 closure 为 FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict). 执行 MakeMethod(closure, object). 执行 SetFunctionName(closure, propKey, \"set\"). 设置 closure.[[SourceText]] 为MethodDefinition匹配的源文本. 令 desc 为 the PropertyDescriptor { [[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }. 返回 ? DefinePropertyOrThrow(object, propKey, desc). 14.4 Generator 函数定义 语法 GeneratorMethod[Yield, Await] : * PropertyName[?Yield, ?Await] ( UniqueFormalParameters[+Yield, ~Await] ) { GeneratorBody } GeneratorDeclaration[Yield, Await, Default] : function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, ~Await] ) { GeneratorBody } [+Default] function * ( FormalParameters[+Yield, ~Await] ) { GeneratorBody } GeneratorExpression : function * BindingIdentifier[+Yield, ~Await] opt ( FormalParameters[+Yield, ~Await] ) { GeneratorBody } GeneratorBody : FunctionBody[+Yield, ~Await] YieldExpression[In, Await] : yield yield [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await] yield [no LineTerminator here] * AssignmentExpression[?In, +Yield, ?Await] 注 1 紧随产生之后的句法上下文需要使用 InputElementRegExpOrTemplateTail 词法目标。 注 2 YieldExpression不能在生成器函数的FormalParameters中使用，因为在生成的生成器对象处于可恢复状态之前，将计算FormalParameters组成部分的任何表达式。 注 3 与生成器对象有关的抽象操作在25.4.3中定义。 14.4.1 静态语义：Early Errors GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody } 若 GeneratorMethod 的 HasDirectSuper 是 true，则为语法错误 若 UniqueFormalParameters 包含YieldExpression 是 true，则为语法错误 若GeneratorBody的ContainsUseStrict为true并且UniqueFormalParameters的IsSimpleParameterList为false，则为语法错误 若GeneratorBody的LexicallyDeclaredNames中还出现UniqueFormalParameters BoundNames的任何元素，则是语法错误。 GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody } GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } 若与此产生式匹配的源代码是严格模式代码，则将应用UniqueFormalParameters：FormalParameters的早期错误规则。 若与此产生式匹配的源代码是严格模式代码，则若存在BindingIdentifier并且BindingIdentifier的StringValue是 \"eval\" 或 \"arguments\"，则它是语法错误。 若GeneratorBody的ContainsUseStrict为true，FormalParameters的IsSimpleParameterList为false，则为语法错误。 若FormalParameters的BoundNames的任何元素也会出现在GeneratorBody的LexicallyDeclaredNames中，则为语法错误 若 FormalParameters 包含YieldExpression 是 true，则为语法错误 若 FormalParameters 包含SuperProperty 是 true，则为语法错误 若 GeneratorBody 包含SuperProperty 是 true，则为语法错误 若 FormalParameters 包含SuperCall 是 true，则为语法错误 若 GeneratorBody 包含SuperCall 是 true，则为语法错误 14.4.2 静态语义：BoundNames GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } 返回 BindingIdentifier 的 BoundNames GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody } 返回 « \"*default*\" ». 注 \"*default*\"在本规范中用作使用导出声明定义的可提升匿名函数的合成名称。 14.4.3 静态语义：ComputedProperty包含 带有参数 symbol. GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody } 返回带有参数symbol的PropertyName的ComputedPropertyContains结果 14.4.4 静态语义：包含 带有参数 symbol. GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody } GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } 返回 false. 注：依赖于子结构的静态语义规则通常不会考虑函数定义。 14.4.5 静态语义：HasDirectSuper GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody } 若 UniqueFormalParameters 包含 SuperCall 是 true, 返回 true. 返回 GeneratorBody 包含 SuperCall. 14.4.6 静态语义：HasName GeneratorExpression : function * ( FormalParameters ) { GeneratorBody } 返回 false. GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } 返回 true 14.4.7 静态语义：IsConstantDeclaration GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody } 返回 false 14.4.8 静态语义：IsFunctionDefinition GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } 返回 true. 14.4.9 静态语义：PropName GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody } 返回 PropertyName 的 PropName 14.4.10 运行时语义：EvaluateBody 带有参数 functionObject 和 argumentsList列表. GeneratorBody : FunctionBody 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList). 令 G 为 ? OrdinaryCreateFromConstructor(functionObject, \"%GeneratorPrototype%\", « [[GeneratorState]], [[GeneratorContext]] ») 执行 GeneratorStart(G, FunctionBody). 返回 Completion { [[Type]]: return, [[Value]]: G, [[Target]]: empty }. 14.4.11 运行时语义：InstantiateFunctionObject 带有参数 scope. GeneratorDeclaration : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } 若 GeneratorDeclaration 的函数代码是严格模式代码，则令strict为true，否则令strict为false 令 name 为 BindingIdentifier 的 StringValue 令 F 为 GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict). 令 prototype 为 ObjectCreate(%GeneratorPrototype%). 执行 DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 SetFunctionName(F, name). 设置 F.[[SourceText]] 为GeneratorDeclaration匹配的源文本. 返回 F GeneratorDeclaration : function * ( FormalParameters ) { GeneratorBody } 令 F 为 GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, true). 令 prototype 为 ObjectCreate(%GeneratorPrototype%). 执行 DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 SetFunctionName(F, \"default\"). 设置 F.[[SourceText]] 为GeneratorDeclaration匹配的源文本. 返回 F. 注：匿名GeneratorDeclaration仅可作为export default声明的一部分出现，因此其函数代码始终为严格模式代码。 14.4.12 运行时语义：PropertyDefinitionEvaluation 带有参数 object 和 enumerable. GeneratorMethod : * PropertyName ( UniqueFormalParameters ) { GeneratorBody } 令 propKey 为运算 PropertyName 的结果 ReturnIfAbrupt(propKey). 若此GeneratorMethod的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为 运行时上下文的 LexicalEnvironment. 令 closure 为 GeneratorFunctionCreate(Method, UniqueFormalParameters, GeneratorBody, scope, strict). 执行 MakeMethod(closure, object). 令 prototype 为 ObjectCreate(%GeneratorPrototype%). 执行 DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 SetFunctionName(closure, propKey). 设置 closure.[[SourceText]] 为GeneratorMethod匹配的源文本. 令 desc 为 the PropertyDescriptor { [[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }. 返回 ? DefinePropertyOrThrow(object, propKey, desc). 14.4.13 运行时语义：NamedEvaluation 带有参数 name. GeneratorExpression : function * ( FormalParameters ) { GeneratorBody } 令 closure 为运算此GeneratorExpression的结果。 执行 SetFunctionName(closure, name). 返回 closure. 14.4.14 运行时语义：Evaluation GeneratorExpression : function * ( FormalParameters ) { GeneratorBody } 若此GeneratorExpression的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 closure 为 GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict). 令 prototype 为 ObjectCreate(%GeneratorPrototype%). 执行 DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 设置 closure.[[SourceText]] 为GeneratorExpression匹配的源文本. 返回 closure GeneratorExpression : function * BindingIdentifier ( FormalParameters ) { GeneratorBody } 若此GeneratorExpression的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为 运行时上下文的 LexicalEnvironment. 令 funcEnv 为 NewDeclarativeEnvironment(scope). 令 envRec 为 funcEnv 的 EnvironmentRecord. 令 name 为 BindingIdentifier 的 StringValue 执行 envRec.CreateImmutableBinding(name, false). 令 closure 为 GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict). 令 prototype 为 ObjectCreate(%GeneratorPrototype%). 执行 DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 SetFunctionName(closure, name). 执行 envRec.InitializeBinding(name, closure). 设置 closure.[[SourceText]] 为GeneratorExpression匹配的源文本. 返回 closure. 注：可以从GeneratorExpression的FunctionBody内部引用GeneratorExpression中的BindingIdentifier，以允许生成器代码递归调用自身。但是，与GeneratorDeclaration中的不同，GeneratorExpression中的BindingIdentifier不能从GeneratorExpression中引用，也不影响封装GeneratorExpression的范围。 YieldExpression : yield 令 generatorKind 为 ! GetGeneratorKind(). 若 generatorKind 是 async，那么 返回 ? AsyncGeneratorYield(undefined). 否则, 返回 ? GeneratorYield(CreateIterResultObject(undefined, false)). YieldExpression : yield AssignmentExpression 令 generatorKind 为 ! GetGeneratorKind(). 令 exprRef 为运算 AssignmentExpression 的结果 令 value 为 ? GetValue(exprRef). 若 generatorKind 是 async，那么 返回 ? AsyncGeneratorYield(value). 否则, 返回 ? GeneratorYield(CreateIterResultObject(value, false)). YieldExpression : yield * AssignmentExpression 令 generatorKind 为 ! GetGeneratorKind(). 令 exprRef 为运算 AssignmentExpression 的结果 令 value 为 ? GetValue(exprRef). 令 iteratorRecord 为 ? GetIterator(value, generatorKind). 令 iterator 为 iteratorRecord.[[Iterator]]. 令 received 为 NormalCompletion(undefined). 重复， 若 received.[[Type]] 是 normal，那么 令 innerResult 为 ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « received.[[Value]] »). 若 generatorKind 是 async，那么 设置 innerResult 为 ? Await(innerResult). 若 Type(innerResult) 不是 Object, 抛出 TypeError 异常. 令 done 为 ? IteratorComplete(innerResult). 若 done 是 true，那么 返回 ? IteratorValue(innerResult). 若 generatorKind 是 async，那么 设置 received 为 AsyncGeneratorYield(? IteratorValue(innerResult)). 否则, 设置 received 为 GeneratorYield(innerResult). 否则 若 received.[[Type]] 是 throw，那么 令 throw 为 ? GetMethod(iterator, \"throw\"). 若 throw 不是 undefined，那么 令 innerResult 为 ? Call(throw, iterator, « received.[[Value]] »). 若 generatorKind 是 async，那么 设置 innerResult 为 ? Await(innerResult). 注: 内部迭代器throw方法的异常会传播。内部throw方法的正常完成与内部next类似。 若 Type(innerResult) 不是 Object, 抛出 TypeError 异常. 令 done 为 ? IteratorComplete(innerResult). 若 done 是 true，那么 返回 ? IteratorValue(innerResult). 若 generatorKind 是 async，那么 设置 received 为 AsyncGeneratorYield(? IteratorValue(innerResult)). 否则, 设置 received 为 GeneratorYield(innerResult). 否则, 注: 若iterator没有throw方法，则此throw将终止yield *循环。但是首先我们需要给迭代器一个清理的机会。 令 closeCompletion 为 Completion { [[Type]]: normal, [[Value]]: empty, [[Target]]: empty }. 若 generatorKind 是 async, 执行 ? AsyncIteratorClose(iteratorRecord, closeCompletion). 否则, 执行 ? IteratorClose(iteratorRecord, closeCompletion). 注: 下一步将引发TypeError，以表明发生了yield *协议违规：iterator没有throw方法。 抛出 TypeError 异常. 否则, 断言: received.[[Type]] 是 return. 令 返回 为 ? GetMethod(iterator, \"return\"). 若 返回 是 undefined，那么 若 generatorKind 是 async，那么 设置 received.[[Value]] 为 ? Await(received.[[Value]]). 返回 Completion(received). 令 innerReturnResult 为 ? Call(return, iterator, « received.[[Value]] »). 若 generatorKind 是 async，那么 设置 innerReturnResult 为 ? Await(innerReturnResult). 若 Type(innerReturnResult) 不是 Object, 抛出 TypeError 异常. 令 done 为 ? IteratorComplete(innerReturnResult). 若 done 是 true，那么 令 value 为 ? IteratorValue(innerReturnResult). 返回 Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }. 若 generatorKind 是 async，那么 设置 received 为 AsyncGeneratorYield(? IteratorValue(innerReturnResult)). 否则, 设置 received 为 GeneratorYield(innerReturnResult). 14.5 异步 Generator 函数定义 语法 AsyncGeneratorMethod[Yield, Await] : async [no LineTerminator here] * PropertyName[?Yield, ?Await] (UniqueFormalParameters[+Yield, +Await] ) { AsyncGeneratorBody } AsyncGeneratorDeclaration[Yield, Await, Default] : async [no LineTerminator here] function * BindingIdentifier[?Yield, ?Await] ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody } [+Default] async [no LineTerminator here] function * ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody } AsyncGeneratorExpression : async [no LineTerminator here] function * BindingIdentifier[+Yield, +Await] opt ( FormalParameters[+Yield, +Await] ) { AsyncGeneratorBody } AsyncGeneratorBody : FunctionBody[+Yield, +Await] 注1：YieldExpression和AwaitExpression不能在异步生成器函数的FormalParameters中使用，因为作为FormalParameters一部分的任何表达式都在生成的异步生成器对象处于可恢复状态之前进行求值 注 2：与异步生成器对象有关的抽象操作在25.5.3中定义。 14.5.1 静态语义：Early Errors AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody } 若 AsyncGeneratorMethod 的 HasDirectSuper 是 true，则为语法错误 若 UniqueFormalParameters 包含 YieldExpression 是 true，则为语法错误 若 UniqueFormalParameters 包含 AwaitExpression 是 true，则为语法错误 若 AsyncGeneratorBody 的 ContainsUseStrict 是 true 并且 UniqueFormalParameters 的 IsSimpleParameterList 是 false，则为语法错误 若UniqueFormalParameters的BoundNames的任何元素也都出现在AsyncGeneratorBody的LexicallyDeclaredNames中，则为语法错误 AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody } AsyncGeneratorExpression : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } 若与此产生式匹配的源代码是严格模式代码，则将应用UniqueFormalParameters：FormalParameters的早期错误规则。 若与此产生式匹配的源代码是严格模式代码，并且若BindingIdentifier是IdentifierName eval或IdentifierName arguments，则它是语法错误。 若AsyncGeneratorBody的ContainsUseStrict为true并且FormalParameters的IsSimpleParameterList为false，则为语法错误。 若 FormalParameters 的 BoundNames 的任何元素也出现在 AsyncGeneratorBody 的 LexicallyDeclaredNames 中，则是语法错误。 若 FormalParameters 包含YieldExpression 是 true，则为语法错误 若 FormalParameters 包含AwaitExpression 是 true，则为语法错误 若 FormalParameters 包含SuperProperty 是 true，则为语法错误 若 AsyncGeneratorBody 包含SuperProperty 是 true，则为语法错误 若 FormalParameters 包含SuperCall 是 true，则为语法错误 若 AsyncGeneratorBody 包含SuperCall 是 true，则为语法错误 14.5.2 静态语义：BoundNames AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } 返回 the BindingIdentifier 的 BoundNames AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody } 返回 « \"*default*\" » 注 \"*default*\"在本规范中用作使用导出声明定义的可提升匿名函数的合成名称。 14.5.3 静态语义：ComputedProperty包含 带有参数 symbol. AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody } 返回带有参数symbol的PropertyName的ComputedPropertyContains结果。 14.5.4 静态语义：包含 带有参数 symbol. AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody } AsyncGeneratorExpression : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } 返回 false. 注：依赖于子结构的静态语义规则通常不会考虑函数定义。 14.5.5 静态语义：HasDirectSuper AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody } 若 UniqueFormalParameters 包含SuperCall 是 true, 返回 true. 返回 AsyncGeneratorBody 包含SuperCall. 14.5.6 静态语义：HasName AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody } 返回 false. AsyncGeneratorExpression : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } 返回 true. 14.5.7 静态语义：IsConstantDeclaration AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody } 返回 false. 14.5.8 静态语义：IsFunctionDefinition AsyncGeneratorExpression : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } 返回 true. 14.5.9 静态语义：PropName AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody } 返回 PropertyName 的 PropName 14.5.10 运行时语义：EvaluateBody 带有参数 functionObject 和 argumentsList列表. AsyncGeneratorBody : FunctionBody 执行 ? FunctionDeclarationInstantiation(functionObject, argumentsList). 令 generator 为 ? OrdinaryCreateFromConstructor(functionObject, \"%AsyncGeneratorPrototype%\", « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]] »). 执行 ! AsyncGeneratorStart(generator, FunctionBody). 返回 Completion { [[Type]]: return, [[Value]]: generator, [[Target]]: empty }. 14.5.11 运行时语义：InstantiateFunctionObject 带有参数 scope. AsyncGeneratorDeclaration : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } 若AsyncGeneratorDeclaration的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 name 为 BindingIdentifier 的 StringValue 令 F 为 ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict). 令 prototype 为 ! ObjectCreate(%AsyncGeneratorPrototype%). 执行 ! DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 ! SetFunctionName(F, name). 设置 F.[[SourceText]] 为AsyncGeneratorDeclaration匹配的源文本. 返回 F. AsyncGeneratorDeclaration : async function * ( FormalParameters ) { AsyncGeneratorBody } 若AsyncGeneratorDeclaration的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 F 为 AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict). 令 prototype 为 ObjectCreate(%AsyncGeneratorPrototype%). 执行 DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 SetFunctionName(F, \"default\"). 设置 F.[[SourceText]] 为AsyncGeneratorDeclaration匹配的源文本. 返回 F 注：匿名AsyncGeneratorDeclaration只能作为 export default 声明的一部分出现。 14.5.12 运行时语义：PropertyDefinitionEvaluation 带有参数 object 和 enumerable. AsyncGeneratorMethod : async * PropertyName ( UniqueFormalParameters ) { AsyncGeneratorBody } 令 propKey 为运算 PropertyName 的结果 ReturnIfAbrupt(propKey). 若此AsyncGeneratorMethod的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为 运行时上下文的 LexicalEnvironment. 令 closure 为 ! AsyncGeneratorFunctionCreate(Method, UniqueFormalParameters, AsyncGeneratorBody, scope, strict). 执行 ! MakeMethod(closure, object). 令 prototype 为 ! ObjectCreate(%AsyncGeneratorPrototype%). 执行 ! DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 ! SetFunctionName(closure, propKey). 设置 closure.[[SourceText]] 为AsyncGeneratorMethod匹配的源文本. 令 desc 为 PropertyDescriptor { [[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }. 返回 ? DefinePropertyOrThrow(object, propKey, desc). 14.5.13 运行时语义：NamedEvaluation 带有参数 name. AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody } 令 closure 为运算此AsyncGeneratorExpression的结果。 执行 SetFunctionName(closure, name). 返回 closure. 14.5.14 运行时语义：Evaluation AsyncGeneratorExpression : async function * ( FormalParameters ) { AsyncGeneratorBody } 若此AsyncGeneratorExpression的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 closure 为 ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict). 令 prototype 为 ! ObjectCreate(%AsyncGeneratorPrototype%). 执行 ! DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 设置 closure.[[SourceText]] 为AsyncGeneratorExpression匹配的源文本. 返回 closure. AsyncGeneratorExpression : async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody } 若此AsyncGeneratorExpression的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为 运行时上下文的 LexicalEnvironment. 令 funcEnv 为 ! NewDeclarativeEnvironment(scope). 令 envRec 为 funcEnv 的 EnvironmentRecord. 令 name 为 BindingIdentifier 的 StringValue 执行 ! envRec.CreateImmutableBinding(name). 令 closure 为 ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, funcEnv, strict). 令 prototype 为 ! ObjectCreate(%AsyncGeneratorPrototype%). 执行 ! DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 执行 ! SetFunctionName(closure, name). 执行 ! envRec.InitializeBinding(name, closure). 设置 closure.[[SourceText]] 为AsyncGeneratorExpression匹配的源文本. 返回 closure. 注：可以从AsyncGeneratorExpression的AsyncGeneratorBody内部引用AsyncGeneratorExpression中的BindingIdentifier，以允许生成器代码递归调用自身。但是，与AsyncGeneratorDeclaration中的方法不同，AsyncGeneratorExpression中的BindingIdentifier不能从引用，也不会影响包围AsyncGeneratorExpression的作用域。 14.6 Class 定义 语法 ClassDeclaration[Yield, Await, Default] : class BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await] [+Default] class ClassTail[?Yield, ?Await] ClassExpression[Yield, Await] : class BindingIdentifier[?Yield, ?Await] opt ClassTail[?Yield, ?Await] ClassTail[Yield, Await] : ClassHeritage[?Yield, ?Await] opt { ClassBody[?Yield, ?Await] opt } ClassHeritage[Yield, Await] : extends LeftHandSideExpression[?Yield, ?Await] ClassBody[Yield, Await] : ClassElementList[?Yield, ?Await] ClassElementList[Yield, Await] : ClassElement[?Yield, ?Await] ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await] ClassElement[Yield, Await] : MethodDefinition[?Yield, ?Await] static MethodDefinition[?Yield, ?Await] ; 注：class定义始终是严格模式代码。 14.6.1 静态语义：Early Errors ClassTail : ClassHeritage { ClassBody } 若 ClassHeritage 不存在，并且下面的算法运算为true，则为语法错误： 令 constructor 为 ClassBody 的 ConstructorMethod 若 constructor 是 empty, 返回 false. 返回 constructor 的 HasDirectSuper ClassBody : ClassElementList 若ClassElementList的PrototypePropertyNameList包含多个“constructor”，则为语法错误。 ClassElement : MethodDefinition 若Method Definition的proName不是“constructor”，且Method Definition的HasDirectSuper为真，则为语法错误。 若MethodDefinition的proName是“constructor”，而SpecialMethod Definition是正确的，则是语法错误。 ClassElement : static MethodDefinition 若 MethodDefinition 的 HasDirectSuper 是 true，则为语法错误 若 MethodDefinition 的 PropName 是 \"prototype\"，则为语法错误 14.6.2 静态语义：BoundNames ClassDeclaration : class BindingIdentifier ClassTail 返回 BindingIdentifier 的 BoundNames ClassDeclaration : class ClassTail 返回 « \"*default*\" ». 14.6.3 静态语义：ConstructorMethod ClassElementList : ClassElement 若 ClassElement 是 ClassElement : ; , 返回 empty. 若 ClassElement 的 IsStatic 是 true, 返回 empty. 若 ClassElement 的 PropName 不是\"constructor\", 返回 empty. 返回 ClassElement. ClassElementList : ClassElementList ClassElement 令 head 为 ClassElementList 的 ConstructorMethod 若 head 不是 empty, 返回 head. 若 ClassElement 是 ClassElement : ; , 返回 empty. 若 ClassElement 的 IsStatic 是 true, 返回 empty. 若 ClassElement 的 PropName 不是\"constructor\", 返回 empty. 返回 ClassElement 注：早期错误规则确保只有一个名为“constructor”的方法定义，并且它不是访问器属性或生成器定义。 14.6.4 静态语义：包含 带有参数 symbol. ClassTail : ClassHeritage { ClassBody } 若 symbol 是 ClassBody, 返回 true. 若 symbol 是 ClassHeritage，那么 若 ClassHeritage 存在, 返回 true; 否则 返回 false. 令 inHeritage 为 ClassHeritage 包含symbol. 若 inHeritage 是 true, 返回 true. 返回对于具有参数symbol的ClassBody，计算属性的结果。 注：依赖于子结构的静态语义规则通常不会查看类主体，除了PropertyNames。 14.6.5 静态语义：ComputedProperty包含 带有参数 symbol. ClassElementList : ClassElementList ClassElement 令 inList 为带参数symbol的ClassElementList的ComputedPropertyContains结果. 若 inList 是 true, 返回 true. 返回带参数symbol的ClassElement的ComputedPropertyContains结果. ClassElement : MethodDefinition 返回带参数symbol的MethodDefinition的ComputedPropertyContains结果 ClassElement : static MethodDefinition 返回带参数symbol的MethodDefinition的ComputedPropertyContains结果. ClassElement : ; 返回 false. 14.6.6 静态语义：HasName ClassExpression : class ClassTail 返回 false. ClassExpression : class BindingIdentifier ClassTail 返回 true. 14.6.7 静态语义：IsConstantDeclaration ClassDeclaration : class BindingIdentifier ClassTail ClassDeclaration : class ClassTail 返回 false. 14.6.8 静态语义：IsFunctionDefinition ClassExpression : class BindingIdentifier ClassTail 返回 true. 14.6.9 静态语义：IsStatic ClassElement : MethodDefinition 返回 false. ClassElement : static MethodDefinition 返回 true. ClassElement : ; 返回 false. 14.6.10 静态语义：NonConstructorMethodDefinitions ClassElementList : ClassElement 若 ClassElement 是 ClassElement : ; , 返回一个新的空列表. 若 ClassElement 的 IsStatic 是 false，并且 ClassElement 的 PropName 是 \"constructor\", 返回一个新的空列表. 返回 a List containing ClassElement. ClassElementList : ClassElementList ClassElement 令 list 为 ClassElementList 的 NonConstructorMethodDefinitions 若 ClassElement 是 ClassElement : ; , 返回 list. 若 ClassElement 的 IsStatic 是 false，并且 ClassElement 的 PropName 是 \"constructor\", 返回 list. 将ClassElement追加到列表的末尾。 返回 list. 14.6.11 静态语义：PrototypePropertyNameList ClassElementList : ClassElement 若 ClassElement 的 PropName 是 empty, 返回一个新的空列表. 若 ClassElement 的 IsStatic 是 true, 返回一个新的空列表. 返回一个包含ClassElement的PropName的列表。 ClassElementList : ClassElementList ClassElement 令 list 为 ClassElementList 的 PrototypePropertyNameList 若 ClassElement 的 PropName 是 empty, 返回 list. 若 ClassElement 的 IsStatic 是 true, 返回 list. 将ClassElement的PropName追加到列表的末尾 返回 list. 14.6.12 静态语义：PropName ClassElement : ; 返回 empty. 14.6.13 运行时语义：ClassDefinitionEvaluation 带有参数 classBinding 和 className ClassTail : ClassHeritage { ClassBody } 令 lex 为运行时上下文的LexicalEnvironment. 令 classScope 为 NewDeclarativeEnvironment(lex). 令 classScopeEnvRec 为 classScope 的 EnvironmentRecord. 若 classBinding 不是 undefined，那么 执行 classScopeEnvRec.CreateImmutableBinding(classBinding, true). 若 ClassHeritageopt 不存在，那么 令 protoParent 为内部对象 %ObjectPrototype%. 令 constructorParent 为内部对象 %FunctionPrototype%. 否则, 设置 运行时上下文的 LexicalEnvironment 为 classScope. 令 superclassRef 为运算 ClassHeritage 的结果 设置 运行时上下文的 LexicalEnvironment 为 lex. 令 superclass 为 ? GetValue(superclassRef). 若 superclass 是 null，那么 令 protoParent 为 null. 令 constructorParent 为内部对象 %FunctionPrototype%. 否则 若 IsConstructor(superclass) 是 false, 抛出 TypeError 异常. 否则, 令 protoParent 为 ? Get(superclass, \"prototype\"). 若 Type(protoParent) 不是 Object 或 Null, 抛出 TypeError 异常. 令 constructorParent 为 superclass. 令 proto 为 ObjectCreate(protoParent). 若 ClassBodyopt 不存在, 令 constructor 为 empty. 否则, 令 constructor 为 ClassBody 的 ConstructorMethod 若 constructor 是 empty，那么 若 ClassHeritageopt 存在，那么 设置 constructor 为解析源文本的结果 constructor(... args){ super (...args);} using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await] . 否则, 设置 constructor 为解析源文本的结果 constructor(... args){ super (...args);} using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await] . 设置 运行时上下文的 LexicalEnvironment 为 classScope. 令 constructorInfo 为使用参数proto和ConstructorParent作为可选functionPrototype参数为构造函数执行DefineMethod的结果。 断言: builderInfo不是 abrupt completion. 令 F 为 constructorInfo.[[Closure]]. 若 ClassHeritageopt 存在, 设置 F.[[ConstructorKind]] 为 \"derived\". 执行 MakeConstructor(F, false, proto). 执行 MakeClassConstructor(F). 若 className 不是 undefined，那么 执行 SetFunctionName(F, className). 执行 CreateMethodProperty(proto, \"constructor\", F). 若 ClassBodyopt 不存在, 令 methods 为一个新的空列表. 否则, 令 methods 为 ClassBody 的 NonConstructorMethodDefinitions 对于methods的每一个按顺序的 ClassElement m, 执行 若 m 的 IsStatic 是 false，那么 令 status 为使用参数proto和false对m执行PropertyDefinitionEvaluation的结果。 否则, 令 status 为使用参数F和false对m执行PropertyDefinitionEvaluation的结果。 若 status 是 abrupt completion，那么 设置 运行时上下文的 LexicalEnvironment 为 lex. 返回 Completion(status). 设置 运行时上下文的 LexicalEnvironment 为 lex. 若 classBinding 不是 undefined，那么 执行 classScopeEnvRec.InitializeBinding(classBinding, F). 返回 F. 14.6.14 运行时语义：BindingClassDeclarationEvaluation ClassDeclaration : class BindingIdentifier ClassTail 令 className 为 BindingIdentifier 的 StringValue 令 value 为带参数className和className的ClassTail的ClassDefinitionEvaluation结果 ReturnIfAbrupt(value). 设置 value.[[SourceText]] 为ClassDeclaration匹配的源文本. 令 env 为 运行时上下文的 LexicalEnvironment. 执行 ? InitializeBoundName(className, value, env). 返回 value. ClassDeclaration : class ClassTail 令 value 为参数undefined和“default”的ClassTail的ClassDefinitionEvaluation结果。 ReturnIfAbrupt(value). 设置 value.[[SourceText]] 为ClassDeclaration匹配的源文本. 返回 value. 注：ClassDeclaration：ClassTail类仅作为ExportDeclaration的一部分出现，并且建立其绑定是 作为该产生式运算动作的一部分进行处理。见15.2.3.11。 14.6.15 运行时语义：NamedEvaluation 带有参数 name. ClassExpression : class ClassTail 返回参数undefined和名称的ClassTail的ClassDefinitionEvaluation结果 14.6.16 运行时语义：Evaluation ClassDeclaration : class BindingIdentifier ClassTail 执行 ? 此 ClassDeclaration 的 BindingClassDeclarationEvaluation. 返回 NormalCompletion(empty). 注：ClassDeclaration：ClassTail类仅作为ExportDeclaration的一部分出现，并且从不直接运算 ClassExpression : class BindingIdentifier ClassTail 若 BindingIdentifieropt 不存在, 令 className 为 undefined. 否则, 令 className 为 BindingIdentifier 的 StringValue 令 value 为参数为className和className的ClassTail的ClassDefinitionEvaluation结果。 ReturnIfAbrupt(value). 设置 value.[[SourceText]] 为ClassExpression匹配的源文本. 返回 value. 14.7 Async 函数定义 语法 AsyncFunctionDeclaration[Yield, Await, Default] : async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody } [+Default] async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody } AsyncFunctionExpression : async [no LineTerminator here] function ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody } async [no LineTerminator here] function BindingIdentifier[~Yield, +Await] ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody } AsyncMethod[Yield, Await] : async [no LineTerminator here] PropertyName[?Yield, ?Await] ( UniqueFormalParameters[~Yield, +Await] ) { AsyncFunctionBody } AsyncFunctionBody : FunctionBody[~Yield, +Await] AwaitExpression[Yield] : await UnaryExpression[?Yield, +Await] 注 1：若存在[Await]参数，则将await解析为AwaitExpression。 [Await]参数出现在以下上下文中： 在AsyncFunctionBody中。 在AsyncFunctionDeclaration，AsyncFunctionExpression，AsyncGeneratorDeclaration或AsyncGeneratorExpression的FormalParameters中。 AwaitExpression在此位置是通过静态语义的语法错误。 当Module是语法目标符号并且[Await]参数不存在时，await将被解析为关键字，并且将是语法错误。当Script是语法目标符号时，若[Await]参数不存在，则等待可能被解析为标识符。这包括以下上下文： AsyncFunctionBody或AsyncFunctionDeclaration，AsyncFunctionExpression，AsyncGeneratorDeclaration或AsyncGeneratorExpression的FormalParameters之外的任何位置。在FunctionExpression，GeneratorExpression或AsyncGeneratorExpression的BindingIdentifier中 注 2：与YieldExpression不同，省略AwaitExpression的操作数是语法错误。您必须等待。 14.7.1 静态语义：Early Errors AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody } 若AsyncFunctionBody的ContainsUseStrict为true，并且UniqueFormalParameters的IsSimpleParameterList为false，则为语法错误。 若 AsyncMethod 的 HasDirectSuper 是 true，则为语法错误 若 UniqueFormalParameters 包含AwaitExpression 是 true，则为语法错误 若UniqueFormalParameters的BoundNames的任何元素也出现在AsyncFunctionBody的LexicallyDeclaredNames中，则是语法错误。 AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 若AsyncFunctionBody的ContainsUseStrict为true，并且FormalParameters的IsSimpleParameterList为false，则为语法错误。 若 FormalParameters 包含 AwaitExpression 是 true，则为语法错误 若与此产品匹配的源代码是严格代码，则将应用UniqueFormalParameters：FormalParameters的Early Error规则。 若与此生产匹配的源代码是严格代码，则若存在BindingIdentifier并且BindingIdentifier的StringValue为“ eval”或“ arguments”，则它是语法错误。 若FormalParameters的BoundNames的任何元素也出现在AsyncFunctionBody的LexicallyDeclaredNames中，则是语法错误。 若 FormalParameters 包含SuperProperty 是 true，则为语法错误 若 AsyncFunctionBody 包含SuperProperty 是 true，则为语法错误 若 FormalParameters 包含SuperCall 是 true，则为语法错误 若 AsyncFunctionBody 包含SuperCall 是 true，则为语法错误 14.7.2 静态语义：BoundNames AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 返回 BindingIdentifier 的 BoundNames AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody } 返回 « \"*default*\" ». 注 \"*default*\"在本规范中用作使用导出声明定义的可提升匿名函数的合成名称。. 14.7.3 静态语义：ComputedProperty包含 带有参数 symbol. AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody } 返回带参数symbol的PropertyName的ComputedPropertyContains结果. 14.7.4 静态语义：包含 带有参数 symbol. AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 返回 false. 14.7.5 静态语义：HasDirectSuper AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody } 若 UniqueFormalParameters 包含SuperCall 是 true, 返回 true. 返回 AsyncFunctionBody 包含SuperCall. 14.7.6 静态语义：HasName AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody } 返回 false AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 返回 true. 14.7.7 静态语义：IsConstantDeclaration AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody } 返回 false. 14.7.8 静态语义：IsFunctionDefinition AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody } AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 返回 true. 14.7.9 静态语义：PropName AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody } 返回 PropertyName 的 PropName 14.7.10 运行时语义：InstantiateFunctionObject 带有参数 scope. AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 如果AsyncFunctionDeclaration的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 name 为 BindingIdentifier 的 StringValue 令 F 为 ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict). 执行 ! SetFunctionName(F, name). 设置 F.[[SourceText]] 为AsyncFunctionDeclaration匹配的源文本. 返回 F AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody } 若如果AsyncFunctionDeclaration的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 F 为 ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict). 执行 ! SetFunctionName(F, \"default\"). 设置 F.[[SourceText]] 为AsyncFunctionDeclaration匹配的源文本. 返回 F. 14.7.11 运行时语义：EvaluateBody 带有参数 functionObject 和 argumentsList列表. AsyncFunctionBody : FunctionBody 令 promiseCapability 为 ! NewPromiseCapability(%Promise%). 令 declResult 为 FunctionDeclarationInstantiation(functionObject, argumentsList). 若 declResult 不是 abrupt completion，那么 执行 ! AsyncFunctionStart(promiseCapability, FunctionBody). 否则 declResult 是 abrupt completion, 执行 ! Call(promiseCapability.[[Reject]], undefined, « declResult.[[Value]] »). 返回 Completion { [[Type]]: 返回, [[Value]]: promiseCapability.[[Promise]], [[Target]]: empty }. 14.7.12 运行时语义：PropertyDefinitionEvaluation 带有参数 object 和 enumerable. AsyncMethod : async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody } 令 propKey 为运算 PropertyName 的结果 ReturnIfAbrupt(propKey). 若此AsyncMethod的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 closure 为 ! AsyncFunctionCreate(Method, UniqueFormalParameters, AsyncFunctionBody, scope, strict). 执行 ! MakeMethod(closure, object). 执行 ! SetFunctionName(closure, propKey). 设置 closure.[[SourceText]] 为AsyncMethod匹配的源文本. 令 desc 为 PropertyDescriptor { [[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }. 返回 ? DefinePropertyOrThrow(object, propKey, desc). 14.7.13 运行时语义：NamedEvaluation 带有参数 name. AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody } 令 closure 为运算此AsyncFunctionExpression的结果 执行 SetFunctionName(closure, name). 返回 closure 14.7.14 运行时语义：Evaluation AsyncFunctionDeclaration : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 返回 NormalCompletion(empty) AsyncFunctionDeclaration : async function ( FormalParameters ) { AsyncFunctionBody } 返回 NormalCompletion(empty). AsyncFunctionExpression : async function ( FormalParameters ) { AsyncFunctionBody } 若AsyncFunctionExpression的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 closure 为 ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict). 设置 closure.[[SourceText]] 为AsyncFunctionExpression匹配的源文本. 返回 closure. AsyncFunctionExpression : async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody } 若AsyncFunctionExpression的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 funcEnv 为 ! NewDeclarativeEnvironment(scope). 令 envRec 为 funcEnv 的 EnvironmentRecord. 令 name 为 BindingIdentifier 的 StringValue 执行 ! envRec.CreateImmutableBinding(name). 令 closure 为 ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, funcEnv, strict). 执行 ! SetFunctionName(closure, name). 执行 ! envRec.InitializeBinding(name, closure). 设置 closure.[[SourceText]] 为AsyncFunctionExpression匹配的源文本. 返回 closure. AwaitExpression : await UnaryExpression 令 exprRef 为运算 UnaryExpression 的结果 令 value 为 ? GetValue(exprRef). 返回 ? Await(value) 14.8 Async 箭头函数 语法 AsyncArrowFunction[In, Yield, Await] : async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In] CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] => AsyncConciseBody[?In] AsyncConciseBody[In] : [lookahead ≠ {] AssignmentExpression[?In, ~Yield, +Await] { AsyncFunctionBody } AsyncArrowBindingIdentifier[Yield] : BindingIdentifier[?Yield, +Await] CoverCallExpressionAndAsyncArrowHead[Yield, Await] : MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await] 补充语法 处理产生式的实例时 AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody，使用以下语法完善CoverCallExpressionAndAsyncArrowHead的解释： AsyncArrowHead : async [no LineTerminator here] ArrowFormalParameters[~Yield, +Await] 14.8.1 静态语义：Early Errors AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody 若AsyncArrowBindingIdentifier的BoundNames中的任何元素也出现在AsyncConciseBody的LexicallyDeclaredNames中。，则为语法错误 AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody 若 CoverCallExpressionAndAsyncArrowHead 包含 YieldExpression 是 true，则为语法错误 若 CoverCallExpressionAndAsyncArrowHead 包含 AwaitExpression 是 true，则为语法错误 若 CoverCallExpressionAndAsyncArrowHead 没有覆盖 AsyncArrowHead。，则为语法错误 如果CoverCallExpressionAndAsyncArrowHead的BoundNames中的任何元素也出现在AsyncConciseBody的LexicallyDeclaredNames中，则是语法错误。 如果AsyncConciseBody的ContainsUseStrict为true，并且CoverCallExpressionAndAsyncArrowHead的IsSimpleParameterList为false，则为语法错误。 AsyncArrowHead及其衍生产生式的所有早期错误规则均适用于CoverCallExpressionAndAsyncArrowHead的CoveredAsyncArrowHead。 14.8.2 静态语义：CoveredAsyncArrowHead CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments 返回被CoverCallExpressionAndAsyncArrowHead覆盖的AsyncArrowHead。 14.8.3 静态语义：BoundNames CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments 令 head 为 CoverCallExpressionAndAsyncArrowHead 的 CoveredAsyncArrowHead 返回 head 的 BoundNames 14.8.4 静态语义：包含 带有参数 symbol. AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody 若 symbol 不是 NewTarget, SuperProperty, SuperCall, super, 或 this 其中之一, 返回 false. 返回 AsyncConciseBody 包含symbol. AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody 若 symbol 不是 NewTarget, SuperProperty, SuperCall, super, 或 this 其中之一, 返回 false. 令 head 为 CoverCallExpressionAndAsyncArrowHead 的 CoveredAsyncArrowHead 若 head 包含symbol 是 true, 返回 true. 返回 AsyncConciseBody 包含symbol. 注：通常，Contains并不在大多数函数表单中。但是，Contains用于检测AsyncArrowFunction中的new.target、this和super用法。 14.8.5 静态语义：ContainsExpression AsyncArrowBindingIdentifier : BindingIdentifier 返回 false. 14.8.6 静态语义：ExpectedArgumentCount AsyncArrowBindingIdentifier : BindingIdentifier 返回 1. 14.8.7 静态语义：HasName AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody 返回 false. 14.8.8 静态语义：IsSimpleParameterList AsyncArrowBindingIdentifier : BindingIdentifier 返回 true. CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments 令 head 为 CoverCallExpressionAndAsyncArrowHead 的 CoveredAsyncArrowHead 返回 head 的 IsSimpleParameterList 14.8.9 静态语义：LexicallyDeclaredNames AsyncConciseBody : AssignmentExpression 返回一个新的空列表. 14.8.10 静态语义：LexicallyScopedDeclarations AsyncConciseBody : AssignmentExpression 返回一个新的空列表. 14.8.11 静态语义：VarDeclaredNames AsyncConciseBody : AssignmentExpression 返回一个新的空列表. 14.8.12 静态语义：VarScopedDeclarations AsyncConciseBody : AssignmentExpression 返回一个新的空列表. 14.8.13 运行时语义：IteratorBindingInitialization 带有参数 iteratorRecord 和 environment. AsyncArrowBindingIdentifier : BindingIdentifier 断言: iteratorRecord.[[Done]] 是 false. 令 next 为 IteratorStep(iteratorRecord). 若 next 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(next). 若 next 是 false, 设置 iteratorRecord.[[Done]] 为 true. 否则, 令 v 为 IteratorValue(next). 若 v 是 abrupt completion, 设置 iteratorRecord.[[Done]] 为 true. ReturnIfAbrupt(v). 若 iteratorRecord.[[Done]] 是 true, 令 v 为 undefined. 返回使用v和environment作为参数对BindingIdentifier执行BindingInitialization的结果。 14.8.14 运行时语义：EvaluateBody 带有参数 functionObject 和 argumentsList列表. AsyncConciseBody : AssignmentExpression 令 promiseCapability 为 ! NewPromiseCapability(%Promise%). 令 declResult 为 FunctionDeclarationInstantiation(functionObject, argumentsList). 若 declResult 不是 abrupt completion，那么 执行 ! AsyncFunctionStart(promiseCapability, AssignmentExpression). 否则 declResult 是 abrupt completion, 执行 ! Call(promiseCapability.[[Reject]], undefined, « declResult.[[Value]] »). 返回 Completion { [[Type]]: return, [[Value]]: promiseCapability.[[Promise]], [[Target]]: empty }. AsyncConciseBody : { AsyncFunctionBody } 返回AsyncFunctionBody的EvaluateBody将functionObject和argumentsList作为参数传递的结果。 14.8.15 运行时语义：NamedEvaluation 带有参数 name. AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody 令 closure 为运算此AsyncArrowFunction的结果. 执行 SetFunctionName(closure, name). 返回 closure. 14.8.16 运行时语义：Evaluation AsyncArrowFunction : async AsyncArrowBindingIdentifier => AsyncConciseBody 若此AsyncArrowFunction的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 parameters 为 AsyncArrowBindingIdentifier. 令 closure 为 ! AsyncFunctionCreate(Arrow, parameters, AsyncConciseBody, scope, strict). 返回 closure. AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead => AsyncConciseBody 若此AsyncArrowFunction的函数代码是严格模式代码, 令 strict 为 true. 否则，令 strict 为 false. 令 scope 为运行时上下文的LexicalEnvironment. 令 head 为 CoverCallExpressionAndAsyncArrowHead 的 CoveredAsyncArrowHead 令 parameters 为 head 的 ArrowFormalParameters 令 closure 为 ! AsyncFunctionCreate(Arrow, parameters, AsyncConciseBody, scope, strict). 返回 closure. 14.9 尾调用 14.9.1 静态语义：IsInTailPosition ( call ) 带有参数call的抽象操作IsInTailPosition执行以下步骤: 断言: call 是一个解析节点. 若源代码匹配调用是非严格代码, 返回 false. 若 call 不包含在 FunctionBody, ConciseBody, 或 AsyncConciseBody 中, 返回 false. 令 body 成为最包含call的FunctionBody、ConciseBody或AsyncConciseBody。 若 body 是 GeneratorBody 的 FunctionBody , 返回 false. 若 body 是 AsyncFunctionBody 的 FunctionBody, 返回 false. 若 body 是 AsyncGeneratorBody 的 FunctionBody, 返回 false. 若 body 是 AsyncConciseBody, 返回 false. 返回带参数call 的 body 的 HasCallInTailPosition 的结果 注：尾部位置调用仅在严格模式代码中定义，因为有一个通用的非标准语言扩展(参见9.2.9)，它支持观察调用者上下文链。 14.9.2 静态语义：HasCallInTailPosition 带有参数 call. 注：call是一个表示特定范围的源文本的解析节点。当以下算法将call与另一个解析节点进行比较时，将测试它们是否表示相同的源文本。 14.9.2.1 Statement Rules ConciseBody : AssignmentExpression 返回带有参数 call 的 AssignmentExpression 的 HasCallInTailPosition。 StatementList : StatementList StatementListItem 令 has 为带有参数 call 的 StatementList 的 HasCallInTailPosition。 若 has 是 true, 返回 true. 返回带有参数 call 的 StatementListItem 的 HasCallInTailPosition。 FunctionStatementList : [empty] StatementListItem : Declaration Statement : VariableStatement EmptyStatement ExpressionStatement ContinueStatement BreakStatement ThrowStatement DebuggerStatement Block : { } ReturnStatement : return ; LabelledItem : FunctionDeclaration IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement for ( var ForBinding of AssignmentExpression ) Statement for ( ForDeclaration of AssignmentExpression ) Statement CaseBlock : { } 返回 false. IfStatement : if ( Expression ) Statement else Statement 令 has 为带有参数call的第一个语句的HasCallInTailPosition。 若 has 是 true, 返回 true. 返回带有参数call的第二个语句的HasCallInTailPosition。 IfStatement : if ( Expression ) Statement IterationStatement : do Statement while ( Expression ) ; while ( Expression ) Statement for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement for ( LexicalDeclaration Expressionopt ; Expressionopt ) Statement for ( LeftHandSideExpression in Expression ) Statement for ( var ForBinding in Expression ) Statement for ( ForDeclaration in Expression ) Statement WithStatement : with ( Expression ) Statement 返回具有参数call的Statement的HasCallInTailPosition LabelledStatement : LabelIdentifier : LabelledItem 返回具有参数call的LabelledItem的HasCallInTailPosition ReturnStatement : 返回 Expression ; 返回具有参数call的Expression的HasCallInTailPosition. SwitchStatement : switch ( Expression ) CaseBlock 返回具有参数call的CaseBlock的HasCallInTailPosition CaseBlock : { CaseClauses DefaultClause CaseClauses } 令 has 为 false. 若 the first CaseClauses 存在, 令 has 为具有参数call的第一个CaseClauses的HasCallInTailPosition。 若 has 是 true, 返回 true. 令 has 为带参数call的DefaultClause的HasCallInTailPosition。 若 has 是 true, 返回 true. 如果存在第二个CaseClauses，则令has成为带有参数call的第二个CaseClauses的HasCallInTailPosition。 返回 has. CaseClauses : CaseClauses CaseClause 令 has 为具有参数call的CaseClauses的HasCallInTailPosition. 若 has 是 true, 返回 true. 返回具有参数call的CaseClause的HasCallInTailPosition. CaseClause : case Expression : StatementList DefaultClause : default : StatementList 若 StatementList 存在, 返回具有参数call的StatementList的HasCallInTailPosition. 返回 false. TryStatement : try Block Catch 返回具有参数call的Catch的HasCallInTailPosition. TryStatement : try Block Finally TryStatement : try Block Catch Finally 返回具有参数call的Finally的HasCallInTailPosition Catch : catch ( CatchParameter ) Block 返回具有参数call的Block的HasCallInTailPosition. 14.9.2.2 Expression Rules 注：潜在的尾部位置调用（紧随其后的是调用结果的返回GetValue）也是可能的尾部位置调用。函数调用不能返回参考值，因此，此类GetValue操作将始终返回与实际函数调用结果相同的值。 AssignmentExpression : YieldExpression ArrowFunction AsyncArrowFunction LeftHandSideExpression = AssignmentExpression LeftHandSideExpression AssignmentOperator AssignmentExpression BitwiseANDExpression : BitwiseANDExpression & EqualityExpression BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression EqualityExpression : EqualityExpression == RelationalExpression EqualityExpression != RelationalExpression EqualityExpression === RelationalExpression EqualityExpression !== RelationalExpression RelationalExpression : RelationalExpression ShiftExpression RelationalExpression = ShiftExpression RelationalExpression instanceof ShiftExpression RelationalExpression in ShiftExpression ShiftExpression : ShiftExpression > AdditiveExpression ShiftExpression >>> AdditiveExpression AdditiveExpression : AdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression ExponentiationExpression : UpdateExpression ** ExponentiationExpression UpdateExpression : LeftHandSideExpression ++ LeftHandSideExpression -- ++ UnaryExpression -- UnaryExpression UnaryExpression : delete UnaryExpression void UnaryExpression typeof UnaryExpression + UnaryExpression - UnaryExpression ~ UnaryExpression ! UnaryExpression AwaitExpression CallExpression : SuperCall CallExpression [ Expression ] CallExpression . IdentifierName NewExpression : new NewExpression MemberExpression : MemberExpression [ Expression ] MemberExpression . IdentifierName SuperProperty MetaProperty new MemberExpression Arguments PrimaryExpression : this IdentifierReference Literal ArrayLiteral ObjectLiteral FunctionExpression ClassExpression GeneratorExpression AsyncFunctionExpression AsyncGeneratorExpression RegularExpressionLiteral TemplateLiteral 返回 false. Expression : AssignmentExpression Expression , AssignmentExpression 返回具有参数call的AssignmentExpression的HasCallInTailPosition. ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression 令 has 为带参数call的第一个AssignmentExpression的HasCallInTailPosition。 若 has 是 true, 返回 true. 返回具有参数call的第二个AssignmentExpression的HasCallInTailPosition LogicalANDExpression : LogicalANDExpression && BitwiseORExpression 返回具有参数call的BitwiseORExpression的HasCallInTailPosition. LogicalORExpression : LogicalORExpression || LogicalANDExpression 返回具有参数call的LogicalANDExpression的HasCallInTailPosition. CallExpression : CoverCallExpressionAndAsyncArrowHead CallExpression Arguments CallExpression TemplateLiteral 若此 CallExpression 是 call, 返回 true. 返回 false. MemberExpression : MemberExpression TemplateLiteral 若此 MemberExpression 是 call, 返回 true. 返回 false. PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList 令 expr 为 CoverParenthesizedExpressionAndArrowParameterList 的 CoveredParenthesizedExpression 返回具有参数call的expr的HasCallInTailPosition. ParenthesizedExpression : ( Expression ) 返回具有参数call的Expression的HasCallInTailPosition 14.9.3 运行时语义：PrepareForTailCall ( ) 抽象操作PrepareForTailCall执行以下步骤： 令 leafContext 为 运行时上下文. 挂起 leafContext. 从执行上下文堆栈中弹出leafContext。现在堆栈顶部的执行上下文成为正在运行的执行上下文。 断言: leafContext没有进一步的用途。它永远不会作为正在运行的执行参数被激活 尾位置调用必须在调用目标函数之前释放与当前执行的函数执行上下文相关的任何临时内部资源，或者重用这些资源以支持目标函数。 注：例如，尾部位置调用应该只将实现的激活记录堆栈的大小增加到目标函数的激活记录的大小超过调用函数的激活记录的大小。如果目标函数的激活记录较小，则堆栈的总大小应该减小。 "},"scripts-and-modules.html":{"url":"scripts-and-modules.html","title":"15 ECMAScript语言：脚本和模块","keywords":"","body":"15 ECMAScript语言：脚本和模块 15.1 脚本 语法 Script : ScriptBodyopt ScriptBody : StatementList[~Yield, ~Await, ~return] 15.1.1 静态语义：Early Errors Script : ScriptBody 若ScriptBody的LexicallyDeclaredNames包含任何重复的条目，这是一个语法错误。 若ScriptBody的LexicallyDeclaredNames的任何元素也出现在ScriptBody的VarDeclaredNames中，这是一个语法错误。 ScriptBody : StatementList 若StatementList包含super，则是语法错误，除非包含super的源代码是由直接eval处理的eval代码。在18.2.1.1中定义了直接求值的super额外早期错误规则。 若StatementList包含了NewTarget，这是一个语法错误，除非包含NewTarget的源代码是由直接eval处理的eval代码。在18.2.1.1中定义了直接求值的super额外早期错误规则。 若包含带有参数«»的重复声明列表为真，这是一个语法错误。 若带有参数«»的StatementList的ContainsUndefinedBreakTarget为真，这是一个语法错误。 若带有参数«»和«»的StatementList的ContainsUndefinedContinueTarget为真，则为语法错误。 15.1.2 静态语义：IsStrict ScriptBody : StatementList 若指令的声明列表的序言包含一个使用严格指令，返回true；否则,返回false。 15.1.3 静态语义：LexicallyDeclaredNames ScriptBody : StatementList 返回StatementList的TopLevelLexicallyDeclaredNames 注：在Script的顶层，将函数声明视为var声明，而不是词法声明。 15.1.4 静态语义：LexicallyScopedDeclarations ScriptBody : StatementList 返回StatementList的TopLevelLexicallyScopedDeclarations。 15.1.5 静态语义：VarDeclaredNames ScriptBody : StatementList 返回StatementList的TopLevelVarDeclaredNames 。 15.1.6 静态语义：VarScopedDeclarations ScriptBody : StatementList 返回StatementList的TopLevelVarScopedDeclarations 。 15.1.7 运行时语义：Evaluation Script : [empty] 返回 NormalCompletion(undefined). 15.1.8 脚本记录 脚本记录封装了有关正在求值的脚本的信息。每个脚本记录都包含表36中列出的字段。 表格 36: Script Record Fields 字段名 值类型 意义 [[Realm]] 作用域记录项 \\ undefined 在其中创建此脚本的作用域。undefined（若尚未分配）。 [[Environment]] 词法环境 \\ undefined 包含此脚本的顶级绑定的词法环境。实例化脚本时设置此字段。 [[ECMAScriptCode]] 解析节点 使用脚本作为目标符号解析此模块的源文本的结果。 [[HostDefined]] 任意，默认值为undefined 保留给需要将其他信息与脚本关联的主机环境使用的字段。 15.1.9 ParseScript ( sourceText, realm, hostDefined ) 具有参数sourceText，realm和hostDefined的抽象操作ParseScript会基于将sourceText解析为脚本的结果来创建脚本记录。 ParseScript执行以下步骤： 断言: sourceText是ECMAScript源文本（请参见第10节）。 使用Script作为目标符号来解析sourceText，并分析任何早期错误条件的解析结果。若解析成功并且未发现早期错误，则将body作为结果解析树。否则，将body作为代表解析错误和/或早期错误的一个或多个SyntaxError或ReferenceError对象的列表。解析和早期错误检测可以以依赖于实现的方式进行交织。若存在多个解析错误或早期错误，则列表中错误对象的数量和顺序与实现有关，但必须至少存在一个。 若 body 是 errors 列表, 返回 body. 返回 Script Record { [[Realm]]: realm, [[Environment]]: undefined, [[ECMAScriptCode]]: body,[[HostDefined]]: hostDefined }. 注：在运算ParseScript脚本源文本之前，实现可能会解析脚本源文本并针对早期错误条件对其进行分析。但是，任何错误的报告都必须推迟到该规范对该源文本实际执行ParseScript为止。 15.1.10 ScriptEvaluation ( scriptRecord ) 令 globalEnv 为 scriptRecord.[[Realm]].[[GlobalEnv]]. 令 scriptCxt 为新的ECMAScript代码执行上下文。 设置 scriptCxt 的 Function 为 null. 设置 scriptCxt 的 Realm 为 scriptRecord.[[Realm]]. 设置 scriptCxt 的 ScriptOrModule 为 scriptRecord. 设置 scriptCxt 的 VariableEnvironment 为 globalEnv. 设置 scriptCxt 的 LexicalEnvironment 为 globalEnv. 挂起当前正在运行的执行上下文 将scriptCxt推入执行上下文堆栈；现在，scriptCxt是正在运行的执行上下文。 令 scriptBody 为 scriptRecord.[[ECMAScriptCode]]. 令 result 为 GlobalDeclarationInstantiation(scriptBody, globalEnv). 若 result.[[Type]] 是 normal，那么 设置 result 为运算scriptBody的结果。 若 result.[[Type]] 是 normal，并且 result.[[Value]] 是 empty，那么 设置 result 为 NormalCompletion(undefined). 挂起scriptCxt并将其从执行上下文堆栈中删除。 断言: 执行上下文堆栈不为空。 将现在位于执行上下文堆栈顶部的上下文恢复为运行中的执行上下文。 返回 Completion(result). 15.1.11 运行时语义：GlobalDeclarationInstantiation ( script, env ) 注 1：建立用于运算脚本的执行上下文时，将在当前全局环境中实例化声明。代码中声明的每个全局绑定都被实例化。 GlobalDeclarationInstantiation使用参数脚本和env如下执行。脚本是为其建立执行上下文的ScriptBody。 env是要在其中创建绑定的全局词汇环境。 令 envRec 为 env 的 EnvironmentRecord. 断言: envRec 是 a global Environment Record. 令 lexNames 为 script 的 LexicallyDeclaredNames 令 varNames 为 script 的 VarDeclaredNames 对于在lexNames中的每一个name，执行 若 envRec.HasVarDeclaration(name) 是 true, 抛出 SyntaxError 异常 若 envRec.HasLexicalDeclaration(name) 是 true, 抛出 SyntaxError 异常 令 hasRestrictedGlobal 为 ? envRec.HasRestrictedGlobalProperty(name). 若 hasRestrictedGlobal 是 true, 抛出 SyntaxError 异常 对于在varNames中的每一个name，执行 若 envRec.HasLexicalDeclaration(name) 是 true, 抛出 SyntaxError 异常 令 varDeclarations 为 script 的 VarScopedDeclarations 令 functionsToInitialize 为新的空列表. 令 declaredFunctionNames 为新的空列表. 对于varDeclarations中的每个d，以反向列表顺序，执行 若 d 是 不是 VariableDeclaration 或 ForBinding 或 BindingIdentifier，那么 断言: d 是 FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, 或 AsyncGeneratorDeclaration. 注: 若有多个相同名称的函数声明，则使用最后一个声明。 令 fn 为 d 的BoundNames的唯一元素。 若 fn 不是 declaredFunctionNames 的 element，那么 令 fnDefinable 为 ? envRec.CanDeclareGlobalFunction(fn). 若 fnDefinable 是 false, 抛出 TypeError 异常 将 fn 添加到 declaredFunctionNames. 插入d作为functionsToInitialize的第一个元素。 令 declaredVarNames 为新的空列表. 对于在varDeclarations中的每一个d，执行 若 d 是 VariableDeclaration, ForBinding, 或 BindingIdentifier，那么 对于在 d 的 BoundNames 中的每一个字符串 vn，执行 若 vn 不是 declaredFunctionNames 的元素，那么 令 vnDefinable 为 ? envRec.CanDeclareGlobalVar(vn). 若 vnDefinable 是 false, 抛出 TypeError 异常 若 vn 不是 an declaredVarNames 的元素，那么 将 vn 添加到 declaredVarNames. 注: 若全局对象是普通对象，则在此算法步骤之后不会发生异常终止。但是，若全局对象是Proxy外来对象，则在以下某些步骤中，它可能会表现出导致异常终止的行为。 注: 附件B.3.3.2在这一点上增加了其他步骤。 令 lexDeclarations 为 script 的 LexicallyScopedDeclarations 对于在lexDeclarations中的每一个元素 d，执行 注: 词汇声明的名称仅在此处实例化，而不初始化。 对于在 d 的 BoundNames 的每一个元素 d，执行 若 d 的 IsConstantDeclaration 是 true，那么 执行 ? envRec.CreateImmutableBinding(dn, true). 否则， 执行 ? envRec.CreateMutableBinding(dn, false). 对于在functionsToInitialize中的每一个解析节点 f，执行 令 fn 为 f 的 BoundNames 的唯一元素。 令 fo 为使用参数 env 为 f 执行InstantiateFunctionObject的结果。 执行 ? envRec.CreateGlobalFunctionBinding(fn, fo, false). 对于clarifiedVarNames中的每个String vn，按列表顺序，执行 执行 ? envRec.CreateGlobalVarBinding(vn, false). 返回 NormalCompletion(empty). 注 2：15.1.1中指定的早期错误可防止 function/ var声明与let / const / class声明之间的名称冲突，以及防止为单个脚本中包含的声明重新声明let / const / class绑定。但是，在GlobalDeclarationInstantiation期间将跨越多个脚本的此类冲突和重新声明检测为运行时错误。若检测到任何此类错误，则不会实例化脚本的绑定。但是，若使用代理外来对象定义了全局对象，则针对冲突声明的运行时测试可能不可靠，从而导致突然完成，并且某些全局声明未实例化。若发生这种情况，则不会执行脚本的代码。 与显式var或function声明不同，直接在全局对象上创建的属性会导致全局绑定，而这些绑定可能会被let / const / class声明所遮盖。 15.1.12 运行时语义：ScriptEvaluationJob ( sourceText, hostDefined ) 具有参数sourceText和hostDefined的任务ScriptEvaluationJob解析、验证和运算sourceText作为脚本 断言: sourceText 是ECMAScript源文本 (见第10条). 令 realm 为当前 Realm Record. 令 s 为 ParseScript(sourceText, realm, hostDefined). 若 s 是 errors 的 列表，那么 执行 HostReportErrors(s). 返回 NormalCompletion(undefined). 返回 ? ScriptEvaluation(s). 15.2 模块 语法 Module : ModuleBodyopt ModuleBody : ModuleItemList ModuleItemList : ModuleItem ModuleItemList ModuleItem ModuleItem : ImportDeclaration ExportDeclaration StatementListItem[~Yield, ~Await, ~返回] 15.2.1 模块语义 15.2.1.1 静态语义：Early Errors ModuleBody : ModuleItemList 若ModuleItemList的LexicallyDeclaredNames包含任何重复的条目，则是语法错误。 若ModuleItemList的LexicallyDeclaredNames的任何元素也出现在ModuleItemList的VarDeclaredNames中，则是语法错误。 若ModuleItemList的ExportedNames包含任何重复的条目，则是语法错误。 若ModuleItemList的VarDeclaredNames或ModuleItemList的LexicallyDeclaredNames中也没有出现ModuleItemList的ExportedBindings的任何元素，则是语法错误。 若ModuleItemList包含super，则为语法错误。 若ModuleItemList包含NewTarget，则为语法错误。 若带有参数«»的ModuleItemList的ContainsDuplicateLabels为true，则为语法错误。 若带有参数«»的ModuleItemList的ContainsUndefinedBreakTarget为true，则为语法错误。 若带有参数«»和«»的ModuleItemList的ContainsUndefinedContinueTarget为true，则为语法错误。 注：重复的ExportedNames规则意味着ModuleBody中的多个export default 的 ExportDeclaration项目是语法错误。在运算模块之前，在模块链接期间检查与冲突或重复声明有关的其他错误条件。若检测到任何此类错误，则不会运算模块。 15.2.1.2 静态语义：ContainsDuplicateLabels 带参数 labelSet。 ModuleItemList : ModuleItemList ModuleItem 令 hasDuplicates 为带有参数labelSet的ModuleItemList的ContainsDuplicateLabels。 若 hasDuplicates 是 true，返回 true. 返回带有参数 labelSet 的 ModuleItem 的 ContainsDuplicateLabels ModuleItem : ImportDeclaration ExportDeclaration 返回 false. 15.2.1.3 静态语义：ContainsUndefinedBreakTarget 带参数 labelSet。 ModuleItemList : ModuleItemList ModuleItem 令 hasUndefinedLabels 为带有参数 labelSet 的 ModuleItemList 的 ContainsUndefinedBreakTarget 若 hasUndefinedLabels 是 true，返回 true. 返回带有参数 labelSet 的 ModuleItem 的 ContainsUndefinedBreakTarget ModuleItem : ImportDeclaration ExportDeclaration 返回 false. 15.2.1.4 静态语义：ContainsUndefinedContinueTarget With parameters iterationSet and labelSet. ModuleItemList : ModuleItemList ModuleItem 令 hasUndefinedLabels 为带有参数 iterationSet 和 « » 的 ModuleItemList 的 ContainsUndefinedContinueTarget . 若 hasUndefinedLabels 是 true，返回 true. 返回参数 iterationSet 和 « » 的 ModuleItem 的 ContainsUndefinedContinueTarget . ModuleItem : ImportDeclaration ExportDeclaration 返回 false. 15.2.1.5 静态语义：ExportedBindings 注：ExportedBindings是与模块的ExportedNames显式关联的本地绑定名称。 ModuleItemList : ModuleItemList ModuleItem 令 names 为ModuleItemList 的 ExportedBindings 追加到ModuleItem的ExportedBindings元素的名称 返回 names ModuleItem : ImportDeclaration StatementListItem 返回新的空列表. 15.2.1.6 静态语义：ExportedNames 注：ExportedNames是模块显式映射到其本地名称绑定之一的外部可见名称。 ModuleItemList : ModuleItemList ModuleItem 令 names 为 ModuleItemList 的 ExportedNames 追加到ModuleItem的ExportedNames元素的名称。 返回 names. ModuleItem : ExportDeclaration 返回 ExportDeclaration 的 ExportedNames ModuleItem : ImportDeclaration StatementListItem 返回新的空列表. 15.2.1.7 静态语义：ExportEntries Module : [empty] 返回新的空列表. ModuleItemList : ModuleItemList ModuleItem 令 entries 为 ModuleItemList 的 ExportEntries 在 entries 后追加 ModuleItem 的 ExportEntries 返回 entries. ModuleItem : ImportDeclaration StatementListItem 返回新的空列表. 15.2.1.8 静态语义：ImportEntries Module : [empty] 返回新的空列表. ModuleItemList : ModuleItemList ModuleItem 令 entries 为 ModuleItemList 的 ImportEntries 在 entries 后追加 ModuleItem 的 ImportEntries 返回 entries ModuleItem : ExportDeclaration StatementListItem 返回新的空列表 15.2.1.9 静态语义：ImportedLocalNames ( importEntries ) 具有参数importEntries的抽象操作ImportedLocalNames创建一个由ImportEntry记录列表定义的所有本地名称绑定的列表（请参见表42）。 ImportedLocalNames执行以下步骤： 令 localNames 为新的空列表. 对于在importEntries中的每一个ImportEntry 记录 i，执行 将 i.[[LocalName]] 添加到 localNames. 返回 localNames. 15.2.1.10 静态语义：ModuleRequests Module : [empty] 返回新的空列表. ModuleItemList : ModuleItem 返回 ModuleItem 的 ModuleRequests ModuleItemList : ModuleItemList ModuleItem 令 moduleNames 为 ModuleItemList 的 ModuleRequests 令 additionalNames 为 ModuleItem 的 ModuleRequests 附加到moduleNames的additionalNames的每个元素还不是moduleNames的元素。 返回 moduleNames. ModuleItem : StatementListItem 返回新的空列表. 15.2.1.11 静态语义：LexicallyDeclaredNames 注 1：模块的LexicallyDeclaredNames包括其所有导入的绑定的名称。 ModuleItemList : ModuleItemList ModuleItem 令 names 为 ModuleItemList 的 LexicallyDeclaredNames 在 names 后追加 ModuleItem 的 LexicallyDeclaredNames 返回 names. ModuleItem : ImportDeclaration 返回 ImportDeclaration 的 BoundNames ModuleItem : ExportDeclaration 若 ExportDeclaration 是 export VariableStatement, 返回新的空列表. 返回 ExportDeclaration 的 BoundNames ModuleItem : StatementListItem 返回 StatementListItem 的 LexicallyDeclaredNames 注 2：在模块的顶层，将函数声明视为词法声明而不是var声明。 15.2.1.12 静态语义：LexicallyScopedDeclarations Module : [empty] 返回新的空列表. ModuleItemList : ModuleItemList ModuleItem 令 declarations 为 ModuleItemList 的 LexicallyScopedDeclarations 在 declarations 后追加 ModuleItem 的 LexicallyScopedDeclarations 返回 declarations. ModuleItem : ImportDeclaration 返回新的空列表 15.2.1.13 静态语义：VarDeclaredNames Module : [empty] 返回新的空列表 ModuleItemList : ModuleItemList ModuleItem 令 names 为 ModuleItemList 的 VarDeclaredNames 在 names 后追加 ModuleItem 的 VarDeclaredNames 返回 names. ModuleItem : ImportDeclaration 返回新的空列表. ModuleItem : ExportDeclaration 若 ExportDeclaration 是 export VariableStatement，返回 ExportDeclaration 的 BoundNames 返回新的空列表. 15.2.1.14 静态语义：VarScopedDeclarations Module : [empty] 返回新的空列表 ModuleItemList : ModuleItemList ModuleItem 令 declarations 为 ModuleItemList 的 VarScopedDeclarations 在 declarations 后追加 ModuleItem 的 VarScopedDeclarations 返回 declarations. ModuleItem : ImportDeclaration 返回新的空列表. ModuleItem : ExportDeclaration 若 ExportDeclaration 是 export VariableStatement，返回 VariableStatement 的 VarScopedDeclarations 返回新的空列表. 15.2.1.15 抽象模块记录 模块记录封装有关单个模块的导入和导出的结构信息。此信息用于链接已连接模块集的导入和导出。模块记录包含四个字段，仅在运算模块时使用。 出于规范目的，“模块记录”值是记录规范类型的值，可以视为存在于简单的面向对象的层次结构中，其中“模块记录”是具有抽象和具体子类的抽象类。该规范定义了名为循环模块记录的抽象子类及其名为源文本模块记录的具体子类。其他规范和实现可以定义与它们定义的替代模块定义功能相对应的其他模块记录子类。 模块记录定义了表37中列出的字段。所有模块定义子类至少包括那些字段。模块记录还定义了表38中的抽象方法列表。所有模块定义子类都必须提供这些抽象方法的具体实现。 表37：模块记录字段 字段命长 值类型 意义 [[Realm]] 作用域记录项\\ undefined 在其中创建此模块的作用域。undfined（若尚未分配）。 [[Environment]] 词法环境 \\ undefined 包含此模块的顶级绑定的词法环境。实例化脚本时设置此字段 [[Namespace]] 对象\\ undefined 模块命名空间对象（26.3）（若已为此模块创建一个）。否则为undefined。 [[HostDefined]] 任意，默认值是 undefined. 保留给需要其他信息与模块关联的主机环境使用的字段。 表38：模块记录的抽象方法 方法 目的 GetExportedNames(exportStarSet) 返回从此模块直接或间接导出的所有名称的列表 ResolveExport(exportName, resolveSet, exportStarSet) 返回此模块导出的名称的绑定。绑定由格式为{[[[Module]]：Module Record，[[BindingName]]：String}的ResolvedBinding Record表示。若名称无法解析，则返回null；若找到多个绑定，则返回“ambiguous”若该操作正常完成，则必须是幂等的。每次使用特定的exportName，resolveSet对作为参数调用时，它必须返回相同的结果。 Instantiate() 通过暂时解决所有模块依赖性并创建模块环境记录来准备要运算的模块。 Evaluate() 若已经成功解析执行了此模块，则返回undefined；否则返回false。若尚未解析执行成功，则抛出所产生的异常。否则，可传递地解析执行此模块的所有模块依赖性，然后解析执行此模块实例化必须在调用此方法之前成功完成。 15.2.1.16 循环模块记录 循环模块记录用于表示有关模块的信息，这些模块可以与作为循环模块记录类型子类的其他模块一起参与依赖循环。不是循环模块记录类型的子类的模块记录不能与源文本模块记录一起参与依赖循环。 除了表37中定义的字段外，循环模块记录还有表39中列出的其他字段 表39：循环模块记录的其他字段 字段名称 值类型 意义 [[Status]] String 最初是“uninstantiated”。随着模块在其整个生命周期中的进展，转换为“instantiating”，“instantiated”，“evaluating”，“evaluated”（按此顺序）。 [[EvaluationError]] An abrupt completion\\ undefined 类型throw的完成，表示运算期间发生的异常。若未发生异常或未对[[Status]]进行“envaluation”，则为undefined。 [[DFSIndex]] Integer\\ undefined 仅在实例化和解析执行期间使用的辅助字段。若[[Status]]是“instantiating”或“evaluating”，则此非负数记录在进行依赖图的深度优先遍历过程中首次访问模块的点。 [[DFSAncestorIndex]] Integer\\ undefined 仅在实例化和运算期间使用的辅助字段。若[[Status]]是“instantiating”或“evaluating”，则这是模块自己的[[DFSIndex]]或同一强连接组件中“较早”模块的名称。 [[RequestedModules]] List of String 此记录表示的模块用于请求导入模块的所有ModuleSpecifier字符串的列表。列表是源代码出现顺序。 除表38中定义的方法外，循环模块记录还有表40中列出的其他方法 表40：循环模块记录的其他抽象方法 方法 目的 InitializeEnvironment() 初始化模块的词法环境，包括解析所有导入的绑定。 ExecuteModule() 初始化模块的执行上下文，并运算其中的模块代码。 15.2.1.16.1 Instantiate ( ) 具体方法 循环模块记录的实例化具体方法实现了相应的模块记录抽象方法。 成功完成后，Instantiate将该模块的[[Status]]从“uninstantiated”转换为“instantiated”。失败时，将引发异常，并且该模块的[[Status]]保持“uninstantiated”。 此抽象方法执行以下步骤（大部分工作由辅助函数InnerModuleInstantiation完成）： 令 module 为此 Cyclic 模块记录项. 断言: module.[[Status]] 不是 \"instantiating\" 或 \"evaluating\". 令 stack 为新的空列表. 令 result 为 InnerModuleInstantiation(module, stack, 0). 若 result 是 abrupt completion，那么 对于在stack中的每一个模块m，执行 断言: m.[[Status]] 是 \"instantiating\". 设置 m.[[Status]] 为 \"uninstantiated\". 设置 m.[[Environment]] 为 undefined. 设置 m.[[DFSIndex]] 为 undefined. 设置 m.[[DFSAncestorIndex]] 为 undefined. 断言: module.[[Status]] 是 \"uninstantiated\". 返回 result. 断言: module.[[Status]] 是 \"instantiated\" 或 \"evaluated\". 断言: stack 是 empty. 返回 undefined. 15.2.1.16.1.1 InnerModuleInstantiation ( module, stack, index ) 实例化使用InnerModuleInstantiation抽象操作为Cyclic Module Record模块以及依赖关系图中的所有其他模块递归执行实际的实例化过程。堆栈和索引参数，以及模块的[[DFSIndex]]和[[DFSAncestorIndex]]字段可跟踪深度优先搜索（DFS）遍历。特别地，[[DFSAncestorIndex]]用于发现强连接的组件（SCC），以使SCC中的所有模块一起过渡到“instantiated”。 此抽象操作执行以下步骤： 若 module 不是 Cyclic 模块记录项，那么 执行 ? module.Instantiate(). 返回 index. 若 module.[[Status]] 是 \"instantiating\", \"instantiated\", 或 \"evaluated\"，那么 返回 index. 断言: module.[[Status]] 是 \"uninstantiated\". 设置 module.[[Status]] 为 \"instantiating\". 设置 module.[[DFSIndex]] 为 index. 设置 module.[[DFSAncestorIndex]] 为 index. index 增加 1. 将 module 添加到 stack. 对于每个需要的module.[[RequestedModules]]元素, 执行 令 requiredModule 为 ? HostResolveImportedModule(module, required). 设置 index 为 ? InnerModuleInstantiation(requiredModule, stack, index). 断言: requiredModule.[[Status]] 是 \"instantiating\", \"instantiated\", 或 \"evaluated\". 断言: requiredModule.[[Status]] 是 \"instantiating\" 若 and only 若 requiredModule 是 in stack. 若 requiredModule.[[Status]] 是 \"instantiating\"，那么 断言: requiredModule 是 a Cyclic Module Record. 设置 module.[[DFSAncestorIndex]] 为 min(module.[[DFSAncestorIndex]], requiredModule. [[DFSAncestorIndex]]). 执行 ? module.InitializeEnvironment(). 断言: 模块恰好在堆栈中发生一次 断言: module.[[DFSAncestorIndex]] 小于等于 module.[[DFSIndex]]. 若 module.[[DFSAncestorIndex]] 等于 module.[[DFSIndex]]，那么 令 done 为 false. 重复, 直到 done 是 false, 令 requiredModule 为 stack 的最后一个元素. 删除堆栈的最后一个元素。 设置 requiredModule.[[Status]] 为 \"instantiated\". 若requiredModule和module是相同的模块记录, 设置 done 为 true. 返回 index 15.2.1.16.2 Evaluate ( ) 具体方法 循环模块记录的运算具体方法实现了相应的模块记录抽象方法。 运算将模块的[[Status]]从“instantiated”转换为“evaluated”。 若执行导致异常，则将该异常记录在[[EvaluationError]]字段中，并在以后调用Evaluate时将其重新抛出。 该抽象方法执行以下步骤(大部分工作由辅助函数InnerModuleEvaluation完成): 令 module 为此 Cyclic 模块记录项. 断言: module.[[Status]] 是 \"instantiated\" 或 \"evaluated\". 令 stack 为新的空列表. 令 result 为 InnerModuleEvaluation(module, stack, 0). 若 result 是 abrupt completion，那么 对于在stack中的每一个模块 m，执行 断言: m.[[Status]] 是 \"evaluating\". 设置 m.[[Status]] 为 \"evaluated\". 设置 m.[[EvaluationError]] 为 result. 断言: module.[[Status]] 是 \"evaluated\"，并且 module.[[EvaluationError]] 是 result. 返回 result. 断言: module.[[Status]] 是 \"evaluated\"，并且 module.[[EvaluationError]] 是 undefined. 断言: stack 是 empty. 返回 undefined. 15.2.1.16.2.1 InnerModuleEvaluation ( module, stack, index ) Evaluate使用InnerModuleEvaluation抽象操作来执行源文本模块记录module的实际解释执行过程，并递归地处理依赖关系图中的所有其他模块。堆栈和索引参数以及模块的[[DFSIndex]]和[[DFSAncestoreIndex]]字段的使用方式与InnerModuleInstantiation相同。 这个抽象操作执行以下步骤： 若 module 不是 Cyclic 模块记录项，那么 执行 ? module.Evaluate(). 返回 index. 若 module.[[Status]] 是 \"evaluated\"，那么 若 module.[[EvaluationError]] 是 undefined，返回 index. 否则，返回 module.[[EvaluationError]]. 若 module.[[Status]] 是 \"evaluating\"，返回 index. 断言: module.[[Status]] 是 \"instantiated\". 设置 module.[[Status]] 为 \"evaluating\". 设置 module.[[DFSIndex]] 为 index. 设置 module.[[DFSAncestorIndex]] 为 index. index 增加 1. 将 module 添加到 stack. 对于每个需要的module.[[RequestedModules]]元素, 执行 令 requiredModule 为 ! HostResolveImportedModule(module, required). 注: 在调用这个方法之前，必须成功地完成实例化，这样才能保证每个请求的模块都能成功解析。 设置 index 为 ? InnerModuleEvaluation(requiredModule, stack, index). 断言: requiredModule.[[Status]] 是 \"evaluating\" 或 \"evaluated\". 断言: requiredModule.[[Status]] 是 \"evaluating\" 当且仅当 requiredModule 在 stack 中. 若 requiredModule.[[Status]] 是 \"evaluating\"，那么 断言: requiredModule 是 Cyclic 模块记录项。 设置 module.[[DFSAncestorIndex]] 为 min(module.[[DFSAncestorIndex]], requiredModule. [[DFSAncestorIndex]]). 执行 ? module.ExecuteModule(). 断言:module恰好在stack中出现一次。 断言: module.[[DFSAncestorIndex]] 小于等于 module.[[DFSIndex]]. 若 module.[[DFSAncestorIndex]] 等于 module.[[DFSIndex]]，那么 令 done 为 false. 重复, 直到 done 是 false, 令 requiredModule 为 stack 中的最后一个元素 移除 stack 的最后一个元素 设置 requiredModule.[[Status]] 为 \"evaluated\". 若 requiredModule 和 module 的模块记录项相同, 设置 done 为 true. 返回 index 15.2.1.16.3 循环模块记录示例图 本非规范性部分提供了一些示例和一些常见模块图的解释执行的示例，并特别关注错误的发生方式。 首先考虑以下简单模块图： 图2：一个简单的模块图 首先，假设没有错误条件。当主机首先调用 A.Instantiate() 时，这将通过假设成功完成，并递归实例化模块B和C，使得A.[[Status]] = B.[[Status]] = C.[[Status]] =“instantiated”。该准备步骤可以随时执行。稍后，当主机准备好承担模块的任何可能的副作用时，它可以调用A.Evaluate()，该操作将成功完成（再次假设），递归地首先解析执行C，然后解析执行B。每个模块的[[Status]]此时将被“evaluated”。 然后考虑涉及实例化错误的情况。若C的InnerModuleInstantiation成功但此后对B失败，例如因为它导入了C无法提供的内容，则原始 A.Instantiate() 将失败，并且A和B的[[Status]]都保持“uninstantiated” 。但是，C的[[Status]]已“instantiated”。 最后，考虑涉及解析执行错误的情况。若C的InnerModuleEvaluation成功但之后对B失败，例如，因为B包含引发异常的代码，则原始A.Evaluate() 将失败。结果异常将记录在A和B的[[EvaluationError]]字段中，并且它们的[[Status]]将变为“evaluated”。C也将变为“evaluated”，但与A和B相比，它将保持不包含一个状态[[EvaluationError]]，因为它成功完成了解析执行。存储异常可确保主机每次通过调用其Evaluate（）方法尝试重用A或B时，都会遇到相同的异常（不需要主机重用循环模块记录；类似地，不需要主机公开该异常这些方法抛出的对象。但是，规范允许此类使用。） 实例化错误和解析执行错误之间的差异是由于解析执行仅能执行一次的原因，因为解析执行会导致副作用。因此，重要的是要记住解析执行是否已经执行，即使解析执行未成功。 （在错误情况下，还记得该异常是有意义的，因为否则，随后的Evaluate() 调用将不得不合成一个新的异常。）另一方面，实例化是无副作用的，因此即使失败了，以后可以重试而不会出现任何问题 现在考虑另一种错误条件： 图3：带有不可解析模块的模块图 在这种情况下，模块A声明了对某个其他模块的依赖关系，但是该模块不存在任何模块记录，即HostResolveImportedModule在被询问时引发异常。发生这种情况的原因可能多种多样，例如不存在相应的资源，或者存在现有资源，但ParseModule在尝试解析结果源文本时抛出异常。主机可以选择通过从HostResolveImportedModule引发的异常来揭示失败原因。在任何情况下，此异常都会导致实例化失败，这与以前一样导致A的[[Status]]保持“uninstantiated”。 最后，考虑带有循环的模块图： 图4：循环模块图 在这里，我们假设入口点是模块A，以便主机通过调用 A.Instantiate() 进行操作，该A.Instantiate()在A上执行InnerModuleInstantiation。这又在B上调用InnerModuleInstantiation。由于周期的缘故，这再次触发了A上的InnerModuleInstantiation，但是由于A.[[Status]]已经在“instantiating”，因此这是空操作。当控制权返回到A并且在C上触发InnerModuleInstantiation时，B.[[Status]]本身保持“instantiating”。在C.[[Status]]返回“instantiated”之后，A和B一起从“instantiating”过渡到“instantiated”。这是设计使然，因为它们形成了牢固连接的组件。 在成功的情况下，循环模块图的解析执行阶段发生了类似的情况。 现在考虑A具有实例化错误的情况；例如，它尝试从C中导入一个不存在的绑定。在那种情况下，上述步骤仍然会发生，包括从第二次调用A上的InnerModuleInstantiation提前返回。但是，一旦我们退回到A上的原始InnerModuleInstantiation，它在InitializeEnvironment期间即C.ResolveExport（）之后就失败了。引发的SyntaxError异常会传播到A.Instantiate，该异常会重置其堆栈上当前存在的所有模块（这些模块始终都是仍在“instantiating”的模块）。因此，A和B都变为“uninstantiated”。请注意，C保留为“instantiated”。 最后，考虑A解析执行错误的情况；例如，其源代码会抛出异常。在那种情况下，上述步骤的解析执行时间模拟仍然会发生，包括从第二个调用提前返回到A上的InnerModuleEvaluation。但是，一旦我们退回到A上的原始InnerModuleEvaluation，它就会由于假设而失败。引发的异常会传播到A.Evaluate（），该异常会在当前堆栈中的所有模块（即仍在“evaluating”中的模块）中记录错误。因此，A和B都变为“evaluated”，并且异常记录在A和B的[[EvaluationError]]字段中，而C保留为“evaluated”，没有[[EvaluationError]]。 15.2.1.17 源文本模块记录 源文本模块记录用于表示有关由ECMAScript源文本（10）定义的模块的信息，该文本使用目标符号模块进行了解析。其字段包含有关模块导入的名称的摘要信息，其具体方法使用此摘要链接，实例化和解析执行模块。 源文本模块记录可以与抽象模块记录类型的其他子类一起存在于模块图中，并且可以与循环模块记录类型的其他子类一起参与循环。 除了表39中定义的字段之外，源文本模块记录还有表41中列出的其他字段。这些字段中的每个字段最初都是在ParseModule中设置的。 表41：源文本模块记录的其他字段 字段名 值类型 意义 [[ECMAScriptCode]] 解析节点 使用Module作为目标符号解析此模块的源文本的结果 [[ImportEntries]] ImportEntry 记录项的列表 从此模块的代码派生的ImportEntry记录列表。 [[LocalExportEntries]] ExportEntry 记录项的列表 从此模块的代码派生的ExportEntry记录的列表，这些记录与模块中发生的声明相对应。 [[IndirectExportEntries]] ExportEntry 记录项的列表 从此模块的代码派生的ExportEntry记录列表，这些记录与模块中发生的重新导出的导入相对应。 [[StarExportEntries]] ExportEntry 记录项的列表 从此模块的代码派生的ExportEntry记录列表，与该模块内发生的export *声明相对应。 ImportEntry记录是一种记录，用于摘要有关单个声明性导入的信息。每个ImportEntry记录均具有表42中定义的字段： 表42：ImportEntry记录字段 字段名 值类型 意义 [[ModuleRequest]] String ImportDeclaration的ModuleSpecifier的字符串值。 [[ImportName]] String 由[[ModuleRequest]]标识的模块导出所需绑定的名称。值\"*\"表示导入请求是针对目标模块的名称空间对象的。 [[LocalName]] String 用于从导入模块内部本地访问导入值的名称。 注 1：表43给出了用于表示语法导入形式的ImportEntry记录字段的示例： Import 声明格式 [[ModuleRequest]] [[ImportName]] [[LocalName]] import v from \"mod\"; \"mod\" \"default\" \"v\" import * as ns from \"mod\"; \"mod\" \"*\" \"ns\" import {x} from \"mod\"; \"mod\" \"x\" \"x\" import {x as v} from \"mod\"; \"mod\" \"x\" \"v\" import \"mod\"; 没有创建 ImportEntry 记录。 ExportEntry记录是一个记录，它摘要了有关单个声明性导出的信息。每个ExportEntry Record都有表44中定义的字段： 字段名 值类型 意义 [[ExportName]] String 此模块用于导出此绑定的名称。 [[ModuleRequest]] String \\ null 导出声明的ModuleSspecifier的字符串值。若导出声明没有Module Specifier，则为NULL。 [[ImportName]] String \\ null 由[[Module Request]]标识的模块导出所需绑定的名称。若导出声明没有Module Specifier，则为NULL。“*”表示出口请求为所有出口绑定。 [[LocalName]] String \\ null 用于从导入模块内本地访问导出值的名称。若导出的值不能从模块内本地访问，则为NULL。 注 2：表45给出了用于表示语法导出表单的ExportEntry记录字段的示例： 表45（信息）：导出表格 Export 声明格式 [[ExportName]] [[ModuleRequest]] [[ImportName]] [[LocalName]] export var v; \"v\" null null \"v\" export default function f(){} \"default\" null null \"f\" export default function(){} \"default\" null null \"*default*\" export default 42; \"default\" null null \"*default*\" export {x}; \"x\" null null \"x\" export {v as x}; \"x\" null null \"v\" export {x} from \"mod\"; \"x\" \"mod\" \"x\" null export {v as x} from \"mod\"; \"x\" \"mod\" \"v\" null export * from \"mod\"; null \"mod\" \"*\" null 以下定义规定了源文本模块记录所需的具体方法和其他抽象操作 15.2.1.17.1 ParseModule ( sourceText, realm, hostDefined ) 具有参数sourceText，realm和hostDefined的抽象操作ParseModule基于将sourceText作为模块进行解析的结果来创建源文本模块记录。 ParseModule执行以下步骤： 断言: sourceText是ECMAScript源文本（请参见第10节） 使用Module作为目标符号来解析sourceText并分析任何Early Error条件的解析结果。若解析成功并且未发现早期错误，则将body作为结果解析树。否则，将body作为代表解析错误和/或早期错误的一个或多个SyntaxError或ReferenceError对象的列表。解析和早期错误检测可以以依赖于实现的方式进行交织。若存在多个解析错误或早期错误，则列表中错误对象的数量和顺序与实现有关，但必须至少存在一个。 若 body 是 errors 的列表，返回 body. 令 requestedModules 为 body 的 ModuleRequests 令 importEntries 为 body 的 ImportEntries 令 importedBoundNames 为 ImportedLocalNames(importEntries). 令 indirectExportEntries 为新的空列表. 令 localExportEntries 为新的空列表. 令 starExportEntries 为新的空列表. 令 exportEntries 为 body 的 ExportEntries 对于在exportEntries中的每一个ExportEntry 记录项 ee，执行 若 ee.[[ModuleRequest]] 是 null，那么 若 ee.[[LocalName]] 不是 importedBoundNames 的元素，那么 将 ee 添加到 localExportEntries. 否则， 令ie为importEntries的元素，该元素的[[LocalName]]与ee.[[LocalName]]相同。 若 ie.[[ImportName]] 是 \"*\"，那么 断言: 这是导入的模块名称空间对象的重新导出。 将 ee 添加到 localExportEntries. 否则这是单个名称的重新导出， 添加 ExportEntry Record { [[ModuleRequest]]: ie.[[ModuleRequest]], [[ImportName]]: ie.[[ImportName]], [[LocalName]]: null, [[ExportName]]: ee. [[ExportName]] } to indirectExportEntries. 否则若 ee.[[ImportName]] 是 \"*\"，那么 将 ee 添加到 starExportEntries. 否则， 将 ee 添加到 indirectExportEntries. 返回 源文本模块记录项 { [[Realm]]: realm, [[Environment]]: undefined, [[Namespace]]: undefined, [[Status]]: \"uninstantiated\", [[EvaluationError]]: undefined, [[HostDefined]]: hostDefined,[[ECMAScriptCode]]: body, [[RequestedModules]]: requestedModules, [[ImportEntries]]: importEntries, [[LocalExportEntries]]: localExportEntries, [[IndirectExportEntries]]: indirectExportEntries, [[StarExportEntries]]: starExportEntries, [[DFSIndex]]: undefined, [[DFSAncestorIndex]]: undefined }. 注：一个实现可以解析模块源文本，并在为该模块源文本解析执行ParseModule之前针对早期错误条件对其进行分析。但是，任何错误的报告都必须推迟到该规范对该源文本实际执行ParseModule为止。 15.2.1.17.2 GetExportedNames ( exportStarSet ) Concrete Method 源文本模块记录的GetExportedNames具体方法实现了相应的模块记录抽象方法。 它执行以下步骤： 令 module 为此源文本模块记录。 若 exportStarSet contains module，那么 断言: 我们已经达到了 import * 循环的起点 返回新的空列表. 将 module 添加到 exportStarSet. 令 exportedNames 为新的空列表. 对于在module.[[LocalExportEntries]]中的每一个ExportEntry 记录 e，执行 断言: 模块为此导出提供直接绑定。 将 e.[[ExportName]] 添加到 exportedNames. 对于在module.[[IndirectExportEntries]]中的每一个ExportEntry 记录 e，执行 断言: 模块为此导出导入特定的绑定。 将 e.[[ExportName]] 添加到 exportedNames. 对于在module.[[StarExportEntries]]中的每一个ExportEntry 记录 e，执行 令 requestedModule 为 ? HostResolveImportedModule(module, e.[[ModuleRequest]]). 令 starNames 为 ? requestedModule.GetExportedNames(exportStarSet). 对于每一个 starNames 的 n，执行 若 SameValue(n, \"default\") 是 false, 那么 若 n 不是 exportedNames 的元素，那么 将 n 添加到 exportedNames. 返回 exportedNames. 注：GetExported Names不会筛选出或抛出具有模糊星型导出绑定的名称的异常。 15.2.1.17.3 ResolveExport ( exportName, resolveSet ) Concrete Method 源文本模块记录的解决输出具体方法实现了相应的模块记录抽象方法。 解析Export尝试解析导入的绑定到实际定义模块和本地绑定名称。定义模块可以是由模块记录表示的模块，该方法是在该模块上调用的，也可以是由该模块导入的其他模块。参数解析集用于检测未解决的循环导入/导出路径。若到达由特定模块记录和exportName组成的对，并且已经在solutionSet中，则已经遇到了导入循环。在递归调用ResolveExport之前，添加一对由模块和exportName组成的resolveSet。 若找到定义模块，则返回一个ResolvedBinding Record {[Module]，[[BindingName]]}。此记录标识原始请求导出的解析绑定。若没有找到定义或发现请求是循环的，则返回NULL。若发现请求是模糊的，则返回字符串“ambiguous”。 此抽象方法执行以下步骤： 令 module 为此源文本模块记录。 对于在resolveSet中的每一个Record { [[Module]], [[ExportName]] } r，执行 若模块和r.[[Module]]是相同的模块记录，并且SameValue（exportName，r.[[ExportName]]）为true，则 断言: 这是一个循环导入请求。 返回 null. 将 Record { [[Module]]: module, [[ExportName]]: exportName } 添加到 resolveSet. 对于在module.[[LocalExportEntries]]中的每一个ExportEntry 记录 e，执行 若 SameValue(exportName, e.[[ExportName]]) 是 true，那么 断言: module provides the direct binding for this export. 返回 ResolvedBinding Record { [[Module]]: module, [[BindingName]]: e.[[LocalName]] }. 对于在module.[[IndirectExportEntries]]中的每一个ExportEntry 记录 e，执行 若 SameValue(exportName, e.[[ExportName]]) 是 true，那么 断言: module imports a specific binding for this export. 令 importedModule 为 ? HostResolveImportedModule(module, e.[[ModuleRequest]]). 返回 importedModule.ResolveExport(e.[[ImportName]], resolveSet). 若 SameValue(exportName, \"default\") 是 true，那么 断言: 此模块未明确定义默认导出。 返回 null. 注：export*无法提供 default export。 令 starResolution 为 null. 对于在module.[[StarExportEntries]]中的每一个ExportEntry 记录 e，执行 令 importedModule 为 ? HostResolveImportedModule(module, e.[[ModuleRequest]]). 令 resolution 为 ? importedModule.ResolveExport(exportName, resolveSet). 若 resolution 是 \"ambiguous\"，返回 \"ambiguous\". 若 resolution 不是 null，那么 断言: resolution 是 a ResolvedBinding Record. 若 starResolution 是 null，设置 starResolution 为 resolution. 否则， 断言：一个以上的*import包含所请求的名称 若 resolution.[[Module]] 和 starResolution.[[Module]] Module 记录不相同，或 SameValue(resolution.[[BindingName]], starResolution.[[BindingName]]) 是 false，返回\"ambiguous\". 返回 starResolution. 15.2.1.17.4 InitializeEnvironment ( ) Concrete Method 源文本模块记录的InitializeEnvironment具体方法实现了相应的循环模块记录抽象方法。 此抽象方法执行以下步骤： 令 module 为此源文本模块记录。 对于在module.[[IndirectExportEntries]]中的每一个ExportEntry 记录 e，执行 令 resolution 为 ? module.ResolveExport(e.[[ExportName]], « »). 若 resolution 是 null 或 \"ambiguous\", 抛出 SyntaxError 异常 断言: resolution 是 ResolvedBinding 记录项. 断言: 模块中所有已命名的导出都是可解析的。 令 realm 为 module.[[Realm]]. 断言: realm 不是 undefined. 令 env 为 NewModuleEnvironment(realm.[[GlobalEnv]]). 设置 module.[[Environment]] 为 env. 令 envRec 为 env的 EnvironmentRecord. 对于在module.[[ImportEntries]]中的每一个ImportEntry 记录 in，执行 令 importedModule 为 ! HostResolveImportedModule(module, in.[[ModuleRequest]]). 注: 上面的调用不会失败，因为导入的模块请求是module.[[RequestedModules]]的子集，并且这些已在此算法中得到了较早的解决。 若 in.[[ImportName]] 是 \"*\"，那么 令 namespace 为 ? GetModuleNamespace(importedModule). 执行 ! envRec.CreateImmutableBinding(in.[[LocalName]], true). 调用 envRec.InitializeBinding(in.[[LocalName]], namespace). 否则， 令 resolution 为 ? importedModule.ResolveExport(in.[[ImportName]], « »). 若 resolution 是 null 或 \"ambiguous\", 抛出 SyntaxError 异常 调用 envRec.CreateImportBinding(in.[[LocalName]], resolution.[[Module]], resolution. [[BindingName]]). 令 code 为 module.[[ECMAScriptCode]]. 令 varDeclarations 为 code 的 VarScopedDeclarations 令 declaredVarNames 为新的空列表. 对于在varDeclarations中的每一个element d，执行 对于在d的BoundNames的每一个元素dn，执行 若 dn 不是 declaredVarNames 的元素，那么 执行 ! envRec.CreateMutableBinding(dn, false). 调用 envRec.InitializeBinding(dn, undefined). 将 dn 添加到 declaredVarNames. 令 lexDeclarations 为 code 的 LexicallyScopedDeclarations 对于在lexDeclarations中的每一个元素d，执行 对于d 的 BoundNames的每一个元素d，执行 若 d的IsConstantDeclaration 是 true，那么 执行 ! envRec.CreateImmutableBinding(dn, true). 否则， 执行 ! envRec.CreateMutableBinding(dn, false). 若 d 是 FunctionDeclaration, GeneratorDeclaration, AsyncFunctionDeclaration, 或 AsyncGeneratorDeclaration，那么 令fo为使用参数env为d执行InstantiateFunctionObject的结果 调用 envRec.InitializeBinding(dn, fo). 返回 NormalCompletion(empty). 15.2.1.17.5 ExecuteModule ( ) Concrete Method 源文本模块记录的ExecuteModule具体方法实现了相应的循环模块记录抽象方法。 此抽象方法执行以下步骤： 令 module 为此源文本模块记录 令 moduleCxt 为新的ECMAScript代码执行上下文。 设置 moduleCxt 的 Function 为 null. 断言: module.[[Realm]] 不是 undefined. 设置 moduleCxt 的 Realm 为 module.[[Realm]]. 设置 moduleCxt 的 ScriptOrModule 为 module. 断言: 已链接模块，并且已在其模块环境中实例化了声明。 设置 moduleCxt 的 VariableEnvironment 为 module.[[Environment]]. 设置 moduleCxt 的 LexicalEnvironment 为 module.[[Environment]]. 挂起当前正在运行的执行上下文。 将moduleCxt推入执行上下文堆栈；现在，moduleCxt是正在运行的执行上下文。 令 result 为解析执行 module.[[ECMAScriptCode]] 的结果 挂起moduleCxt并将其从执行上下文堆栈中删除。 将现在位于执行上下文堆栈顶部的上下文恢复为运行中的执行上下文。 返回 Completion(result). 15.2.1.18 运行时语义：HostResolveImportedModule ( referencingModule, specifier ) HostResolveImportedModule是一个实现定义的抽象操作，它提供与ModuleSpecifier字符串（说明符）相对应的具体Module Record子类实例，该实例出现在Module Record referenceencingModule表示的模块的上下文中。 HostResolveImportedModule的实现必须符合以下要求： 正常返回值必须是Module Record的具体子类的实例。 若对应于对referencelingModule对的模块记录，说明符不存在或无法创建，则必须引发异常。若该操作正常完成，则必须是幂等的。 每次使用特定的referencecingModule，说明符对作为参数调用时，它必须返回相同的Module Record实例。 多个不同的referencelingModule，说明符对可以映射到同一Module Record实例。实际的映射语义是实现定义的，但通常将规范化过程作为映射过程的一部分应用于说明符。典型的规范化过程将包括诸如字母大小写折叠以及相对和缩写路径说明符扩展的动作。 15.2.1.19 运行时语义：GetModuleNamespace ( module ) GetModuleNamespace抽象操作检索表示模块导出的Module Namespace Exotic对象，在第一次请求时延迟创建它，并将其存储在module。[[Namespace]]中，以备将来检索。 此抽象操作执行以下步骤： 断言: module 是Module Record的具体子类的实例。 断言: module.[[Status]] 不是 \"uninstantiated\". 令 namespace 为 module.[[Namespace]]. 若 namespace 是 undefined，那么 令 exportedNames 为 ? module.GetExportedNames(« »). 令 unambiguousNames 为新的空列表 对于每个是exportNames元素的names, 执行 令 resolution 为 ? module.ResolveExport(name, « »). 如果resolution是ResolvedBinding Record，则将名称附加到unambiguousNames。 设置namespace为ModuleNamespaceCreate（module，unambiguousNames）。 令 unambiguousNames 为新的空列表. 对于每个是exportNames元素的名称，执行 令 resolution 为 ? module.ResolveExport(name, « »). 若 resolution 是 ResolvedBinding 记录, 将 name 添加到 unambiguousNames. 设置 namespace 为 ModuleNamespaceCreate(module, unambiguousNames). 返回 namespace. 注：GetModuleNamespace抛出的唯一方法是通过触发的HostResolveImportedModule调用之一。此时，无法解析的名称仅从名称空间中排除。除非它们都是模棱两可的恒星输出，并且在任何地方都没有明确要求，否则它们将导致实际实例化错误。 15.2.1.20 运行时语义：TopLevelModuleEvaluationJob ( sourceText, hostDefined ) 参数sourceText和hostDefined的TopLevelModuleEvaluationJob是一项将SourceText作为模块进行解析，验证和解析执行的工作。 断言: sourceText 是ECMAScript源文本（请参见第10节）。 令 realm 为当前 Realm 记录项. 令 m 为 ParseModule(sourceText, realm, hostDefined). 若 m 是 errors 的列表，那么 执行 HostReportErrors(m). 返回 NormalCompletion(undefined). 执行 ? m.Instantiate(). 断言: m的所有依赖关系都已通过传递方式解决，并且m可供解析执行 返回 ? m.Evaluate(). 注：一个实现可以将sourceText解析为一个模块，分析它的Early Error条件，并在对该SourceText执行TopLevelModuleEvaluationJob之前实例化它。实现也可以解析，预先分析和预先分析以及预先实例化sourceText的模块依赖性。但是，必须推迟报告由这些操作检测到的任何错误，直到实际执行TopLevelModuleEvaluationJob为止。 15.2.1.21 运行时语义：Evaluation Module : [empty] 返回 NormalCompletion(undefined). ModuleBody : ModuleItemList 令 result 为解析执行ModuleItemList的结果。 若 result.[[Type]] 是 normal，并且 result.[[Value]] 是 empty，那么 返回 NormalCompletion(undefined). 返回 Completion(result). ModuleItemList : ModuleItemList ModuleItem 令 sl 为解析执行ModuleItemList的结果。 ReturnIfAbrupt(sl). 令 s 为解析执行ModuleItem的结果。 返回 Completion(UpdateEmpty(s, sl)). 注：ModuleItemList的值是ModuleItemList中最后一个产生值的项目的值。 ModuleItem : ImportDeclaration 返回 NormalCompletion(empty) 15.2.2 导入 语法 ImportDeclaration : import ImportClause FromClause ; import ModuleSpecifier ; ImportClause : ImportedDefaultBinding NameSpaceImport NamedImports ImportedDefaultBinding , NameSpaceImport ImportedDefaultBinding , NamedImports ImportedDefaultBinding : ImportedBinding NameSpaceImport : * as ImportedBinding NamedImports : { } { ImportsList } { ImportsList , } FromClause : from ModuleSpecifier ImportsList : ImportSpecifier ImportsList , ImportSpecifier ImportSpecifier : ImportedBinding IdentifierName as ImportedBinding ModuleSpecifier : StringLiteral ImportedBinding : BindingIdentifier[~Yield, ~Await] 15.2.2.1 静态语义：Early Errors ModuleItem : ImportDeclaration 若ImportDeclaration的BoundNames包含任何重复的条目，则是语法错误。 15.2.2.2 静态语义：BoundNames ImportDeclaration : import ImportClause FromClause ; 返回 ImportClause 的 BoundNames ImportDeclaration : import ModuleSpecifier ; 返回新的空列表. ImportClause : ImportedDefaultBinding , NameSpaceImport 令 names 为 ImportedDefaultBinding 的 BoundNames 在 names 后追加 NameSpaceImport 的 BoundNames 返回 names. ImportClause : ImportedDefaultBinding , NamedImports 令 names 为 ImportedDefaultBinding 的 BoundNames 在 names 后追加 NamedImports 的 BoundNames 返回 names. NamedImports : { } 返回新的空列表 ImportsList : ImportsList , ImportSpecifier 令 names 为 ImportsList 的 BoundNames 在 names 后追加 ImportSpecifier 的 BoundNames 返回 names. ImportSpecifier : IdentifierName as ImportedBinding 返回 the BoundNames of ImportedBinding 15.2.2.3 静态语义：ImportEntries ImportDeclaration : import ImportClause FromClause ; 令 module 为FromClause的ModuleRequests的唯一元素。 返回带有参数 modul 的 ImportClause 的 ImportEntriesForModule ImportDeclaration : import ModuleSpecifier ; 返回新的空列表. 15.2.2.4 静态语义：ImportEntriesForModule 带参数 module。 ImportClause : ImportedDefaultBinding , NameSpaceImport 令 entries 为带有参数 module 的 ImportedDefaultBinding 的 ImportEntriesForModule 在 entries 后追加 带有参数 module 的 NameSpaceImport 的 ImportEntriesForModule 返回 entries. ImportClause : ImportedDefaultBinding , NamedImports 令 entries 为带有参数 module 的 ImportedDefaultBinding 的 ImportEntriesForModule 在 entries 后追加 带有参数 module 的 NamedImports 的 ImportEntriesForModule 返回 entries ImportedDefaultBinding : ImportedBinding 令 localName 为 ImportedBinding 的 BoundNames 的唯一元素 令 defaultEntry 为 the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: \"default\", [[LocalName]]: localName }. 返回一个包含defaultEntry的新列表。 NameSpaceImport : * as ImportedBinding 令 localName 为 ImportedBinding 的 StringValue 令 entry 为 the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: \"*\", [[LocalName]]: localName }. 返回一个包含entry的新列表。 NamedImports : { } 返回新的空列表. ImportsList : ImportsList , ImportSpecifier 令 specs 为 the带有参数 module 的 ImportsList 的 ImportEntriesForModule 在 specs 后追加 带有参数 module 的 ImportSpecifier 的 ImportEntriesForModule 返回 specs. ImportSpecifier : ImportedBinding 令 localName 为 ImportedBinding 的 BoundNames 的单个元素 令 entry 为 ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: localName, [[LocalName]]: localName }. 返回一个包含entry的新列表。 ImportSpecifier : IdentifierName as ImportedBinding 令 importName 为 IdentifierName 的 StringValue 令 localName 为 ImportedBinding 的 StringValue 令 entry 为 the ImportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName }. 返回一个包含entry的新列表。 15.2.2.5 静态语义：ModuleRequests ImportDeclaration : import ImportClause FromClause ; 返回 FromClause 的 ModuleRequests ModuleSpecifier : StringLiteral 返回包含 StringLiteral 的 StringValue 的列表 15.2.3 导出 语法 ExportDeclaration : export * FromClause ; export ExportClause FromClause ; export ExportClause ; export VariableStatement[~Yield, ~Await] export Declaration[~Yield, ~Await] export default HoistableDeclaration[~Yield, ~Await, +Default] export default ClassDeclaration[~Yield, ~Await, +Default] export default [lookahead ∉ { function , async [no LineTerminator here] function , class }] AssignmentExpression[+In, ~Yield, ~Await] ; ExportClause : { } { ExportsList } { ExportsList , } ExportsList : ExportSpecifier ExportsList , ExportSpecifier ExportSpecifier : IdentifierName IdentifierName as IdentifierName 15.2.3.1 静态语义：Early Errors ExportDeclaration : export ExportClause ; 对于ExportClause的ReferencedBindings中的每个IdentifierName n：若n的StringValue是ReservedWord或n的StringValue是以下之一，则为语法错误：\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", or \"static\". 注：上面的规则意味着ExportClause的每个ReferencedBindings都被视为IdentifierReference。 15.2.3.2 静态语义：BoundNames ExportDeclaration : export * FromClause ; export ExportClause FromClause ; export ExportClause ; 返回新的空列表. ExportDeclaration : export VariableStatement 返回 VariableStatement 的 BoundNames ExportDeclaration : export Declaration 返回 Declaration 的 BoundNames ExportDeclaration : export default HoistableDeclaration 令 declarationNames 为 HoistableDeclaration 的 BoundNames 若clarificationNames不包含元素\" default \"，则将\" default \"附加到clarificationNames。 返回 declarationNames. ExportDeclaration : export default ClassDeclaration 令 declarationNames 为 ClassDeclaration 的 BoundNames 若 declarationNames 不包含 \"*default*\" 元素, 将 \"*default*\" 添加到 declarationNames. 返回 declarationNames. ExportDeclaration : export default AssignmentExpression ; 返回 « \"*default*\" ». 15.2.3.3 静态语义：ExportedBindings ExportDeclaration : export * FromClause ; export ExportClause FromClause ; 返回新的空列表. ExportDeclaration : export ExportClause ; 返回 ExportClause 的 ExportedBindings ExportDeclaration : export VariableStatement 返回 VariableStatement 的 BoundNames ExportDeclaration : export Declaration 返回 the BoundNames of Declaration ExportDeclaration : export default HoistableDeclaration ExportDeclaration : export default ClassDeclaration ExportDeclaration : export default AssignmentExpression ; 返回 the BoundNames of this ExportDeclaration. ExportClause : { } 返回新的空列表. ExportsList : ExportsList , ExportSpecifier 令 names 为 ExportsList 的 ExportedBindings 在 names 后追加 ExportSpecifier 的 ExportedBindings 返回 names. ExportSpecifier : IdentifierName 返回包含IdentifierName的StringValue的列表 ExportSpecifier : IdentifierName as IdentifierName 返回包含第一个IdentifierName的StringValue的列表 15.2.3.4 静态语义：ExportedNames ExportDeclaration : export * FromClause ; 返回新的空列表. ExportDeclaration : export ExportClause FromClause ; ExportDeclaration : export ExportClause ; 返回 ExportClause 的 ExportedNames ExportDeclaration : export VariableStatement 返回 the BoundNames of VariableStatement ExportDeclaration : export Declaration 返回 Declaration 的 BoundNames ExportDeclaration : export default HoistableDeclaration ExportDeclaration : export default ClassDeclaration ExportDeclaration : export default AssignmentExpression ; 返回 « \"default\" ». ExportClause : { } 返回新的空列表. ExportsList : ExportsList , ExportSpecifier 令 names 为 ExportsList 的 ExportedNames 在 names 后追加 ExportSpecifier 的 ExportedNames 返回 names ExportSpecifier : IdentifierName 返回包含 IdentifierName 的 StringValue 的列表 ExportSpecifier : IdentifierName as IdentifierName 返回一个包含第二个IdentifierName的StringValue的列表。 15.2.3.5 静态语义：ExportEntries ExportDeclaration : export * FromClause ; 令 module 为FromClause的ModuleRequests的唯一元素。 令 entry 为 the ExportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: \"*\", [[LocalName]]: null, [[ExportName]]: null }. 返回一个包含entry的新列表。 ExportDeclaration : export ExportClause FromClause ; 令 module 为FromClause的ModuleRequests的唯一元素。 返回带有参数 module 的 ExportClause 的 ExportEntriesForModule ExportDeclaration : export ExportClause ; 返回带有参数 null 的 ExportClause 的 ExportEntriesForModule ExportDeclaration : export VariableStatement 令 entries 为新的空列表. 令 names 为 VariableStatement 的 BoundNames 对于在names中的每一个name，执行 添加 the ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } 到 entries. 返回 entries. ExportDeclaration : export Declaration 令 entries 为新的空列表. 令 names 为 Declaration 的 BoundNames 对于在names中的每一个name，执行 将 ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: name, [[ExportName]]: name } 添加到 entries. 返回 entries ExportDeclaration : export default HoistableDeclaration 令 names 为 HoistableDeclaration 的 BoundNames 令 localName 为names的唯一元素。 返回包含 ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: \"default\" } 的新列表 ExportDeclaration : export default ClassDeclaration 令 names 为 ClassDeclaration 的 BoundNames 令 localName 为names的唯一元素。 返回包含 ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: localName, [[ExportName]]: \"default\" } 的新列表 ExportDeclaration : export default AssignmentExpression ; 令 entry 为 ExportEntry Record { [[ModuleRequest]]: null, [[ImportName]]: null, [[LocalName]]: \"*default*\", [[ExportName]]: \"default\" }. 返回一个包含entry的新列表。 注：在本规范中，“ default ”用作匿名默认导出值的综合名称。 15.2.3.6 静态语义：ExportEntriesForModule 带参数 module。 ExportClause : { } 返回新的空列表. ExportsList : ExportsList , ExportSpecifier 令 specs 为 the带有参数 module 的 ExportsList 的 ExportEntriesForModule 在 specs 后追加 带有参数 module 的 ExportSpecifier 的 ExportEntriesForModule 返回 specs. ExportSpecifier : IdentifierName 令 sourceName 为 IdentifierName 的 StringValue 若 module 是 null，那么 令 localName 为 sourceName. 令 importName 为 null. 否则， 令 localName 为 null. 令 importName 为 sourceName. 返回包含 ExportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName, [[ExportName]]: sourceName } 的新列表 ExportSpecifier : IdentifierName as IdentifierName 令 sourceName 为第一个IdentifierName的StringValue。 令 exportName 为第二个IdentifierName的StringValue。 若 module 是 null，那么 令 localName 为 sourceName. 令 importName 为 null. 否则， 令 localName 为 null. 令 importName 为 sourceName. 返回包含 ExportEntry Record { [[ModuleRequest]]: module, [[ImportName]]: importName, [[LocalName]]: localName, [[ExportName]]: exportName } 的新列表 15.2.3.7 静态语义：IsConstantDeclaration ExportDeclaration : export * FromClause ; export ExportClause FromClause ; export ExportClause ; export default AssignmentExpression ; 返回 false. 注：不必将 export default 的AssignmentExpression视为常量声明，因为没有语法允许分配给用于引用模块默认对象的内部绑定名称。 15.2.3.8 静态语义：LexicallyScopedDeclarations ExportDeclaration : export * FromClause ; export ExportClause FromClause ; export ExportClause ; export VariableStatement 返回新的空列表. ExportDeclaration : export Declaration 返回包含 Declaration 的 DeclarationPart 的新列表 ExportDeclaration : export default HoistableDeclaration 返回包含 HoistableDeclaration 的 DeclarationPart 的新列表 ExportDeclaration : export default ClassDeclaration 返回包含 ClassDeclaration 的新列表 ExportDeclaration : export default AssignmentExpression ; 返回包含 this ExportDeclaration 的新列表 15.2.3.9 静态语义：ModuleRequests ExportDeclaration : export * FromClause ; ExportDeclaration : export ExportClause FromClause ; 返回 FromClause 的 ModuleRequests ExportDeclaration : export ExportClause ; export VariableStatement export Declaration export default HoistableDeclaration export default ClassDeclaration export default AssignmentExpression ; 返回新的空列表. 15.2.3.10 静态语义：ReferencedBindings ExportClause : { } 返回新的空列表. ExportsList : ExportsList , ExportSpecifier 令 names 为 ExportsList 的 ReferencedBindings 在 names 后追加 ExportSpecifier 的 ReferencedBindings 返回 names. ExportSpecifier : IdentifierName 返回包含 IdentifierName 的列表 ExportSpecifier : IdentifierName as IdentifierName 返回包含第一个 IdentifierName 的列表 15.2.3.11 运行时语义：Evaluation ExportDeclaration : export * FromClause ; export ExportClause FromClause ; export ExportClause ; 返回 NormalCompletion(empty). ExportDeclaration : export VariableStatement 返回解析执行VariableStatement的结果 ExportDeclaration : export Declaration 返回解析执行Declaration的结果 ExportDeclaration : export default HoistableDeclaration 返回解析执行HoistableDeclaration的结果 ExportDeclaration : export default ClassDeclaration 令 value 为 ClassDeclaration 的 BindingClassDeclarationEvaluation 的结果 ReturnIfAbrupt(value). 令 className 为 ClassDeclaration 的 BoundNames 的单个元素 若 className 是 \"*default*\"，那么 令 env 为运行时的执行上下文的 LexicalEnvironment. 执行 ? InitializeBoundName(\"default\", value, env). 返回 NormalCompletion(empty). ExportDeclaration : export default AssignmentExpression ; 若 IsAnonymousFunctionDefinition(AssignmentExpression) 是 true，那么 令value为使用参数“ default”为AssignmentExpression执行NamedEvaluation的结果 否则， 令 rhs 为解析执行AssignmentExpression的结果 令 value 为 ? GetValue(rhs). 令 env 为运行时的执行上下文的 LexicalEnvironment. 执行 ? InitializeBoundName(\"*default*\", value, env). 返回 NormalCompletion(empty). "},"error-handling-and-language-extensions.html":{"url":"error-handling-and-language-extensions.html","title":"16 错误处理和语言扩展","keywords":"","body":"16 错误处理和语言扩展 在解析执行相关ECMAScript语言结构时，实现必须报告大多数错误。早期错误是一种错误，可以在解析执行包含错误的脚本中的任何构造之前检测到并报告该错误。早期错误的存在阻止了对结构的解析执行。实现必须报告脚本中的早期错误，这是在ParseScript中解析该脚本的一部分。在解析执行模块并且从未初始化模块时，报告模块中的早期错误。在调用eval时会报告eval码中的早期错误，这会阻止解析执行eval码。不是早期错误的所有错误都是运行时错误。 实现必须将本规范“静态语义：早期错误”子节中列出的任何情况的发生报告为早期错误。 即使编译器可以证明构造在任何情况下都无法执行而没有错误，实现也不应将其他类型的错误视为早期错误。在这种情况下，实现可能会发出预警，但在实际执行相关构造之前，它不应报告错误。 一个实现应报告指定的所有错误，但以下情况除外： 除16.2中的限制外，实现可以扩展脚本语法，模块语法以及正则表达式模式或标志语法。为此，允许被允许抛出SyntaxError的所有操作（例如调用eval，使用正则表达式文字或使用Function或RegExp构造函数）都表现出实现定义的行为，而不是在遇到实现定义的扩展时抛出SyntaxError脚本语法或正则表达式模式或标志语法 除16.2中的限制外，实现可以提供其他类型，值，对象，属性和 超出本规范中描述的功能。这可能导致构造（例如在全局范围内查找变量）具有实现定义的行为，而不是引发错误（例如ReferenceError）。 16.1 HostReportErrors ( errorList ) HostReportErrors是实现定义的抽象操作，允许主机环境报告解析错误，早期错误和运行时错误。 在所有情况下，HostReportErrors的实现都必须正常完成。 HostReportErrors的默认实现是无条件返回空的正常完成。 注：errorList将是ECMAScript语言值的列表。如果错误是解析错误或早期错误，则这些错误始终是SyntaxError或ReferenceError对象。但是，运行时错误可以是任何ECMAScript值。 16.2 禁止扩展 实现不得以下列方式扩展此规范： 使用严格的模式代码中的语法构造函数定义的ECMAScript函数对象不能使用自己的名为“caller或“arguments”的属性来创建。也不应该为使用ArrowFunction，MethodDefinition，GeneratorDeclaration，GeneratorExpression，AsyncGeneratorDeclaration，AsyncGeneratorExpression，ClassDeclaration，ClassExpression，AsyncFunctionDeclaration，AsyncFunctionExpression或AsyncArrowFunction定义的函数对象创建此类自己的属性，无论该定义是否包含在严格模式代码中。内置函数，使用Function构造函数创建的严格函数，使用Generator构造函数创建的生成器函数，使用AsyncFunction构造函数创建的异步函数以及使用bind方法创建的函数也不得使用此类自己的属性来创建 如果实现使用自己的名为“caller”的属性扩展任何函数对象，则使用[[Get]]或[[GetOwnProperty]]观察到的该属性的值一定不能是严格的函数对象。如果它是访问器属性，则该属性的[[Get]]属性值的函数在调用时绝不能返回严格函数。 映射或未映射的参数对象都不能使用自己的名为“caller”的属性来创建。除ECMA-402中指定的以外，不得扩展以下方法的行为： Object.prototype.toLocaleString, Array.prototype.toLocaleString, Number.prototype.toLocaleString, Date.prototype.toLocaleDateString, Date.prototype.toLocaleString, Date.prototype.toLocaleTimeString, String.prototype.localeCompare, %TypedArray%.prototype.toLocaleString. 当存在[U]语法参数时，不得扩展21.2.1和B.1.4中的RegExp模式语法以将任何源字符A-Z或a-z识别为IdentityEscape[+U]。 语法扩展不得以任何允许token的方式扩展：立即跟随与BindingIdentifier非终结符匹配的源文本。 在处理严格模式代码时，如B.1.1中所述，不得将NumericLiteral的语法扩展为包括LegacyOctalIntegerLiteral，并且不得将DecimalIntegerLiteral的语法扩展为包括NonOctalDecimalIntegerLiteral。 不得将TemplateCharacter扩展为包括B.1.2中定义的LegacyOctalEscapeSequence。在处理严格模式代码时，不得支持B.3.2，B.3.3，B.3.4和B.3.6中定义的扩展。解析模块目标符号时，不得支持B.1.3中定义的词汇语法扩展。 "},"standard-built-in-objects.html":{"url":"standard-built-in-objects.html","title":"17 ECMAScript标准内置对象","keywords":"","body":"17 ECMAScript标准内置对象 每当ECMAScript的Script或Module开始执行时，就有某些内置对象可用。第一个是全局对象，它是执行程序的词法环境的一部分。其他可以作为全局对象的初始属性访问，也可以作为可访问的内置对象的属性间接访问。 除非另有说明，否则可以作为函数调用的内置对象是具有9.3中描述的特征的内置函数对象。除非另有说明，否则内置对象的[[Extensible]]内部插槽最初的值为true。每个内置函数对象都有一个[[Realm]]内部插槽，其值是最初为其创建对象的作用域的作用域记录项。 许多内置对象是函数：可以使用参数调用它们。此外，其中一些是构造函数：它们是供new运算符使用的函数。对于每个内置函数，本规范都描述了该函数所需的参数以及该函数对象的属性。对于每个内置的构造函数，本规范还描述了该构造函数的原型对象的属性，以及由调用该构造函数的新表达式返回的特定对象实例的属性。 除非在特定函数的说明中另有说明，否则，如果给内置函数或构造函数提供的参数少于指定给函数所需的参数，则该函数或构造函数的行为应与赋予了足够的附加参数完全相同，每个参数是undefined的值。这种丢失的参数被认为是“not present”，可以通过规范算法以这种方式进行识别。在特定功能的描述中，术语“this value”和“ NewTarget”具有9.3中给出的含义。 除非在特定功能的说明中另有说明，否则，如果为所描述的内置功能或构造函数提供的参数超出了指定功能所允许的范围，则多余的参数将由调用解析执行，然后由函数忽略。但是，实现可以定义与此类参数有关的实现特定的行为，只要该行为不是抛出TypeError异常（该异常仅基于存在额外的参数就可以得出）。 注1：鼓励为内置函数集添加其他功能的实现通过添加新功能而不是向现有功能添加新参数来实现。 除非另有说明，否则每个内置函数和每个内置构造函数均具有Function原型对象，该对象是表达式Function.prototype（19.2.3）的初始值，作为其[[Prototype]]内部插槽的值。 除非另有说明，否则每个内置原型对象都具有Object原型对象，该对象是表达式Object.prototype（19.1.3）的初始值，作为其[[Prototype]]内部插槽的值，但Object原型对象除外本身。 除非在特定函数的说明中另有指定，否则未被标识为构造函数的内置函数对象不会实现[[Construct]]内部方法。 通过调用CreateBuiltinFunction抽象操作（9.3.3）创建此规范中定义的每个内置函数。 每个内置函数对象（包括构造函数）都有一个“length”属性，其值为整数。除非另有说明，否则该值等于该函数说明的子标题中显示的最大命名参数数量。可选参数（用方括号：[]表示）或其余参数（以«... name»形式显示）不包括在默认参数计数中。 注2：例如，在子标题«Array.prototype.map（callbackFn [，thisArg]）»下描述了作为Array原型对象的map属性的初始值的函数对象，该函数对象显示了两个命名参数callbackFn和thisArg，后者是可选的；因此，该函数对象的“length”属性的值为1。 除非另有说明，否则内置函数对象的“ length”属性具有属性{[[Writable]]：false，[[Enumerable]]：false，[[Configurable]]：true}。 没有被标识为匿名函数的每个内置函数对象（包括构造函数）都具有name属性，其值是String。除非另有说明，否则此值是在本规范中赋予函数的名称。对于指定为对象属性的函数，名称值是用于访问该函数的属性名称字符串。指定为内置属性的get或set访问器函数的函数的属性名称字符串前面带有“ get”或“ set”。name属性的值是为属性键为Symbol值的每个内置函数明确指定的 除非另有说明，否则内置函数对象的name属性（如果存在）具有属性{[[Writable]]：false，[[Enumerable]]：false，[[Configurable]]：true}。 除非另有说明，否则第18至26条以及附件B.2中描述的所有其他数据属性均具有属性{[[[Writable]]：true，[[Enumerable]]：false，[[Configurable]]：true}。 除非另有说明，否则第18至26节以及附件B.2中描述的每个访问器属性都具有属性{[[Enumerable]]：false，[[Configurable]]：true}。如果仅描述了get访问器函数，则set访问器函数是默认值undefined。如果仅描述set访问器，则get访问器为默认值undefined。 "},"global-object.html":{"url":"global-object.html","title":"18 全局对象","keywords":"","body":"18 全局对象 全局对象: 在控件进入任何执行上下文之前创建的。 没有[[Construct]]内部方法；它不能与new运算符一起用作构造函数。 没有[[Call]]内部方法；它不能作为函数调用。 有一个[[Prototype]]内部插槽，其值取决于实现。 除本规范中定义的属性外，还可能具有主机定义的属性。这可能包括其值为全局对象本身的属性。 18.1 全局对象的值属性 18.1.1 Infinity Infinity的值为+∞（请参见6.1.6）。该属性具有以下属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 18.1.2 NaN NaN的值为NaN（请参见6.1.6）。该属性具有以下属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 18.1.3 undefined undefined的值是undefined（请参见6.1.1）。该属性具有以下属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 18.2 全局对象的函数属性 18.2.1 eval ( x ) eval函数是％eval％内部对象。当使用一个参数x调用eval函数时，将执行以下步骤： 断言：执行上下文堆栈至少具有两个元素。 令 callerContext 为执行上下文堆栈的第二个元素。 令 callerRealm 为 callerContext 的 Realm. 令 calleeRealm 为 当前 Realm 记录项. 执行 ? HostEnsureCanCompileStrings(callerRealm, calleeRealm). 返回 ? PerformEval(x, calleeRealm, false, false). 18.2.1.1 运行时语义：PerformEval ( x, evalRealm, strictCaller, direct ) 具有参数x，evalRealm，strictCaller和direct的抽象操作PerformEval执行以下步骤： 断言：若 direct 是 false, 那么 strictCaller 也是 false. 若 Type(x) 不是 String, 返回 x. 令 thisEnvRec 为 ! GetThisEnvironment(). 若 thisEnvRec 是函数环境记录项, 那么 令 F 为 thisEnvRec.[[FunctionObject]]. 令 inFunction 为 true. 令 inMethod 为 thisEnvRec.HasSuperBinding(). 若 F.[[ConstructorKind]] 是 \"derived\", 令 inDerivedConstructor 为 true; 否则, 令 inDerivedConstructor 为 false. 否则， 令 inFunction 为 false. 令 inMethod 为 false. 令 inDerivedConstructor 为 false. 令脚本为ECMAScript代码，它是解析x的结果，对于目标符号脚本，x解释为UTF-16编码的Unicode文本（如6.1.4中所述）。如果inFunction为false，则将应用18.2.1.1.1中的其他早期错误规则。如果inMethod为false，则将应用18.2.1.1.2中的其他早期错误规则。如果inDerivedConstructor为false，则会应用18.2.1.1.3中的其他早期错误规则。如果解析失败，则抛出SyntaxError异常。如果检测到任何早期错误，则根据错误的类型抛出SyntaxError或ReferenceError异常（但另请参见第16节）。解析和早期错误检测可以以依赖于实现的方式混合在一起。 若 script 包含 ScriptBody 是 false, 返回 undefined. 令 body 为 ScriptBody 的 script. 若 strictCaller 是 true, 令 strictEval 为 true. 否则，令 strictEval 为 script 的 IsStrict. 令 ctx 为运行时执行上下文。 注意:如果direct为真，则ctx将是执行直接求值的执行上下文。如果direct为false，则ctx将是调用eval函数的执行上下文。 若 direct 是 true，那么 令 lexEnv 为 NewDeclarativeEnvironment(ctx 的词法环境). 令 varEnv 为 ctx 的 VariableEnvironment. 否则， 令 lexEnv 为 NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]). 令 varEnv 为 evalRealm.[[GlobalEnv]]. 若 strictEval 是 true, 设置 varEnv 为 lexEnv. 若 ctx 还没有被挂起, 挂起 ctx. 令 evalCxt 为一个新的ECMAScript代码执行上下文。 设置 evalCxt 的 Function 为 null. 设置 evalCxt 的 Realm 为 evalRealm. 设置 evalCxt 的 ScriptOrModule 为 ctx 的 ScriptOrModule. 设置 evalCxt 的 VariableEnvironment 为 varEnv. 设置 evalCxt 的 LexicalEnvironment 为 lexEnv. Push evalCxt on to the execution context stack; evalCxt is now运行时执行上下文。 令 result 为 EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval). 若 result.[[Type]] 是 normal，那么 设置 result 为 the result of evaluating body. 若 result.[[Type]] 是 normal 并且 result.[[Value]] 是 empty，那么 设置 result 为 NormalCompletion(undefined). 挂起evalCxt并将其从执行上下文堆栈中移除。 将当前位于执行上下文堆栈顶部的上下文恢复为正在运行的执行上下文 返回 Completion(result). 注：如果调用上下文正在计算形式参数初始化器，或者调用上下文的代码或eval代码是严格模式代码，则eval代码不能在调用上下文的变量环境中实例化调用eval的变量或函数绑定。 相反，这样的绑定是在一个新的VariableEnvironment中实例化的，这个环境只能被eval代码访问。 由let、const或类声明引入的绑定总是在新的LexicalEnvironment中实例化。 18.2.1.1.1 eval外部函数的附加早期错误规则 当直接eval调用发生在任何函数之外时，PerformEval将应用这些静态语义。 ScriptBody : StatementList 如果StatementList包含NewTarget，这是一个语法错误 18.2.1.1.2 eval外部方法的附加早期错误规则 当直接eval调用发生在MethodDefinition之外时，PerformEval将应用这些静态语义。 ScriptBody : StatementList 如果StatementList包含SuperProperty，则为语法错误。 18.2.1.1.3 eval外部构造方法的附加早期错误规则 当直接eval调用发生在ClassDeclaration或ClassExpression的构造方法之外时，PerformEval将应用这些静态语义。 ScriptBody : StatementList 如果StatementList包含SuperCall，则为语法错误。 18.2.1.2 HostEnsureCanCompileStrings ( callerRealm, calleeRealm ) HostEnsureCanCompileStrings是实现定义的抽象操作，它允许主机环境阻止某些ECMAScript函数，这些函数使开发人员可以将字符串编译为ECMAScript代码。 HostEnsureCanCompileStrings的实现可以正常或突然完成。任何突然的完成都会传播给它的调用者。 HostEnsureCanCompileStrings的默认实现是无条件返回空的正常完成。 18.2.1.3 运行时语义：EvalDeclarationInstantiation ( body, varEnv, lexEnv, strict ) 当使用参数body，varEnv，lexEnv和strict调用抽象操作EvalDeclarationInstantiation时，将执行以下步骤： 令 varNames 为 body 的 VarDeclaredNames 令 varDeclarations 为 body 的 VarScopedDeclarations 令 lexEnvRec 为 lexEnv 的 EnvironmentRecord. 令 varEnvRec 为 varEnv 的 EnvironmentRecord. 若 strict 是 false，那么 若 varEnvRec 是全局环境记录项，那么 1. 对于每一个在 varNames 中的 name，执行 1. 若 varEnvRec.HasLexicalDeclaration(name) 是 true, 抛出 SyntaxError 异常 2. 注意：eval不会创建一个全局var声明，该声明会被全局词法声明所遮盖。 令 thisLex 为 lexEnv. 断言：以下循环将终止。 重复，当 thisLex 与 varEnv 不同， 1. 令 thisEnvRec 为 thisLex 的 EnvironmentRecord. 2. 若 thisEnvRec 对象环境记录，那么 1. 注意：with语句的环境不能包含任何词法声明，因此不需要检查它是否存在 var / let 提升冲突。 2. 对于varNames中的每个name，执行 1. 若 thisEnvRec.HasBinding(name) 是 true，那么 1. 抛出 SyntaxError 异常 2. 注意：附件B.3.5定义了上述步骤的替代语义。 2. 注意：直接eval不会将var声明放在同名的词法声明上。 3. 设置 thisLex 为 thisLex 的外部环境参考。 令 functionsToInitialize 为新的空列表 令 declaredFunctionNames 为新的空列表 对于varDeclarations中的每个d，以相反的顺序排列，执行 若 d 既不是VariableDeclaration也不是ForBinding或BindingIdentifier，那么 断言：d是FunctionDeclaration，GeneratorDeclaration，AsyncFunctionDeclaration或AsyncGeneratorDeclaration。 注意：如果有多个具有相同名称的函数声明，则使用最后一个声明。 令 fn 为 d 的 BoundNames 的唯一元素。 若 fn 不是 declaredFunctionNames 的元素，那么 若 varEnvRec 是全局环境记录项，那么 令 fnDefinable 为 ? varEnvRec.CanDeclareGlobalFunction(fn). 若 fnDefinable 是 false, 抛出 TypeError 异常 将 fn 附加到声明的 FunctionNames。 插入 d 作为 functionsToInitialize 的第一个元素。 注意：附件B.3.3.3在这一点上增加了其他步骤。 令 declaredVarNames 为新的空列表 对于varDeclarations中的每个d，执行 若 d 是 VariableDeclaration, ForBinding, 或 BindingIdentifier，那么 1. 对于 d 的 BoundNames 中的每个字符串 vn，执行 1. 若 vn 不是 declaredFunctionNames 的元素，那么 1. 若 varEnvRec 是全局环境记录项，那么 1. 令 vnDefinable 为 ? varEnvRec.CanDeclareGlobalVar(vn). 2. 若 vnDefinable 是 false, 抛出 TypeError 异常 2. 若 vn 不是 declaredVarNames 的元素，那么 1. 将vn附加到clarifiedVarNames。 注意：在该算法步骤之后，不会发生异常终止，除非varEnvRec是全局环境记录并且全局对象是Proxy异类对象。 令 lexDeclarations 为 body 的 LexicallyScopedDeclarations 对于lexDeclarations中的每个元素d，执行 注意：词汇声明的名称仅在此处实例化，而不初始化。 对于d的BoundNames中的每个元素dn，执行 1. 如果d的IsConstantDeclaration为true，那么 1. 执行 ? lexEnvRec.CreateImmutableBinding(dn, true). 2. 否则， 1. 执行 ? lexEnvRec.CreateMutableBinding(dn, false). 对于functionsToInitialize中的每个解析节点f，执行 令 fn 为f的BoundNames的唯一元素 令 fo 为使用参数lexEnv为f执行InstantiateFunctionObject的结果。 若 varEnvRec 是全局环境记录项，那么 执行 ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true). 否则， 令 bindingExists 为 varEnvRec.HasBinding(fn). 若 bindingExists 是 false，那么 令 status 为 ! varEnvRec.CreateMutableBinding(fn, true). 断言：由于第12步之前的验证，状态不是突然完成。 执行 ! varEnvRec.InitializeBinding(fn, fo). 否则， 执行 ! varEnvRec.SetMutableBinding(fn, fo, false). 对于clarifiedVarNames中的每个String vn，按列表顺序，执行 若 varEnvRec 是全局环境记录项，那么 执行 ? varEnvRec.CreateGlobalVarBinding(vn, true). 否则， 令 bindingExists 为 varEnvRec.HasBinding(vn). 若 bindingExists 是 false，那么 令 status 为 ! varEnvRec.CreateMutableBinding(vn, true). 断言：由于第12步之前的验证，状态不是突然完成。 执行 ! varEnvRec.InitializeBinding(vn, undefined). 返回 NormalCompletion(empty). 注：B.3.5中描述了该算法的替代版本。 18.2.2 isFinite ( number ) isFinite函数是％isFinite％内部对象。当使用一个参数号调用isFinite函数时，将执行以下步骤： 令 num 为 ? ToNumber(number). 若 num 是 NaN, +∞, or -∞，返回 false. 否则，返回 true. 18.2.3 isNaN ( number ) isNaN函数是％isNaN％内部对象。当使用一个参数号调用isNaN函数时，将执行以下步骤： 令 num 为 ? ToNumber(number). 若 num 是 NaN，返回 true. 否则，返回 false. 注：测试ECMAScript代码值X是否为NaN的可靠方式是形式为X!==X。只有当X为NaN时，结果才为true。 18.2.4 parseFloat ( string ) parseFloat函数产生一个Number值，该值由将字符串参数的内容解释为十进制文字来指示。 parseFloat函数是％parseFloat％内部对象。当使用一个参数字符串调用parseFloat函数时，将执行以下步骤： 令 inputString 为 ? ToString(string). 令trimmedString为inputString的子字符串，该子字符串由不是StrWhiteSpaceChar的最左边的代码单元以及该代码单元右边的所有代码单元组成。 （换句话说，删除前导空格。）如果inputString不包含任何此类代码单元，则将trimmedString设为空字符串。 如果trimmedString或trimmedString的任何前缀都不满足StrDecimalLiteral的语法（请参见7.1.3.1），则返回NaN。 令numberString为trimmedString的最长前缀，它可以是trimmedString本身，它满足StrDecimalLiteral的语法。 令 mathFloat 为 numberString 的MV。 若 mathFloat = 0，那么 如果trimmedString的第一个代码单元是代码单元0x002D（-），则返回-0。 返回 +0. 返回 mathFloat的Number值。 注：parseFloat只能将字符串的开头部分解释为Number值；它忽略了不能解释为十进制文字表示法一部分的任何代码单元，也没有给出任何此类代码单元被忽略的指示。 18.2.5 parseInt ( string, radix ) parseInt函数产生一个整数值，该整数值是根据指定的基数解释字符串参数的内容而指定的。字符串中的前导空格将被忽略。如果基数未定义或为0，则假定为10，除非数字以代码单元对0x或0X开头（在这种情况下，基数为16）。如果基数为16，则数字也可以选择以代码单元对0x或0X开头。 parseInt函数是％parseInt％内部对象。调用parseInt函数时，将执行以下步骤： 令 inputString 为 ? ToString(string). 令S为新创建的inputString子字符串，它由不是StrWhiteSpaceChar的第一个代码单元以及该代码单元之后的所有代码单元组成。 （换句话说，删除前导空格。）如果inputString不包含任何此类代码单元，则使S为空字符串。 令 sign 为 1. 若S不为空，并且S的第一个代码单元是代码单元0x002D（-），, 设置 sign 为 -1. 若S不为空并且S的第一个代码单元是代码单元0x002B（+）或代码单元0x002D(-), 从S中删除第一个代码单元。 令 R 为 ? ToInt32(radix). 令 stripPrefix 为 true. 若 R ≠ 0，那么 若 R 36，返回 NaN. 若 R ≠ 16, 设置 stripPrefix 为 false. Else R = 0, 设置 R 为 10. 若 stripPrefix 是 true，那么 如果S的长度至少为2，并且S的前两个代码单元为“ 0x”或“ 0X”，那么 从S中删除前两个代码单元。 设置 R 为 16. 若S包含不是基数R的代码单元，则令Z为S的子字符串，该子字符串由第一个此类代码单元之前的所有代码单元组成；否则，让Z为S。 若 Z 是 empty，返回 NaN. 令mathInt为Z以基数R表示的数学整数值，使用字母AZ和az表示从10到35的数字。（但是，如果R为10并且Z包含20个以上有效数字，则每个有效数字根据实现的选择，第20个位之后的数字可以用0代替；并且如果R不是2、4、8、10、16或32，则mathInt可以是与实现相关的数学整数的近似值Z以基数R表示的值。） 若 mathInt = 0，那么 若 sign = -1，返回 -0. 返回 +0. 令 number 为mathInt的Number值 返回 sign × number. 注：parseInt只能将字符串的开头部分解释为整数值；它会忽略无法解释为整数符号一部分的任何代码单元，并且不会给出任何此类代码单元被忽略的指示。 18.2.6 URI Handling Functions 统一资源标识符（URI）是用于标识资源（例如网页或文件）和传输协议的字符串，通过这些协议可以在Internet上访问资源（例如HTTP或FTP）。 ECMAScript语言本身不提供对使用URI的任何支持，除了18.2.6.2、18.2.6.3、18.2.6.4和18.2.6.5中所述的编码和解码URI的函数外。 注：ECMAScript的许多实现都提供了操纵网页的其他功能和方法。这些功能超出了本标准的范围。 18.2.6.1 URI 语法和语义 URI由由组件分隔符分隔的一系列组件组成。通用形式为： Scheme : First / Second ; Third ? Fourth 其中斜体名称代表组件，“：”，“ /”，“;”和“？”保留用作分隔符。该encodeURI和decodeURI函数旨在与完整的URI一起使用。它们假定URI中的任何保留代码单元均具有特殊含义，因此未进行编码。该encodeURIComponent和decodeURIComponent函数旨在与URI的各个组成部分一起使用。它们假定任何保留代码单元都代表文本，因此必须进行编码，以便当该组件是完整URI的一部分时，它们不会被解释为保留代码单元。 以下词汇语法指定了已编码URI的形式。 语法 uri ::: uriCharactersopt uriCharacters ::: uriCharacter uriCharactersopt uriCharacter ::: uriReserved uriUnescaped uriEscaped uriReserved ::: one of ; / ? : @ & = + $ , uriUnescaped ::: uriAlpha DecimalDigit uriMark uriEscaped ::: % HexDigit HexDigit uriAlpha ::: one of a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z uriMark ::: one of - _ . ! ~ * ' ( ) 注：以上语法基于RFC 2396，并不反映最新RFC 3986引入的更改 运行时语义 如果上面未列出要包含在URI中的代码单元，或者有时不赋予保留的代码单元特殊含义，则必须对该代码单元进行编码。该代码单元被转换为其UTF-8编码，其中代理对首先从UTF-16转换为相应的代码点值。 （请注意，对于[0，127]范围内的代码单元，这将导致单个octet具有相同的值。）然后，将所得的octet序列转换为字符串，每个octet均以形式为“％”的转义序列表示xx”。 18.2.6.1.1 运行时语义：Encode ( string, unescapedSet ) 编码和转义过程由抽象操作Encode描述，该操作采用两个String参数string和unescapedSet。 令 strLen 为字符串中的代码单位数。 令 R 为空字符串 令 k 为 0. 重复， 若 k 等于 strLen，返回 R. 令 C 为字符串中索引k处的代码单元。 若 C 在 unescapedSet 中，那么 1. 令 S 为仅包含代码单元C的String值。 2. 设置 R 为R和S的先前值的字符串连接。 否则 C 不在unescapedSet中， 若 C 是 a trailing surrogate, 抛出 URIError 异常 若 C 不是前导代理，那么 令 V 为与代码单位C具有相同数值的代码点。 否则， k 增加 1. 若 k 等于 strLen, 抛出 URIError 异常 令 kChar 为字符串中索引k处的代码单元。 若 kChar 不是前导代理, 抛出 URIError 异常 令 V 为 UTF16Decode(C, kChar). 令 Octets 为通过对V应用UTF-8转换得到的八位字节列表。 对于列表顺序中octet的每个元素octet，执行 令 S 为字符串串联： \"%\" octet的字符串表示形式，格式为两位数的大写十六进制数字，如有必要，在左侧添加零 设置 R 为R和S的先前值的字符串连接。 k 增加 1. 18.2.6.1.2 运行时语义：Decode ( string, reservedSet ) 通过使用两个字符串参数string和reservedSet的抽象操作Decode描述了转义和解码过程。 令 strLen 为字符串中的代码单位数。 令 R 为空字符串 令 k 为 0. 重复， 若 k 等于 strLen，返回 R. 令 C 为字符串中索引k处的代码单元。 若 C 不是代码单元0x0025 (%)，那么 令 S 为仅包含代码单元C的String值。 否则 C是代码单元0x0025 (PERCENT SIGN), 令 start 为 k. 若 k + 2 是 大于或等于 strLen, 抛出 URIError 异常 如果字符串中位于索引（k + 1）和（k + 2）的代码单元不表示十六进制数字，抛出 URIError 异常. 令 B 为索引（k + 1）和（k + 2）处两个十六进制数字表示的8位值 k 增加 2. 若B中的最高有效位是 0，那么 令 C 为值为B的代码单位。 若 C 不在 reservedSet 中，那么 令 S 为仅包含代码单元C的String值。 否则 C 在reservedSet中, 令 S 为字符串的子字符串，从索引开始到索引k（包括索引）。 否则 B 中的最高有效位是1 令 n 为最小的非负整数，使得（B 若 n 等于 1 或 n 大于 4, 抛出 URIError 异常 令 Octets 为一个大小为n的8位整数列表。 设置 Octets[0] 为 B. 若 k + (3 × (n - 1)) 是大于等于strLen, 抛出 URIError 异常 令 j 为 1. 重复，while j k 增加 1. 若字符串中索引k处的代码单元不是代码单元 0x0025 (%), 抛出 URIError 异常 若字符串中位于索引（k + 1）和（k + 2）的代码单元不表示十六进制数字, 抛出 URIError 异常 令 B 为由索引（k + 1）和（k + 2）处的两个十六进制数字表示的8位值。 若B中的两个最高有效位不是10, 抛出 URIError 异常 k 增加 2. 设置 Octets[j] 为 B. j 增加 1. 若octet不包含Unicode代码点的有效UTF-8编码，引发URIError异常。 令 V 为通过对Octets应用UTF-8转换而获得的值，即从Octets列表转换为21位值。 令 S 为String值，其代码单位按顺序是UTF16Encoding（V）中的元素。 设置 R 为 R 和S的先前值的字符串连接。 k 增加 1. 注：这种统一资源标识符的语法基于RFC 2396，并且不反映更新的RFC 3986（它代替RFC 2396）。RFC3629中给出了UTF-8的正式描述和实现。 在UTF-8中，使用1到6个octets的序列对字符进行编码。序列1的唯一octet将高阶位设置为0，其余7位用于编码字符值。在n个octet的序列中，n> 1，初始octet的n个高阶位设置为1，其后的位设置为0。该octet的其余位包含要编码的字符值中的位。接下来的octet的高位均设置为1，随后的位均设置为0，每个位保留6位以包含来自要编码字符的位。表46中指定了ECMAScript字符可能的UTF-8编码。 Code Unit Value Representation 1st Octet 2nd Octet 3rd Octet 4th Octet 0x0000 - 0x007F 00000000 0zzzzzzz 0zzzzzzz 0x0080 - 0x07FF 00000yyy yyzzzzzz 110yyyyy 10zzzzzz 0x0800 - 0xD7FF xxxxyyyy yyzzzzzz 1110xxxx 10yyyyyy 10zzzzzz 0xD800 - 0xDBFF followed by 0xDC00 - 0xDFFF 110110vv vvwwwwxx followed by 110111yy yyzzzzzz 11110uuu 10uuwwww 10xxyyyy 10zzzzzz 0xD800 - 0xDBFF not followed by 0xDC00 - 0xDFFF causes URIError 0xDC00 - 0xDFFF causes URIError 0xE000 - 0xFFFF xxxxyyyy yyzzzzzz 1110xxxx 10yyyyyy 10zzzzzz 其中，uuuuu = vvvv + 1代表Unicode标准（替代）第3.8节中添加的0x10000。 上面的转换将每个代理对（保留其在0xD800到0xDFFF范围内的代码单元值）组合为UTF-32表示形式，并将得到的21位值编码为UTF-8。解码可重建代理对。 RFC 3629禁止解码无效的UTF-8八位位组序列。例如，无效序列C0 80不得解码为代码单元0x0000。遇到此类无效序列时，需要使用Decode算法的实现来引发URIError。 18.2.6.2 decodeURI ( encodedURI ) encodeURI函数计算URI的新版本，其中可能由encodeURI函数引入的每个转义序列和此类的UTF-8编码都用其表示的代码点的UTF-16编码代替。无法替换encodeURI无法引入的转义序列。 encodeURI函数是％decodeURI％内部对象。当用一个参数encodedURI调用decodeURI函数时，将执行以下步骤： 令 uriString 为 ? ToString(encodedURI). 令reservedURISet为一个字符串，其中包含在uriReserved中有效的每个代码单元的一个实例加“＃”。 返回 ? Decode(uriString, reservedURISet). 注：即使不是保留的URI代码点，也不会从转义序列中解码代码点“＃”。 18.2.6.3 decodeURIComponent ( encodedURIComponent ) encodeURIComponent函数计算URI的新版本，其中可能由encodeURIComponent函数引入的每个转义序列和此类的UTF-8编码都用其表示的代码点的UTF-16编码代替。 encodeURIComponent函数是％decodeURIComponent％内部对象。当使用一个已编码URIComponent参数调用decodeURIComponent函数时，将执行以下步骤： 令 componentString 为 ? ToString(encodedURIComponent). 令 reservedURIComponentSet 为空字符串。 返回 ? Decode(componentString, reservedURIComponentSet). 18.2.6.4 encodeURI ( uri ) encodeURI函数计算UTF-16编码（6.1.4）URI的新版本，其中某些代码点的每个实例都被一个，两个，三个或四个表示代码点UTF-8编码的转义序列替换。 encodeURI函数是％encodeURI％内部对象。当使用一个参数uri调用encodeURI函数时，将执行以下步骤： 令 uriString 为 ? ToString(uri). 令 unescapedURISet 为一个字符串，其中包含在uriReserved和uriUnescaped加上“＃”有效的每个代码单元的一个实例。 返回 ? Encode(uriString, unescapedURISet). 注：即使代码单元“＃”不是保留或未转义的URI代码点，也不会被编码为转义序列。 18.2.6.5 encodeURIComponent ( uriComponent ) encodeURIComponent函数计算新版本的UTF-16编码（6.1.4）URI，其中某些代码点的每个实例都被一个，两个，三个或四个表示代码点UTF-8编码的转义序列替换。 encodeURIComponent函数是％encodeURIComponent％内部对象。当使用一个参数uriComponent调用encodeURIComponent函数时，将执行以下步骤： 令 componentString 为 ? ToString(uriComponent). 令 unescapedURIComponentSet 为一个字符串，其中包含在uriUnescapeed中有效的每个代码单元的一个实例。 返回 ? Encode(componentString, unescapedURIComponentSet). 18.3 全局对象的构造函数属性 18.3.1 Array ( . . . ) See 22.1.1 18.3.2 ArrayBuffer ( . . . ) See 24.1.2. 18.3.3 Boolean ( . . . ) See 19.3.1. 18.3.4 DataView ( . . . ) See 24.3.2. 18.3.5 Date ( . . . ) See 20.3.2 18.3.6 Error ( . . . ) See 19.5.1 18.3.7 EvalError ( . . . ) See 19.5.5.1 18.3.8 Float32Array ( . . . ) See 22.2.4. 18.3.9 Float64Array ( . . . ) See 22.2.4. 18.3.10 Function ( . . . ) See 19.2.1. 18.3.11 Int8Array ( . . . ) See 22.2.4. 18.3.12 Int16Array ( . . . ) See 22.2.4. 18.3.13 Int32Array ( . . . ) See 22.2.4. 18.3.14 Map ( . . . ) See 23.1.1. 18.3.15 Number ( . . . ) See 20.1.1. 18.3.16 Object ( . . . ) See 19.1.1. 18.3.17 Promise ( . . . ) See 25.6.3. 18.3.18 Proxy ( . . . ) See 26.2.1. 18.3.19 RangeError ( . . . ) See 19.5.5.2 18.3.20 ReferenceError ( . . . ) See 19.5.5.3. 18.3.21 RegExp ( . . . ) See 21.2.3. 18.3.22 设置 ( . . . ) See 23.2.1. 18.3.23 SharedArrayBuffer ( . . . ) See 24.2.2. 18.3.24 String ( . . . ) See 21.1.1. 18.3.25 Symbol ( . . . ) See 19.4.1. 18.3.26 SyntaxError ( . . . ) See 19.5.5.4. 18.3.27 TypeError ( . . . ) See 19.5.5.5. 18.3.28 Uint8Array ( . . . ) See 22.2.4. 18.3.29 Uint8ClampedArray ( . . . ) See 22.2.4. 18.3.30 Uint16Array ( . . . ) See 22.2.4. 18.3.31 Uint32Array ( . . . ) See 22.2.4 18.3.32 URIError ( . . . ) See 19.5.5.6. 18.3.33 WeakMap ( . . . ) See 23.3.1 18.3.34 WeakSet ( . . . ) See 23.4. 18.4 全局对象的其他属性 18.4.1 Atomics See 24.4. 18.4.2 JSON See 24.5. 18.4.3 Math See 20.2. 18.4.4 Reflect See 26.1 "},"fundamental-objects.html":{"url":"fundamental-objects.html","title":"19 基本对象","keywords":"","body":"19 基本对象 19.1 Object 对象 19.1.1 Object 构造器 对象构造函数： 是内部对象％Object％。 是全局对象的对象属性的初始值。 在作为构造函数调用时创建一个新的普通对象。 在作为函数而不是构造函数调用时执行类型转换。 被设计为可子类化。它可以用作类定义的extends子句的值。 19.1.1.1 Object ( [ value ] ) 使用可选参数值调用对象函数时，采取以下步骤: 如果NewTarget既不是undefined的，也不是活动函数，则 返回 ? OrdinaryCreateFromConstructor(NewTarget, \"%ObjectPrototype%\"). 若 value 是 null, undefined 或不提供, 返回 ObjectCreate(%ObjectPrototype%). 返回 ! ToObject(value). 对象构造函数的“length”属性是1 19.1.2 Object 构造器属性 对象构造函数： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 具有“length”属性。 具有以下附加属性： 19.1.2.1 Object.assign ( target, ...sources ) Assign函数用于将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。调用assign函数时，将执行以下步骤： 令 to 为 ? ToObject(target). 如果仅传递了一个参数, 返回 to. 令 sources 为从第二个参数开始的参数值列表。 对于每个元素nextsource的源，按升序排列，执行 如果nextSource既undefined也不为null，那么 令 from 为 ! ToObject(nextSource). 令 keys 为 ? from.[[OwnPropertyKeys]](). 对于按列表顺序的键的每个元素nextKey，执行 令 desc 为 ? from.[[GetOwnProperty]](nextKey). 如果desc不是undefined并且desc.[[Enumerable]]为true，那么 返回 to. 分配函数的“length”属性为2。 19.1.2.2 Object.create ( O, Properties ) create函数使用指定的原型创建一个新对象。调用create函数时，将执行以下步骤： 若 Type(O) 不是 Object 或 Null, 抛出 TypeError 异常。 令 obj 为 ObjectCreate(O). 若 Properties 不是 undefined，那么 返回 ? ObjectDefineProperties(obj, Properties). 返回 obj. 19.1.2.3 Object.defineProperties ( O, Properties ) defineProperties函数用于添加自己的属性和/或更新对象现有的自己属性的属性。调用defineProperties函数时，将执行以下步骤： 返回 ? ObjectDefineProperties(O, Properties). 19.1.2.3.1 RS: ObjectDefineProperties ( O, Properties ) 具有参数O和属性的抽象操作ObjectDefineProperties执行以下步骤： 若 Type(O) 不是 Object, 抛出 TypeError 异常。 令 props 为 ? ToObject(Properties). 令 keys 为 ? props.[[OwnPropertyKeys]](). 令 descriptors 为新的空列表 对于按列表顺序的键的每个元素nextKey，执行 令 propDesc 为 ? props.[[GetOwnProperty]](nextKey). 若 propDesc 不是 undefined 并且 propDesc.[[Enumerable]] 是 true，那么 令 descObj 为 ? Get(props, nextKey). 令 desc 为 ? ToPropertyDescriptor(descObj). 将由nextKey和desc组成的对（一个由两个元素组成的List）附加到描述符的末尾。 对于列表中描述符中的每一对，执行 令 P 为对的第一个元素。 令 desc 为对的第二个元素。 执行 ? DefinePropertyOrThrow(O, P, desc). 返回 O. 19.1.2.4 Object.defineProperty ( O, P, Attributes ) defineProperty函数用于添加自己的属性和/或更新对象现有的自己属性的属性。调用defineProperty函数时，将执行以下步骤： 若 Type(O) 不是 Object, 抛出 TypeError 异常。 令 key 为 ? ToPropertyKey(P). 令 desc 为 ? ToPropertyDescriptor(Attributes). 执行 ? DefinePropertyOrThrow(O, key, desc). 返回 O 19.1.2.5 Object.entries ( O ) 当使用参数O调用entrys函数时，将执行以下步骤： 令 obj 为 ? ToObject(O). 令 nameList 为 ? EnumerableOwnPropertyNames(obj, \"key+value\"). 返回 CreateArrayFromList(nameList). 19.1.2.6 Object.freeze ( O ) 调用冻结函数时，将执行以下步骤： 若 Type(O) 不是 Object, 返回 O. 令 status 为 ? SetIntegrityLevel(O, \"frozen\"). 若 status 是 false, 抛出 TypeError 异常。 返回 O. 19.1.2.7 Object.fromEntries ( iterable ) 当使用参数iterable调用fromEntries方法时，将执行以下步骤： 执行 ? RequireObjectCoercible(iterable). 令 obj 为 ObjectCreate(%ObjectPrototype%). 断言：obj是没有自己属性的可扩展普通对象。 令 stepsDefine 为CreateDataPropertyOnObject函数中定义的算法步骤。 令 adder 为 CreateBuiltinFunction(stepsDefine, « »). 返回 ? AddEntriesFromIterable(obj, iterable, adder). 注：ECMAScript代码绝对不能直接访问为adder创建的函数。 19.1.2.7.1 CreateDataPropertyOnObject Functions CreateDataPropertyOnObject函数是匿名内置函数。当使用参数key和value调用CreateDataPropertyOnObject函数时，将执行以下步骤： 令 O 为 this 值. 断言：Type(O) 是 Object. 断言：O是可扩展的普通对象。 令 propertyKey 为 ? ToPropertyKey(key). 执行 ! CreateDataPropertyOrThrow(O, propertyKey, value). 返回 undefined. 19.1.2.8 Object.getOwnPropertyDescriptor ( O, P ) 调用getOwnPropertyDescriptor函数时，将执行以下步骤： 令 obj 为 ? ToObject(O). 令 key 为 ? ToPropertyKey(P). 令 desc 为 ? obj.[[GetOwnProperty]](key). 返回 FromPropertyDescriptor(desc). 19.1.2.9 Object.getOwnPropertyDescriptors ( O ) 调用getOwnPropertyDescriptors函数时，将执行以下步骤： 令 obj 为 ? ToObject(O). 令 ownKeys 为 ? obj.[[OwnPropertyKeys]](). 令 descriptors 为 ! ObjectCreate(%ObjectPrototype%). 对于List顺序中ownKeys的每个元素键，执行 令 desc 为 ? obj.[[GetOwnProperty]](key). 令 descriptor 为 ! FromPropertyDescriptor(desc). 若 descriptor 不是 undefined, 执行 ! CreateDataProperty(descriptors, key, descriptor). 返回 descriptors. 19.1.2.10 Object.getOwnPropertyNames ( O ) 调用getOwnPropertyNames函数时，将执行以下步骤： 返回 ? GetOwnPropertyKeys(O, String). 19.1.2.11 Object.getOwnPropertySymbols ( O ) 使用参数O调用getOwnPropertySymbols函数时，将执行以下步骤： 返回 ? GetOwnPropertyKeys(O, Symbol). 19.1.2.11.1 RS: GetOwnPropertyKeys ( O, type ) 使用参数O和类型调用抽象操作GetOwnPropertyKeys，其中类型O为对象，类型为ECMAScript规范类型String或Symbol之一。采取以下步骤： 令 obj 为 ? ToObject(O). 令 keys 为 ? obj.[[OwnPropertyKeys]](). 令 nameList 为新的空列表 对于按列表顺序的键的每个元素nextKey，执行 1. 若 Type(nextKey) 是 type，那么 1. 追加nextKey作为nameList的最后一个元素。 返回 CreateArrayFromList(nameList). 19.1.2.12 Object.getPrototypeOf ( O ) 使用参数OF调用getPrototypeOf函数时，将执行以下步骤： 令 obj 为 ? ToObject(O). 返回 ? obj.[[GetPrototypeOf]](). 19.1.2.13 Object.is ( value1, value2 ) 当使用参数value1和value2调用is函数时，将执行以下步骤： 返回 SameValue(value1, value2). 19.1.2.14 Object.isExtensible ( O ) 当使用参数O调用is可扩展函数时，将执行以下步骤： 若 Type(O) 不是 Object, 返回 false. 返回 ? IsExtensible(O). 19.1.2.15 Object.isFrozen ( O ) 使用参数O调用isFrozen函数时，将执行以下步骤： 若 Type(O) 不是 Object, 返回 true. 返回 ? TestIntegrityLevel(O, \"frozen\"). 19.1.2.16 Object.isSealed ( O ) 当使用参数O调用is Sealed函数时，将执行以下步骤： 若 Type(O) 不是 Object, 返回 true. 返回 ? TestIntegrityLevel(O, \"sealed\"). 19.1.2.17 Object.keys ( O ) 当使用参数O调用keys函数时，将执行以下步骤： 令 obj 为 ? ToObject(O). 令 nameList 为 ? EnumerableOwnPropertyNames(obj, \"key\"). 返回 CreateArrayFromList(nameList). 19.1.2.18 Object.preventExtensions ( O ) 调用preventExtensions函数时，将执行以下步骤： 若 Type(O) 不是 Object, 返回 O. 令 status 为 ? O.[[PreventExtensions]](). 若 status 是 false, 抛出 TypeError 异常。 返回 O. 19.1.2.19 Object.prototype Object.prototype的初始值为内部对象％ObjectPrototype％。 该属性具有以下属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.1.2.20 Object.seal ( O ) 调用seal函数时，将执行以下步骤： 若 Type(O) 不是 Object, 返回 O. 令 status 为 ? SetIntegrityLevel(O, \"sealed\"). 若 status 是 false, 抛出 TypeError 异常。 返回 O. 19.1.2.21 Object.setPrototypeOf ( O, proto ) 当使用参数O和proto调用setPrototypeOf函数时，将执行以下步骤： 设置 O 为 ? RequireObjectCoercible(O). 若 Type(proto) 不是 Object 或 Null, 抛出 TypeError 异常。 若 Type(O) 不是 Object, 返回 O. 令 status 为 ? O.[[SetPrototypeOf]](proto). 若 status 是 false, 抛出 TypeError 异常。 返回 O. 19.1.2.22 Object.values ( O ) 当使用参数O调用values函数时，将执行以下步骤： 令 obj 为 ? ToObject(O). 令 nameList 为 ? EnumerableOwnPropertyNames(obj, \"value\"). 返回 CreateArrayFromList(nameList). 19.1.3 Object 原型对象属性 对象原型对象： 是内部对象％ObjectPrototype％。 是不变的原型异类对象 有一个[[Prototype]]内部插槽，其值为null。 19.1.3.1 Object.prototype.constructor Object.prototype.constructor的初始值为内部对象％Object％。 19.1.3.2 Object.prototype.hasOwnProperty ( V ) 当使用参数V调用hasOwnProperty方法时，将执行以下步骤： 令 P 为 ? ToPropertyKey(V). 令 O 为 ? ToObject(this value). 返回 ? HasOwnProperty(O, P). 注：选择步骤1和2的顺序是为了确保即使this值undefined或为null，在本规范的先前版本中由步骤1引发的任何异常都将继续引发。 19.1.3.3 Object.prototype.isPrototypeOf ( V ) 使用参数V调用isPrototypeOf方法时，将执行以下步骤： 若 Type(V) 不是 Object, 返回 false. 令 O 为 ? ToObject(this value). 重复， 设置 V 为 ? V.[[GetPrototypeOf]](). 若 V 是 null, 返回 false. 若 SameValue(O, V) 是 true, 返回 true. 注：对于V不是对象且this值undefined或为null的情况，步骤1和2的顺序保留了本规范先前版本指定的行为。 19.1.3.4 Object.prototype.propertyIsEnumerable ( V ) 当使用参数V调用propertyIsEnumerable方法时，将执行以下步骤： 令 P 为 ? ToPropertyKey(V). 令 O 为 ? ToObject(this value). 令 desc 为 ? O.[[GetOwnProperty]](P). 若 desc 是 undefined, 返回 false. 返回 desc.[[Enumerable]]. 注1：该方法不考虑原型链中的对象。 注2：选择步骤1和2的顺序是为了确保即使this值为undefined或null，在本规范先前版本中由步骤1引发的任何异常都将继续引发。 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] ) 调用toLocaleString方法时，将执行以下步骤： 令 O 为 this 值. 返回 ? Invoke(O, \"toString\"). 该函数的可选参数未使用，但旨在与ECMA-402 toLocaleString函数使用的参数模式相对应。不包含ECMA-402支持的实现不得将这些参数位置用于其他目的。 注1：该函数为没有特定于语言环境的toString行为的对象提供通用的toLocaleString实现。数组，数字，日期和类型数组提供了它们自己的区域设置敏感的toLocaleString方法。 注2：ECMA-402有意不提供此默认实施方式的替代方法。 19.1.3.6 Object.prototype.toString ( ) 调用toString方法时，将执行以下步骤： 若 this 值是 undefined, 返回 \"[object Undefined]\". 若 this 值是 null, 返回 \"[object Null]\". 令 O 为 ! ToObject(this value). 令 isArray 为 ? IsArray(O). 若 isArray 是 true, 令 builtinTag 为 \"Array\". 否则，若 O 是 String 异类对象, 令 builtinTag 为 \"String\". 否则，若 O 具有 [[ParameterMap]] 内部插槽, 令 builtinTag 为 \"Arguments\". 否则，若 O 具有 [[Call]] 内部方法, 令 builtinTag 为 \"Function\". 否则，若 O 具有 [[ErrorData]] 内部插槽, 令 builtinTag 为 \"Error\". 否则，若 O 具有 [[BooleanData]] 内部插槽, 令 builtinTag 为 \"Boolean\". 否则，若 O 具有 [[NumberData]] 内部插槽, 令 builtinTag 为 \"Number\". 否则，若 O 具有 [[DateValue]] 内部插槽, 令 builtinTag 为 \"Date\". 否则，若 O 具有 [[RegExpMatcher]] 内部插槽, 令 builtinTag 为 \"RegExp\". 否则, 令 builtinTag 为 \"Object\". 令 tag 为 ? Get(O, @@toStringTag). 若 Type(tag) 不是 String, 设置 tag 为 builtinTag. 返回 \"[object \", tag, and \"]\" 的字符串连接 此函数是％ObjProto_toString％内部对象。 注：从历史上看，此函数有时用于访问[[Class]]内部插槽的String值，该内部插槽在本规范的先前版本中用作各种内置对象的标称类型标记。上面对toString的定义保留了与使用toString来测试那些特定种类的内置对象的旧代码的兼容性。它没有为其他类型的内置或程序定义的对象提供可靠的类型测试机制。另外，程序可以使用@@ toStringTag，这将使此类旧式测试的可靠性无效。 19.1.3.7 Object.prototype.valueOf ( ) 调用valueOf方法时，将执行以下步骤 返回 ? ToObject(this value). 此函数是％ObjProto_valueOf％内部对象。 19.1.4 Object 实例属性 对象实例除了从Object原型对象继承的属性外，没有其他特殊属性。 19.2 Function 对象 19.2.1 Function 构造器 函数构造函数： 是内部对象％Function％。 是全局对象的Function属性的初始值。 当作为函数而不是构造函数调用时，创建并初始化一个新的函数对象。因此，函数调用Function（…）等效于具有相同参数的对象创建表达式new Function（…）。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定Function行为的子类构造函数必须包括对Function构造函数的super调用，以使用内置函数行为所需的内部插槽来创建和初始化子类实例。用于定义函数对象的所有ECMAScript语法形式都将创建Function的实例。 除了内置的GeneratorFunction，AsyncFunction和AsyncGeneratorFunction子类之外，没有语法方法可以创建Function子类的实例。 19.2.1.1 Function ( p1, p2, … , pn, body ) 最后一个参数指定函数的主体（可执行代码）；前面的任何参数都指定形式参数。 当使用某些参数p1，p2，…，pn主体（其中n可能为0，即没有“ p”参数，也可能不提供主体）调用Function函数时，将执行以下步骤采取： 令 C 为活动函数对象。 令 args 为由[[Call]]或[[Construct]]传递给此函数的argumentsList。 返回 ? CreateDynamicFunction(C, NewTarget, \"normal\", args). 注：允许但不必为每个要指定的形式参数使用一个参数。例如，以下所有三个表达式产生相同的结果： new Function(\"a\", \"b\", \"c\", \"return a+b+c\") new Function(\"a, b, c\", \"return a+b+c\") new Function(\"a,b\", \"c\", \"return a+b+c\") 19.2.1.1.1 RS: CreateDynamicFunction ( constructor, newTarget, kind, args ) 抽象操作CreateDynamicFunction用参数构造函数，newTarget，kind和args调用。构造函数是执行此操作的构造函数，newTarget是new最初应用于的构造函数，kind是“ normal”，“ generator”，“ async”或“ async generator”，而args是包含以下内容的List传递给构造函数的实际参数值。采取以下步骤： 断言：执行上下文堆栈至少具有两个元素。 令 callerContext 为执行上下文堆栈的第二个元素。 令 callerRealm 为 callerContext 的作用域. 令 calleeRealm 为大年作用域记录 执行 ? HostEnsureCanCompileStrings(callerRealm, calleeRealm). 若 newTarget 是 undefined, 设置 newTarget 为 constructor. 若 kind 是 \"normal\"，那么 令 goal 为语法标记 FunctionBody[~Yield, ~Await] . 令 parameterGoal 为语法标记 FormalParameters[~Yield, ~Await] . 令 fallbackProto 为 \"%FunctionPrototype%\". 否则，若 kind 是 \"generator\"，那么 令 goal 为语法标记 GeneratorBody. 令 parameterGoal 为语法标记 FormalParameters[+Yield, ~Await] . 令 fallbackProto 为 \"%Generator%\". 否则，若 kind 是 \"async\"，那么 令 goal 为语法标记 AsyncFunctionBody. 令 parameterGoal 为语法标记 FormalParameters[~Yield, +Await] . 令 fallbackProto 为 \"%AsyncFunctionPrototype%\". 否则， 断言：kind 是 \"async generator\". 令 goal 为语法标记 AsyncGeneratorBody. 令 parameterGoal 为语法标记 FormalParameters[+Yield, +Await] . 令 fallbackProto 为 \"%AsyncGenerator%\". 令 argCount 为 args 中的元素数。 令 P 为空字符串。 若 argCount = 0, 令 bodyText 为空字符串 否则，若 argCount = 1, 令 bodyText 为 args[0]. 否则，argCount > 1, 令 firstArg 为 args[0]. 设置 P 为 ? ToString(firstArg). 令 k 为 1. 重复， 当 k 令 nextArg 为 args[k]. 令 nextArgString 为 ? ToString(nextArg). 设置 P 为 P, \",\" (a comma), and nextArgString 的先前值的字符串连接的值 k 增加 1. 令 bodyText 为 args[k]. 设置 bodyText 为 ? ToString(bodyText). 令 parameters 为使用parameterGoal作为目标符号的解析P的结果，解释为6.1.4中描述的UTF-16编码的Unicode文本。如果解析失败，则抛出SyntaxError异常。 令 body 为解析bodyText的结果，使用目标作为目标符号，解释为6.1.4中描述的UTF-16编码的Unicode文本。如果解析失败，则抛出SyntaxError异常。 令 strict 为 body 的 ContainsUseStrict。 如果检测到参数或主体的任何静态语义错误，则根据错误的类型，抛出SyntaxError或ReferenceError异常。如果strict为true，则将应用UniqueFormalParameters：FormalParameters的Early Error规则。解析和早期错误检测可以以依赖于实现的方式混合在一起。 如果strict为true而IsSimpleParameterList为假, 抛出 SyntaxError 异常。 如果parameters的BoundNames的任何元素也出现在body的LexicallyDeclaredNames中，抛出 SyntaxError 异常。 若 body 包含 SuperCall 是 true, 抛出 SyntaxError 异常。 若 parameters 包含 SuperCall 是 true, 抛出 SyntaxError 异常。 若 body 包含 SuperProperty 是 true, 抛出 SyntaxError 异常。 若 parameters 包含 SuperProperty 是 true, 抛出 SyntaxError 异常。 若 kind 是 \"generator\" 或 \"async generator\"，那么 若 parameters 包含 YieldExpression 是 true, 抛出 SyntaxError 异常。 若 kind 是 \"async\" 或 \"async generator\"，那么 若 parameters 包含 AwaitExpression 是 true, 抛出 SyntaxError 异常。 若 strict 是 true，那么 如果parameters的BoundNames包含任何重复的元素，抛出 SyntaxError 异常。 令 proto 为 ? GetPrototypeFromConstructor(newTarget, fallbackProto). 令 F 为 FunctionAllocate(proto, strict, kind). 令 realmF 为 F.[[Realm]]. 令 scope 为 realmF.[[GlobalEnv]]. 执行 FunctionInitialize(F, Normal, parameters, body, scope). 若 kind 是 \"generator\"，那么 令 prototype 为 ObjectCreate(%GeneratorPrototype%). 执行 DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 否则，若 kind 是 \"async generator\"，那么 令 prototype 为 ObjectCreate(%AsyncGeneratorPrototype%). 执行 DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 否则，若 kind 是 \"normal\", 执行 MakeConstructor(F). 注意：异步函数不是可构造的，也没有[[Construct]]内部方法或“prototype”属性 执行 SetFunctionName(F, \"anonymous\"). 令 prefix 为表47中与kind相关的前缀。 令 sourceText 为 prefix, \" anonymous(\", P, 0x000A (LINE FEED), \") {\", 0x000A (LINE FEED), bodyText, 0x000A (LINE FEED), and \"}\" 的字符串连接 设置 F.[[SourceText]] 为 sourceText. 返回 F. 注意，对于使用CreateDynamicFunction创建的每个非异步函数，都会创建一个prototype属性，以提供将该函数用作构造函数的可能性。 表47:动态函数SourceText前缀 Kind Prefix \"normal\" \"function\" \"generator\" \"function*\" \"async\" \"async function\" \"async generator\" \"async function*\" 19.2.2 Function 构造器属性 构造函数的函数: 本身就是一个内置函数对象。 有一个[[Prototype]]内部槽，其值为内部对象%FunctionPrototype%。 具有以下特性: 19.2.2.1 Function.length 这是一个值为1的数据属性。该属性的属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。 19.2.2.2 Function.prototype Function.prototyp的值为%FunctionPrototype%，即内部函数原型对象。 此属性具有属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.2.3 Function 原型对象属性 函数原型对象： 是内部对象%FunctionPrototype%。 本身就是一个内置函数对象。 接受任何参数并在调用时返回undefined的值。 没有[[Construct]]内部方法；它不能与新操作符一起用作构造函数。 有一个[[Prototype]]内部槽，其值为内部对象%ObjectPrototype%。 没有原型属性。 具有“length”属性，其值为0。 具有name属性，其值为空字符串。 NOTE The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification. 19.2.3.1 Function.prototype.apply ( thisArg, argArray ) 当使用参数thisArg和argArray调用apply方法时，需要执行以下步骤: 令 func 为 this 值. 若 IsCallable(func) 是 false, 抛出 TypeError 异常。 若 argArray 是 undefined 或 null，那么 执行 PrepareForTailCall(). 返回 ? Call(func, thisArg). 令 argList 为 ? CreateListFromArrayLike(argArray). 执行 PrepareForTailCall(). 返回 ? Call(func, thisArg, argList). 注 1：将thisArg值作为this值传递，而不进行任何修改。这是版本3的一个变化，其中undefined或null thisArg被替换为全局对象，ToObject应用于所有其他值，结果作为This值传递。即使没有修改就传递了thisArg，非严格函数仍然在进入函数时执行这些转换。 注 2：如果func是一个箭头函数或绑定函数，那么这个thisArg将被第5步中的函数[[Call]]忽略 19.2.3.2 Function.prototype.bind ( thisArg, ...args ) 当绑定方法被参数thisArg和零个或多个args调用时，它执行以下步骤: 令 Target 为 this 值. 若 IsCallable(Target) 是 false, 抛出 TypeError 异常。 令 args 为一个新的(可能是空的)列表，由thisArg之后提供的所有参数值按顺序组成。 令 F 为 ? BoundFunctionCreate(Target, thisArg, args). 令 targetHasLength 为 ? HasOwnProperty(Target, \"length\"). 若 targetHasLength 是 true，那么 令 targetLen 为 ? Get(Target, \"length\"). 若 Type(targetLen) 不是 Number, 令 L 为 0. 否则, 设置 targetLen 为 ! ToInteger(targetLen). 令 L 为0和targetLen的结果减去args的元素数中较大的数。 否则，令 L 为 0. 执行 ! SetFunctionLength(F, L). 令 targetName 为 ? Get(Target, \"name\"). 若 Type(targetName) 不是 String, 设置 targetName 为空字符串 执行 SetFunctionName(F, targetName, \"bound\"). 返回 F. 注 1：使用Function.prototype创建的Function.prototype.bind是异类对象。它们也没有原型属性。 注 2：如果Target是一个箭头函数或绑定函数，那么传递给这个方法的thisArg将不会被后续的F调用所使用 19.2.3.3 Function.prototype.call ( thisArg, ...args ) 当使用参数thisArg和零个或多个args调用调用方法时，将采取以下步骤: 令 func 为 this 值. 若 IsCallable(func) 是 false, 抛出 TypeError 异常。 令 argList 为新的空列表 如果使用多个参数调用此方法，则按照从左到右的顺序，从第二个参数开始，将每个参数附加为argList的最后一个元素。 执行 PrepareForTailCall(). 返回 ? Call(func, thisArg, argList). 注 1：将thisArg值作为this值传递，而不进行任何修改。这是版本3的一个变化，其中undefined的或null thisArg被替换为全局对象，ToObject应用于所有其他值，结果作为This值传递。即使没有修改就传递了thisArg，非严格函数仍然在进入函数时执行这些转换。 注 2：如果func是一个箭头函数或绑定函数，那么这个thisArg将被第5步中的函数[[Call]]忽略。 19.2.3.4 Function.prototype.constructor Function.prototype.constructor的初始值是内部对象%Function%。 19.2.3.5 Function.prototype.toString ( ) 当toString方法被调用时，需要执行以下步骤: 令 func 为 this 值. 如果func是绑定函数异类对象或内置函数对象，则返回依赖于实现的 func 的字符串源代码表示。该表示形式必须具有NativeFunction的语法。此外，如果func是常见的内在对象，并且未标识为匿名函数，则返回的String中与PropertyName匹配的部分必须是func的name属性的初始值。 如果Type(func)是Object并且func具有[[SourceText]]内部插槽，并且Type(func.[[SourceText]])是String和 ! HostHasSourceTextAvailable(func)为true，那么返回func.[[SourceText]] 若 Type(func) 是 Object 并且 IsCallable(func) 是 true，那么 返回返回func的与实现相关的String源代码表示形式。该表示形式必须具有NativeFunction的语法。 抛出 TypeError 异常。 NativeFunction : function PropertyName[~Yield, ~Await] opt ( FormalParameters[~Yield, ~Await] ) { [ native code ] } 19.2.3.6 Function.prototype [ @@hasInstance ] ( V ) 当使用值V调用对象F的@@hasInstance方法时，将执行以下步骤： 令 F 为 this 值. 返回 ? OrdinaryHasInstance(F, V). 该函数的name属性的值为“ [Symbol.hasInstance]”。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 注：这是大多数函数继承的@@hasInstance的默认实现。 @@hasInstance由instanceof运算符调用，以确定某个值是否为特定构造函数的实例。诸如 v instanceof F 解释执行为 F[@@hasInstance](v) 构造函数可以通过在函数上暴露不同的@@hasInstance方法来控制instanceof将哪些对象识别为其实例。 此属性是不可写的且不可配置的，以防止可能被用来全局公开绑定函数的目标函数的篡改。 19.2.4 Function 实例 每个Function实例都是ECMAScript函数对象，并且具有在表27中列出的内部插槽。使用Function.prototype.bind方法（19.2.3.2）创建的函数对象具有在表28中列出的内部插槽。 函数实例具有以下属性： 19.2.4.1 length “ length”属性的值是一个整数，表示该函数期望的典型参数数量。但是，该语言允许使用其他一些参数来调用该函数。当函数调用多个参数而不是由其“ length”属性指定的数字时，其行为取决于函数。此属性具有属性{[[[Writable]]：false，[[Enumerable]]：false，[[Configurable]]：true}。 19.2.4.2 name 没有与此规范关联的上下文名称的匿名函数对象不具有名称拥有的属性，而是继承％FunctionPrototype％的name属性。 19.2.4.3 prototype 可用作构造函数的函数实例具有prototype属性。每当创建这样的Function实例时，也会创建另一个普通对象，该对象是函数的prototype属性的初始值。除非另有说明，否则原型属性的值将用于初始化在将该函数作为构造函数调用时创建的对象的[[Prototype]]内部插槽。 该属性具有以下特性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. 注：使用Function.prototype.bind或通过解释执行MethodDefinition（不是GeneratorMethod或AsyncGeneratorMethod）或ArrowFunction创建的函数对象没有原型属性。 19.2.5 HostHasSourceTextAvailable ( func ) HostHasSourceTextAvailable是实现定义的抽象操作，允许主机环境阻止为给定函数提供源文本。 在所有情况下，HostHasSourceTextAvailable的实现都必须正常完成。该操作必须在参数方面具有确定性。每次使用特定函数作为参数调用它时，它都必须返回相同的完成记录。 HostHasSourceTextAvailable的默认实现是无条件返回值为true的正常完成。 19.3 Boolean 对象 19.3.1 Boolean 构造器 布尔构造函数: 是内部对象％Boolean％。 是全局对象的Boolean属性的初始值。 在作为构造函数调用时创建并初始化一个新的布尔对象。 当作为函数而不是构造函数调用时执行类型转换。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定的Boolean行为的子类构造函数必须包括对Boolean构造函数的super调用，以使用[[BooleanData]]内部插槽创建和初始化子类实例。 19.3.1.1 Boolean ( value ) 当使用参数值调用Boolean时，将执行以下步骤： 令 b 为 ToBoolean(value). 若 NewTarget 是 undefined, 返回 b. 令 O 为 ? OrdinaryCreateFromConstructor(NewTarget, \"%BooleanPrototype%\", « [[BooleanData]] »). 设置 O.[[BooleanData]] 为 b. 返回 O. 19.3.2 Boolean 构造器属性 布尔构造函数： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 具有以下属性： 19.3.2.1 Boolean.prototype Boolean.prototype的初始值为内部对象％BooleanPrototype％。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.3.3 Boolean 原型对象属性 布尔原型对象： 是内部对象％BooleanPrototype％。 是一个普通的对象。 它本身是一个布尔对象；它具有一个[[BooleanData]]内部插槽，其值为false。 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 抽象操作thisBooleanValue（value）执行以下步骤： 若 Type(value) 是 Boolean, 返回 value. 若 Type(value) 是 Object and value has a [[BooleanData]] internal slot，那么 令 b 为 value.[[BooleanData]]. 断言：Type(b) is Boolean. 返回 b. 抛出 TypeError 异常。 19.3.3.1 Boolean.prototype.constructor Boolean.prototype.constructor的初始值为内部对象％Boolean％。 19.3.3.2 Boolean.prototype.toString ( ) 采取以下步骤： 令 b 为 ? thisBooleanValue(this value). 若 b 是 true, 返回 \"true\"; 否则，返回 \"false\". 19.3.3.3 Boolean.prototype.valueOf ( ) 采取以下步骤： 返回 ? thisBooleanValue(this value). 19.3.4 Boolean 实例属性 布尔实例是从布尔原型对象继承属性的普通对象。布尔型实例具有一个[[BooleanData]]内部插槽。内部插槽[[BooleanData]]是此布尔对象表示的布尔值。 19.4 Symbol 对象 19.4.1 Symbol 构造器 Symbol构造函数： 是内部对象％Symbol％。 是全局对象的Symbol属性的初始值。 作为函数调用时，返回一个新的Symbol值。 不适用于新运算符。 不打算被子类化。 可以用作类定义的extends子句的值，但是对其的super调用将导致例外。 19.4.1.1 Symbol ( [ description ] ) 使用可选参数description调用Symbol时, 采取以下步骤： 若 NewTarget 不是 undefined, 抛出 TypeError 异常。 若 description 是 undefined, 令 descString 为 undefined. 否则，令 descString 为 ? ToString(description). 返回一个新的唯一Symbol值，其[[Description]]值为descString。 19.4.2 Symbol 构造器属性 Symbol构造函数： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 具有以下属性： 19.4.2.1 Symbol.asyncIterator Symbol.asyncIterator的初始值为常见的符号@@asyncIterator（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.2 Symbol.for ( key ) 使用参数键调用Symbol.for时，它将执行以下步骤： 令 stringKey 为 ? ToString(key). 对于GlobalSymbolRegistry列表中的每个元素e，执行 若 SameValue(e.[[Key]], stringKey) 是 true, 返回 e.[[Symbol]]. 断言：GlobalSymbolRegistry当前不包含stringKey的条目。 令 newSymbol 为一个新的唯一Symbol值，其[[Description]]值为stringKey。 追加记录 { [[Key]]: stringKey, [[Symbol]]: newSymbol } 到 GlobalSymbolRegistry 列表。 返回 newSymbol. GlobalSymbolRegistry是一个全局可用的列表。它是所有作用域共享的。在解释执行任何ECMAScript代码之前，它会初始化为一个新的空列表。 GlobalSymbolRegistry的元素是具有表48中定义的结构的记录。 表48：GlobalSymbolRegistry记录字段 字段名 值 用法 [[Key]] String 用于全局标识Symbol的字符串键。 [[Symbol]] Symbol 可以从任何作用域检索的symbol。 19.4.2.3 Symbol.hasInstance Symbol.hasInstance的初始值为常见的符号@@hasInstance（表1）。该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.4 Symbol.isConcatSpreadable Symbol.isConcatSpread的初始值为常见的符号@@isConcatSpread（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.5 Symbol.iterator Symbol.iterator 的初始值为常见的符号 @@iterator（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.6 Symbol.keyFor ( sym ) 当使用参数sym调用Symbol.keyFor时，它将执行以下步骤： 若 Type(sym) 不是 Symbol, 抛出 TypeError 异常。 对于GlobalSymbolRegistry列表中的每个元素e（请参见19.4.2.2），执行 若 SameValue(e.[[Symbol]], sym) 是 true, 返回 e.[[Key]]. 断言：GlobalSymbolRegistry当前不包含sym的条目。 返回 undefined. 19.4.2.7 Symbol.match Symbol.match 的初始值为常见的符号 @@match（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.8 Symbol.prototype The initial value of Symbol.prototype is the intrinsic object %SymbolPrototype%. 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.9 Symbol.replace Symbol.replace 的初始值为常见的符号 @@replace（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.10 Symbol.search Symbol.search 的初始值为常见的符号 @@search（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.11 Symbol.species Symbol.species 的初始值为常见的符号 @@species（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 19.4.2.12 Symbol.split Symbol.split 的初始值为常见的符号 @@split（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 19.4.2.13 Symbol.toPrimitive Symbol.toPrimitive 的初始值为常见的符号 @@toPrimitive（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.14 Symbol.toStringTag Symbol.toStringTag 的初始值为常见的符号 @@toStringTag（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.4.2.15 Symbol.unscopables Symbol.unscopables 的初始值为常见的符号 @@unscopables（表1）。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 19.4.3 Symbol 原型对象属性 Symbol原型对象： 是内部对象％SymbolPrototype％。 是一个普通的对象。 不是Symbol实例，并且没有[[SymbolData]]内部插槽。 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 抽象操作thisSymbolValue（value）执行以下步骤： 若 Type(value) 是 Symbol, 返回 value. 若 Type(value) 是对象和值具有一个[[SymbolData]]内部插槽，那么 令 s 为 value.[[SymbolData]]. 断言：Type(s) 是 Symbol. 返回 s. 抛出 TypeError 异常。 19.4.3.1 Symbol.prototype.constructor Symbol.prototype.constructor的初始值为内部对象％Symbol％。 19.4.3.2 get Symbol.prototype.description Symbol.prototype.description是一个访问器属性，其设置的访问器函数undefined。它的get访问器函数执行以下步骤： 令 s 为 this 值. 令 sym 为 ? thisSymbolValue(s). 返回 sym.[[Description]]. 19.4.3.3 Symbol.prototype.toString ( ) 采取以下步骤： 令 sym 为 ? thisSymbolValue(this value). 返回 SymbolDescriptiveString(sym). 19.4.3.3.1 RS: SymbolDescriptiveString ( sym ) 使用参数sym调用抽象操作SymbolDescriptiveString时, 采取以下步骤： 断言：Type(sym) is Symbol. 令 desc 为 sym's [[Description]] value. 若 desc 是 undefined, 设置 desc 为空字符串 断言：Type(desc) is String. 返回 the string-concatenation of \"Symbol(\", desc, and \")\" 19.4.3.4 Symbol.prototype.valueOf ( ) 采取以下步骤： 返回 ? thisSymbolValue(this value). 19.4.3.5 Symbol.prototype [ @@toPrimitive ] ( hint ) ECMAScript语言操作员调用此函数以将Symbol对象转换为原始值。hint的允许值为“默认”，“数字”和“字符串”。 使用参数hint调用@@toPrimitive方法时, 采取以下步骤： 返回 ? thisSymbolValue(this value) 该函数的name属性的值为“ [Symbol.toPrimitive]”。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 19.4.3.6 Symbol.prototype [ @@toStringTag ] @@toStringTag属性的初始值为字符串值“ Symbol”。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 19.4.4 Symbol 实例属性 符号实例是从Symbol原型对象继承属性的普通对象。符号实例具有一个[[SymbolData]]内部插槽。 [[SymbolData]]内部插槽是此Symbol对象表示的Symbol值。 19.5 Error 对象 当发生运行时错误时，将Error对象的实例作为异常抛出。 Error对象还可以用作用户定义的异常类的基础对象。 19.5.1 The Error 构造器 错误构造函数： 是内部对象％Error％。 是全局对象的Error属性的初始值。 当作为函数而不是构造函数调用时，创建并初始化一个新的Error对象。因此，函数调用Error（…）等效于具有相同参数的对象创建表达式new Error（…）。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定的Error行为的子类构造函数必须包括对Error构造函数的super调用，以使用[[ErrorData]]内部插槽创建和初始化子类实例。 19.5.1.1 Error ( message ) 使用参数消息调用Error函数时, 采取以下步骤： 若 NewTarget 是 undefined, 令 newTarget 为活动函数对象, 否则，令 newTarget 为 NewTarget. 令 O 为 ? OrdinaryCreateFromConstructor(newTarget, \"%ErrorPrototype%\", « [[ErrorData]] »). 若 message 不是 undefined，那么 令 msg 为 ? ToString(message). 令 msgDesc 为 PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. 执行 ! DefinePropertyOrThrow(O, \"message\", msgDesc). 返回 O. 19.5.2 Properties of the Error 构造器属性 错误构造函数： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 具有以下属性： 19.5.2.1 Error.prototype Error.prototype的初始值为内部对象％ErrorPrototype％。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.5.3 Properties of the Error 原型对象属性 错误构造函数： 是内部对象％ErrorPrototype％。 是一个普通的对象。 不是Error实例，并且没有[[ErrorData]]内部插槽。 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 19.5.3.1 Error.prototype.constructor Error.prototype.constructor的初始值为内部对象％Error％。 19.5.3.2 Error.prototype.message Error.prototype.message的初始值为空字符串。 19.5.3.3 Error.prototype.name Error.prototype.name的初始值为“ Error”。 19.5.3.4 Error.prototype.toString ( ) 采取以下步骤： 令 O 为 this 值. 若 Type(O) 不是 Object, 抛出 TypeError 异常。 令 name 为 ? Get(O, \"name\"). 若 name 是 undefined, 设置 name 为 \"Error\"; 否则，设置 name 为 ? ToString(name). 令 msg 为 ? Get(O, \"message\"). 若 msg 是 undefined, 设置 msg 为空字符串，否则设置 msg 为 ? ToString(msg). 若 name 是空字符串 返回 msg. 若 msg 是空字符串 返回 name. 返回 名称 的字符串连接，代码单元0x003A（:），代码单元0x0020（空格）和msg。 19.5.4 Properties of Error 实例属性 错误实例是继承自错误原型对象的属性并具有[[ErrorData]]内部插槽（其值undefined）的普通对象。 [[ErrorData]]的唯一指定用途是将Error和NativeError实例标识为Object.prototype.toString中的Error对象。 19.5.5 本标准值中使用的原生错误类型 当检测到运行时错误时，将引发以下NativeError对象之一的新实例。所有这些对象都共享相同的结构，如19.5.6中所述。 19.5.5.1 EvalError 此规范当前未使用此异常。保留该目的是为了与本规范的先前版本兼容。 19.5.5.2 RangeError 表示不在允许值范围内的值。 19.5.5.3 ReferenceError 表示已检测到无效参考值。 19.5.5.4 SyntaxError 表示已发生解析错误。 19.5.5.5 TypeError 当其他NativeError对象都不是失败原因的适当指示时，TypeError用于指示操作失败。 19.5.5.6 URIError 表示使用一种全局URI处理函数与其定义不兼容。 19.5.6 NativeError 对象结构 当ECMAScript实现检测到运行时错误时，它将引发19.5.5中定义的NativeError对象之一的新实例。这些对象中的每一个都具有以下描述的结构，仅在原型对象的name属性和原型对象的实现定义的消息属性方面有所不同，只是用作构造函数名称的名称而不是NativeError。 对于每个错误对象，应使用19.5.5中的相应错误对象名称替换对定义中对NativeError的引用。 19.5.6.1 NativeError 构造器 每个NativeError构造函数： 当作为函数而不是构造函数调用时，创建并初始化一个新的NativeError对象。将对象作为函数调用等效于将其作为具有相同参数的构造函数调用。因此，函数调用NativeError（...）等效于具有相同参数的对象创建表达式new NativeError（...）。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定的NativeError行为的子类构造函数必须包括对NativeError构造函数的super调用，以使用[[ErrorData]]内部插槽创建和初始化子类实例。 19.5.6.1.1 NativeError ( message ) 使用参数消息调用NativeError函数时, 采取以下步骤： 若 NewTarget 是 undefined, 令 newTarget 为 活动函数对象, 否则，令 newTarget 为 NewTarget. 令 O 为 ? OrdinaryCreateFromConstructor(newTarget, \"%NativeErrorPrototype%\", « [[ErrorData]] »). 若 message 不是 undefined，那么 令 msg 为 ? ToString(message). 令 msgDesc 为 the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. 执行 ! DefinePropertyOrThrow(O, \"message\", msgDesc). 返回 O. 在步骤2中传递的字符串的实际值是“％EvalErrorPrototype％”，“％RangeErrorPrototype％”，“％ReferenceErrorPrototype％”，“％SyntaxErrorPrototype％”，“％TypeErrorPrototype％”或“％URIErrorPrototype％”，即对应于正在定义哪个NativeError构造函数。 19.5.6.2 NativeError 构造器属性 每个NativeError构造函数： 有一个[[Prototype]]内部插槽，其值是内部对象％Error％。 有一个name属性，其值是字符串值“ NativeError”。 具有以下属性： 19.5.6.2.1 NativeError.prototype NativeError.prototype的初始值为NativeError原型对象（19.5.6.3）。每个NativeError 构造函数有一个独特的原型对象。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 19.5.6.3 NativeError 原型对象属性 每个NativeError原型对象： 是一个普通的对象。 不是Error实例，并且没有[[ErrorData]]内部插槽。 有一个[[Prototype]]内部插槽，其值是内部对象％ErrorPrototype％ 19.5.6.3.1 NativeError.prototype.constructor 给定NativeError构造函数的原型构造函数属性的初始值为相应的内部对象％NativeError％（19.5.6.1）。 19.5.6.3.2 NativeError.prototype.message 是内部对象％Object％。 是全局对象的Object属性的初始值。 创建对象构造函数： 19.5.6.3.3 NativeError.prototype.name 给定NativeError构造函数的原型name属性的初始值是String值，该值由构造函数的名称（用于代替NativeError的名称）组成。 19.5.6.4 NativeError 实例属性 NativeError实例是从其NativeError原型对象继承属性并具有[[ErrorData]]内部插槽（其值undefined）的普通对象。 [[ErrorData]]的唯一指定用途是由Object.prototype.toString（19.1.3.6）来标识Error或NativeError实例。 "},"numbers-and-dates.html":{"url":"numbers-and-dates.html","title":"20 数字和日期","keywords":"","body":"20 数字和日期 20.1 Number 对象 20.1.1 Number 构造器 Number构造函数： 是内部对象％Number％。 是全局对象的Number属性的初始值。 在作为构造函数调用时创建并初始化一个新的Number对象。 当作为函数而不是构造函数调用时执行类型转换。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定Number行为的子类构造函数必须包括对Number构造函数的超级调用，以使用[[NumberData]]内部插槽创建和初始化子类实例。 20.1.1.1 Number ( value ) 当使用参数值调用Number时，将执行以下步骤： 若没有参数传递给此函数调用，令 n 为 +0. 否则，令 n 为 ? ToNumber(value). 若 NewTarget 是 undefined，返回 n. 令 O 为 ? OrdinaryCreateFromConstructor(NewTarget, \"%NumberPrototype%\", « [[NumberData]] »). 设置 O.[[NumberData]] 为 n. 返回 O. 20.1.2 Number 构造器属性 Number构造函数： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 具有以下属性： 20.1.2.1 Number.EPSILON Number.EPSILON的值是1与可以表示为Number值的大于1的最小值之间的差，大约是2.2204460492503130808472633361816 x 10^-16。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.2.2 Number.isFinite ( number ) 当使用一个参数number调用Number.isFinite时，将执行以下步骤： 若 Type(number) 不是 Number，返回 false. 若 number 是 NaN, +∞，或 -∞，返回 false. 否则，返回 true 20.1.2.3 Number.isInteger ( number ) 当使用一个参数number调用Number.isInteger时，将执行以下步骤： 若 Type(number) 不是 Number，返回 false. 若 number 是 NaN, +∞，或 -∞，返回 false. 令 integer 为 ! ToInteger(number). 若 integer 不等于 number，返回 false. 否则，返回 true. 20.1.2.4 Number.isNaN ( number ) 当使用一个参数number调用Number.isNaN时，将执行以下步骤： 若 Type(number) 不是 Number，返回 false. 若 number 是 NaN，返回 true. 否则，返回 false. 注：此函数与全局isNaN函数（18.2.3）的不同之处在于，在确定它是否为NaN之前，不会将其参数转换为Number。 20.1.2.5 Number.isSafeInteger ( number ) 当使用一个参数number调用Number.isSafeInteger时，将执行以下步骤： 若 Type(number) 不是 Number，返回 false. 若 number 是 NaN, +∞，或 -∞，返回 false. 令 integer 为 ! ToInteger(number). 若 integer 不等于 number，返回 false. 若 abs(integer) ≤ 253 - 1，返回 true. 否则，返回 false. 20.1.2.6 Number.MAX_SAFE_INTEGER 注：Number.MAX_SAFE_INTEGER的值是最大的整数n，因此n和n +1都可以精确表示为Number值。 Number.MAX_SAFE_INTEGER的值为9007199254740991(2 ^ 53-1)。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.2.7 Number.MAX_VALUE Number.MAX_VALUE的值是Number类型的最大正有限值，大约为1.7976931348623157×10 ^ 308 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.2.8 Number.MIN_SAFE_INTEGER 注：Number.MIN_SAFE_INTEGER的值是最小的整数n，因此n和n-1都可以精确表示为Number值。 Number.MIN_SAFE_INTEGER的值为-9007199254740991(-(2 ^ 53-1))。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.2.9 Number.MIN_VALUE Number.MIN_VALUE的值是Number类型的最小正值，大约为5×10 ^ -324 在IEEE 754-2008双精度二进制表示中，最小的可能值是非规范化的数字。如果实现不支持非规范化的值，则Number.MIN_VALUE的值必须是该实现实际可以表示的最小非零正值。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.2.10 Number.NaN Number.NaN的值为NaN 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.2.11 Number.NEGATIVE_INFINITY Number.NEGATIVE_INFINITY的值为-∞。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.2.12 Number.parseFloat ( string ) Number.parseFloat数据属性的值是与18.2.4中定义的全局对象的parseFloat属性的值相同的内置函数对象。 20.1.2.13 Number.parseInt ( string, radix ) Number.parseInt数据属性的值是相同的内置函数对象，与18.2.5中定义的全局对象的parseInt属性的值相同。 20.1.2.14 Number.POSITIVE_INFINITY Number.POSITIVE_INFINITY的值为+∞。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 20.1.2.15 Number.prototype Number.prototype的初始值为内部对象％NumberPrototype％。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.1.3 Number 原型对象属性 Number原型对象： 是内部对象％NumberPrototype％。 是一个普通的对象。 本身是一个Number对象；它具有一个[[NumberData]]内部插槽，其值为+0。 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 除非另有明确说明，否则下面定义的Number原型对象的方法不是通用的，传递给它们的this值必须是Number值或具有[[NumberData]]内部插槽已初始化为Number的对象值。 抽象操作thisNumberValue(value)执行以下步骤： 若 Type(value) 是 Number，返回 value. 若 Type(value) 是对象和值具有一个[[NumberData]]内部插槽，那么 令 n 为 value.[[NumberData]]. 断言：Type(n) 是 Number. 返回 n. 抛出 TypeError 异常 方法规范中的短语“ this Number value”是指通过调用抽象操作thisNumberValue并将方法调用的this值作为参数传递来返回的结果。 20.1.3.1 Number.prototype.constructor Number.prototype.constructor的初始值为内部对象％Number％ 20.1.3.2 Number.prototype.toExponential ( fractionDigits ) 返回一个包含此Number值的字符串，该值以十进制指数表示，在有效位数的小数点前一位，在有效位数的小数点后一位分数。如果fractionDigits是undefined，则包含必要的有效数字以唯一地指定Number（就像在ToString中一样，只是在这种情况下，Number始终以指数表示法输出）。具体来说，请执行以下步骤： 令 x 为 ? thisNumberValue(this value). 令 f 为 ? ToInteger(fractionDigits). 断言：若 fractionDigits 是 undefined，那么 f is 0. 若 x 是 NaN，返回 the String \"NaN\". 令 s 为空字符串。 若 x 设置 s 为 \"-\". 设置 x 为 -x. 若 x = +∞，那么 returns和“ Infinity”的字符串连接。 若 f 100，抛出 RangeError 异常 若 x = 0，那么 令 m 为由f +1次出现的String值组成的代码单元0x0030(0)。 令 e 为 0. Else x ≠ 0, 若 fractionDigits 不是 undefined，那么 令e和n为整数，使10 ^ f≤n 否则 fractionDigits 是 undefined, 令e，n和f为整数，使得f≥0，10 ^ f≤n 令 m 为由n的十进制表示形式的数字组成的String值（按顺序，没有前导零）。 若 f ≠ 0，那么 令 a 为m的第一个代码单元，令b为m的其余f个代码单元。 设置 m 为a，“.”和b的字符串连接。 若 e = 0，那么 令 c 为 \"+\"。 令 d 为 \"0\"。 否则， 若 e > 0，令 c 为 \"+\". 否则 e ≤ 0, 令 c 为 \"-\". 设置 e 为 -e. 令 d 为由e的十进制表示形式的数字组成的String值（按顺序，没有前导零）。 设置 m 为 m，“ e”，c和d的字符串连接。 returns和m的字符串连接。 注：对于提供比以上规则要求的转换更为准确的实现，建议将以下步骤10.b.i的替代版本用作指导： 令e，n和f为整数，使得10 ^ f≤n 20.1.3.3 Number.prototype.toFixed ( fractionDigits ) 注 1：toFixed返回一个字符串，其中包含此数字值，该数字值以十进制定点表示法表示，小数点后有小数位数。如果fractionDigits是undefined，则假定为0。 执行以下步骤： 令 x 为 ? thisNumberValue(this value). 令 f 为 ? ToInteger(fractionDigits). 断言：若 fractionDigits 是 undefined，那么 f is 0. 若 f 100，抛出 RangeError 异常 若 x 是 NaN，返回 the String \"NaN\". 令 s 为空字符串。 若 x 设置 s 为 \"-\". 设置 x 为 -x. 若 x ≥ 1021，那么 1. 令 m 为 ! ToString(x). 否则 x 令 n 为一个整数，其精确数学值n÷10 ^(f-x)尽可能接近零。如果有两个这样的n，则选择较大的n。 若 n = 0, 令 m 为 字符串 \"0\". 否则，令 m 为由 n 的十进制表示形式的数字组成的String值（按顺序，无前导零）。 若 f ≠ 0，那么 令 k 为 m 的长度 若 k ≤ f，那么 令 z 为由f +1-k个出现的字符串值组成的代码单元0x0030(0)。 设置 m 为 z 和 m 的字符串连接。 设置 k 为 f + 1. 令 a 为 m 的前k-f个代码单元，令b为m的其余f个代码单元。 设置 m 为a，“.”和b的字符串连接。 returns和m的字符串连接。 注 2：对于某些值，toFixed的输出可能比toString更精确，因为toString仅打印足够的有效数字以将数字与相邻数字值区分开。例如， (1000000000000000128).toString() 返回 \"1000000000000000100\", 当(1000000000000000128).toFixed(0) 返回 \"1000000000000000128\". 20.1.3.4 Number.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的Number.prototype.toLocaleString方法。如果ECMAScript实现不包含ECMA-402 API，则使用以下toLocaleString方法的规范。 产生一个String值，该值表示此Number值，该值根据主机环境当前语言环境的约定进行格式化。此函数与实现有关，并且允许但不鼓励使用，因为它返回与toString相同的东西。 此方法的可选参数的含义在ECMA-402规范中定义；不包含ECMA-402支持的实现不得将这些参数位置用于其他任何用途。 20.1.3.5 Number.prototype.toPrecision ( precision ) 返回一个包含此Number值的字符串，该字符串以十进制指数符号表示，并在有效位数的小数点前加一位数字，而精度-在有效位数的小数点之后为1位数，或者以十进制固定表示法（具有精度有效位数）来表示。如果不确定精度，则调用ToString。具体来说，请执行以下步骤： 令 x 为 ? thisNumberValue(this value). 若 precision 是 undefined，返回 ! ToString(x). 令 p 为 ? ToInteger(precision). 若 x 是 NaN，返回字符串 \"NaN\". 令 s 为空字符串。 若 x 设置 s 为代码单元0x002D(-)。 设置 x 为 -x. 若 x = +∞，那么. returns和“ Infinity”的字符串连接。 若 p 100，抛出 RangeError 异常 若 x = 0，那么 令 m 为字符串值，由p个出现的代码单元0x0030(0)组成。 令 e 为 0. 否则 x ≠ 0, 令e和n为整数，使10 ^(p-1)≤n 令 m 为由n的十进制表示形式的数字组成的String值（按顺序，没有前导零）。 若 e 断言：e ≠ 0. 若 p ≠ 1，那么 令 a 为 m 的第一个代码单元，令b为m的其余p-1个代码单元。 设置 m 为a，“.”和b的字符串连接。 若 e > 0，那么 令 c 为代码单元0x002B(+)。 否则 e 令 c 为代码单元0x002D(-)。 设置 e 为 -e. 令 d 为由 e 的十进制表示形式的数字组成的String值（按顺序，没有前导零）。 returns，m，代码单元0x0065（拉丁文小写字母E），c和d的字符串连接。 若 e = p - 1，返回 s 和 m 的字符串连接。 若 e ≥ 0，那么 设置 m 为 m 的前e + 1个代码单元，代码单元0x002E(FULL STOP)和m的其余p-(e +1)个代码单元的字符串连接。 Else e 设置 m 为代码单元0x0030(0)的字符串连接，代码单元0x002E(.)，-(e +1)代码单元0x0030(0)的出现以及字符串m。 返回 s 和 m 的字符串连接。 20.1.3.6 Number.prototype.toString ( [ radix ] ) 注：可选的基数应该是2到36之间的整数值。如果基数不存在或为undefined，则使用数字10作为基数值。 执行以下步骤： 令 x 为 ? thisNumberValue(this value). 若 radix 不存在，令 radixNumber 为 10. Else 若 radix 是 undefined，令 radixNumber 为 10. 否则，令 radixNumber 为 ? ToInteger(radix). 若 radixNumber 36，抛出 RangeError 异常 若 radixNumber = 10，返回 ! ToString(x). 返回使用radixNumber指定的基数表示此数字值的字符串。字母a-z用于值为10到35的数字。精确的算法依赖于实现，但是算法应该是7.1.12.1中规定的泛化。 toString函数不是通用的；如果该值不是数字或数字对象，则抛出一个TypeError异常。因此，它不能作为一种方法转移到其他类型的对象上。 toString方法的“length”属性是1 20.1.3.7 Number.prototype.valueOf ( ) 返回 ? thisNumberValue(this value). 20.1.4 Number 实例属性 Number实例是从Number prototype对象继承属性的普通对象。Number实例也有一个[[NumberData]]内部槽。内部槽是这个Number对象表示的数值。 20.2 Math 对象 Math对象： 是内部对象％Math％。 是全局对象的Math属性的初始值。 是一个普通的对象。 有一个[[Prototype]]内部插槽，其值是固有对象％ObjectPrototype％。 不是函数对象。 没有[[Construct]]内部方法；它不能与new运算符一起用作构造函数。 没有[[Call]]内部方法；它不能作为函数调用。 注：在本规范中，短语“ x的数字值”具有6.1.6中定义的技术含义。 20.2.1 Math 对象值属性 20.2.1.1 Math.E e的数字值，自然对数的底数，大约为2.7182818284590452354。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.2.1.2 Math.LN10 自然对数10的Number值，大约为2.302585092994046 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.2.1.3 Math.LN2 自然对数2的Number值，大约为0.6931471805599453。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 20.2.1.4 Math.LOG10E e的以10为底的对数的Number值，自然对数的底；该值约为0.4342944819032518。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 注：Math.LOG10E的值大约是Math.LN10的值的倒数。 20.2.1.5 Math.LOG2E e的以2为底的对数的Number值，自然对数的底；该值约为1.4426950408889634。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 注：Math.LOG2E的值大约是Math.LN2的值的倒数。 20.2.1.6 Math.PI 为π的数值，一个圆其直径，这大约是3.1415926535897932的周长之比。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.2.1.7 Math.SQRT1_2 平方根的Number的数值，大约为0.7071067811865476。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 注：Math.SQRT1_2的值大约是Math.SQRT2的值的倒数。 20.2.1.8 Math.SQRT2 2的平方根的Number值，大约为1.4142135623730951。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.2.1.9 Math [ @@toStringTag ] @@toStringTag属性的初始值为字符串值“ Math”。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true } 20.2.2 Math 对象函数属性 以下每个Math对象函数将ToNumber抽象操作应用于其每个参数（如果有多个，则以从左到右的顺序）。如果ToNumber返回一个突然的完成，该完成记录将立即返回。否则，该函数将对所得的Number值进行计算。每个函数返回的值是一个数字。 在下面的功能描述中，符号NaN，-0，+ 0，-∞和+∞表示6.1.6中描述的Number值。 注：函数acos，acosh，asin，asinh，atan，atanh，atan2，cbrt，cos，cosh，exp，expm1，hypot，log，log1p，log2，log10，pow，pow，sin，sinh，sqrt， tan和tanh在此处未明确指定，只是要求某些表示感兴趣边界情况的参数值具有特定结果。对于其他自变量值，这些函数旨在计算对熟悉的数学函数的结果的近似值，但是在选择近似算法时允许有一定的自由度。总体意图是，实现者应该能够在给定的硬件平台上为ECMAScript使用相同的数学库，该平台可供C程序员使用。 尽管算法的选择留给实现，但建议（但未由该标准指定）实现使用fdlibm中包含的IEEE 754-2008算法的近似算法，fdlibm是Sun Microsystems(http：/ /www.netlib.org/fdlibm)。 20.2.2.1 Math.abs ( x ) 返回x的绝对值；结果的大小与x相同，但具有正号。 若 x 是 NaN，结果为 NaN. 若 x 是 -0，结果为 +0. 若 x 是 -∞，结果为 +∞. 20.2.2.2 Math.acos ( x ) 返回x的反余弦的与实现相关的近似值。结果以弧度表示，范围为+0到+π。 若 x 是 NaN，结果为 NaN. 若 x 是 greater than 1，结果为 NaN. 若 x 是 less than -1，结果为 NaN. 若 x 是 exactly 1，结果为 +0. 20.2.2.3 Math.acosh ( x ) 返回x的反双曲余弦的依赖于实现的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 less than 1，结果为 NaN. 若 x 是 1，结果为 +0. 若 x 是 +∞，结果为 +∞. 20.2.2.4 Math.asin ( x ) 返回x的反正弦值的与实现相关的近似值。结果以弧度表示，范围为-π/ 2到+π/ 2。 若 x 是 NaN，结果为 NaN. 若 x 是 greater than 1，结果为 NaN. 若 x 是 less than -1，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 20.2.2.5 Math.asinh ( x ) 返回x的反双曲正弦的与实现相关的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -∞. 20.2.2.6 Math.atan ( x ) 返回x的反正切的与实现有关的近似值。结果以弧度表示，范围为 -π/ 2到 +π/ 2。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为与实现相关的近似值 +π/2。 若 x 是 -∞，结果为与实现有关的近似值 -π/ 2。 20.2.2.7 Math.atanh ( x ) 返回x的反双曲正切的依赖于实现的近似 若 x 是 NaN，结果为 NaN. 若 x 是 less than -1，结果为 NaN. 若 x 是 greater than 1，结果为 NaN. 若 x 是 -1，结果为 -∞. 若 x 是 +1，结果为 +∞. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 20.2.2.8 Math.atan2 ( y, x ) 返回参数y和x的商y / x的反正切值的与实现有关的近似值，其中y和x的符号用于确定结果的象限。请注意，对于两个参数的反正切函数而言，有意和传统的做法是将名为y的参数设为第一个，将名为x的参数设为第二个。结果以弧度表示，范围为-π到+π。 若 either x or y 是 NaN，结果为 NaN. 若 y > 0 and x 是 +0，结果为与实现相关的近似值 +π/2。 若 y > 0 and x 是 -0，结果为与实现相关的近似值 +π / 2. 若 y 是 +0 and x > 0，结果为 +0. 若 y 是 +0 and x is +0，结果为 +0. 若 y 是 +0 and x is -0，结果为与实现相关的近似值 +π. 若 y 是 +0 and x 若 y 是 -0 and x > 0，结果为 -0. 若 y 是 -0 and x is +0，结果为 -0. 若 y 是 -0 and x is -0，结果为与实现相关的近似值-π. 若 y 是 -0 and x 若 y 若 y 若 y > 0 and y is finite and x 是 +∞，结果为 +0. 若 y > 0 and y is finite and x 是 -∞，结果为与实现相关的近似值+π. 若 y 若 y 若 y 是 +∞ and x is finite，结果为与实现相关的近似值 +π / 2. 若 y 是 -∞ and x is finite，结果为与实现相关的近似值 -π / 2. 若 y 是 +∞ and x is +∞，结果为与实现相关的近似值 +π / 4. 若 y 是 +∞ and x is -∞，结果为与实现相关的近似值 +3π / 4. 若 y 是 -∞ and x is +∞，结果为与实现相关的近似值 -π / 4. 若 y 是 -∞ and x is -∞，结果为与实现相关的近似值 -3π / 4. 20.2.2.9 Math.cbrt ( x ) returns an implementation-dependent approximation to the cube root of x. 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -∞. 20.2.2.10 Math.ceil ( x ) 返回不小于x且等于数学整数的最小（最接近-∞）数值。如果x已经是整数，则结果为x。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -∞. 若 x 是 小于 0 大于 -1，结果为 -0. Math.ceil(x)的值与-Math.floor(-x)的值相同。 20.2.2.11 Math.clz32 ( x ) 当使用一个参数x调用Math.clz32时，将执行以下步骤： 令 n 为 ? ToUint32(x). 令 p 为 n 的32位二进制表示形式中前导零位的数量。 返回 p. 注：如果 n 为0，则 p 将为32。如果32位二进制编码n的最高有效位为1，则 p 将为0。 20.2.2.12 Math.cos ( x ) 返回x的余弦的与实现相关的近似值。该参数以弧度表示 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 1. 若 x 是 -0，结果为 1. 若 x 是 +∞，结果为 NaN. 若 x 是 -∞，结果为 NaN 20.2.2.13 Math.cosh ( x ) 返回x的双曲余弦的与实现相关的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 1. 若 x 是 -0，结果为 1. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 +∞. 注：cosh(x)的值等于(exp(x)+ exp(-x))/ 2。 20.2.2.14 Math.exp ( x ) 返回x的指数函数（将e提升为x的幂，其中e是自然对数的底）的实现依赖近似。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 1. 若 x 是 -0，结果为 1. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 +0. 20.2.2.15 Math.expm1 ( x ) 返回依赖于实现的近似值，以从x的指数函数中减去1（e升至x的幂，其中e是自然对数的底）。即使x的值接近于0，也以准确的方式计算结果。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -1. 20.2.2.16 Math.floor ( x ) 返回不大于x并且等于数学整数的最大（最接近+∞）数值。如果x已经是整数，则结果为x。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -∞. 若 x 是 greater than 0 but less than 1，结果为 +0. 注：Math.floor(x)的值与-Math.ceil(-x)的值相同。 20.2.2.17 Math.fround ( x ) 当使用参数x调用Math.fround时，将执行以下步骤： 若 x 是 NaN，返回 NaN. 若 x 是 one of +0, -0, +∞, -∞，返回 x. 令 x32 为使用roundTiesToEven将x转换为IEEE 754-2008 binary32格式的值的结果。 令 x64 为使用roundTiesToEven将x转换为IEEE 754-2008 binary32格式的值的结果。 返回与x64对应的ECMAScript Number值。 20.2.2.18 Math.hypot ( value1, value2, ...values ) Math.hypot返回其参数的平方和的平方根的依赖于实现的近似值。 若没有传递参数，结果为 +0. 若任何参数是 +∞，结果为 +∞. 若任何参数是 -∞，结果为 +∞. 若没有参数为+∞或-∞，并且任何参数为NaN，则结果为NaN。 若所有参数均为+0或-0，结果为 +0. 注：实现时应注意避免因使用两个或多个参数调用此函数，而在简单的实现中容易发生的上溢和下溢导致精度损失。 20.2.2.19 Math.imul ( x, y ) 当使用参数 x 和 y 调用Math.imul时，将执行以下步骤： 令 a 为 ? ToUint32(x). 令 b 为 ? ToUint32(y). 令 product 为 (a × b) modulo 2^32. 若 product ≥ 2^31，返回 product - 2^32; 否则，返回 product. 20.2.2.20 Math.log ( x ) 返回 x 的自然对数的依赖于实现的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 less than 0，结果为 NaN. 若 x 是 +0 or -0，结果为 -∞. 若 x 是 1，结果为 +0. 若 x 是 +∞，结果为 +∞. 20.2.2.21 Math.log1p ( x ) 返回与实现有关的近似值1 + x的自然对数。即使x的值接近于零，也以准确的方式计算结果。 若 x 是 NaN，结果为 NaN. 若 x 是 less than -1，结果为 NaN. 若 x 是 -1，结果为 -∞. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 20.2.2.22 Math.log10 ( x ) 返回x的以10为底的对数的依赖于实现的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 less than 0，结果为 NaN. 若 x 是 +0，结果为 -∞. 若 x 是 -0，结果为 -∞. 若 x 是 1，结果为 +0. 若 x 是 +∞，结果为 +∞. 20.2.2.23 Math.log2 ( x ) 返回 x 的 2 为底对数的依赖于实现的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 less than 0，结果为 NaN. 若 x 是 +0，结果为 -∞. 若 x 是 -0，结果为 -∞. 若 x 是 1，结果为 +0. 若 x 是 +∞，结果为 +∞. 20.2.2.24 Math.max ( value1, value2, ...values ) 给定零个或多个参数，在每个参数上调用 ToNumber 并返回最大结果值 若没有给出参数，结果为 -∞. 若任何值是 NaN，结果为 NaN. 使用抽象关系比较算法对值进行比较以确定最大值，只不过认为 +0 大于 -0。 20.2.2.25 Math.min ( value1, value2, ...values ) 给定零个或多个参数，在每个参数上调用 ToNumber 并返回结果值的最小值。 若没有给出参数，结果为 +∞. 若任何值是 NaN，结果为 NaN. 使用抽象关系比较算法对确定最小值的值进行比较，只不过认为 +0 大于 -0。 20.2.2.26 Math.pow ( base, exponent ) 返回应用定义在12.6.4的 base 和 exponent 的 ** 运算结果。 20.2.2.27 Math.random ( ) 返回一个带正号的 Number 值，大于或等于 0，但小于 1，使用与实现相关的算法或策略随机或伪随机选择，该范围内分布大致一致。此函数不采用任何参数。 为不同领域创建的每个 Math.random 函数都必须生成与连续调用不同的值序列。 20.2.2.28 Math.round ( x ) 返回最接近 x 且等于数学整数的数字值。如果两个整数值同样接近 x，则结果为更接近 + 的数字值。如果 x 已经是整数，则结果为 x。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -∞. 若 x 是大于 0 但小于 0.5，结果为 +0. 若 x 是小于 0 但大于或等于 -0.5，结果为 -0. NOTE 1 Math.round(3.5) 返回 4, 但是 Math.round(-3.5) 返回 -3. NOTE 2 Math.round (x) 的值并不总是与 Math.floor(x + 0.5) 的值相同。当 x 为 -0 或小于 0 但大于或等于 -0.5 时，Math.round(x) 返回 -0，但 Math.floor(x + 0.5) 返回 +0。Math.round(x) 也可能不同于 Math.floor(x + 0.5) 的值，因为计算 x + 0.5 时存在内部舍入。 20.2.2.29 Math.sign ( x ) 返回 x 的符号，指示 x 是正数、负数还是零。 若 x 是 NaN，结果为 NaN. 若 x 是 -0，结果为 -0. 若 x 是 +0，结果为 +0. 若 x 是负数且不为 -0，结果为 -1. 若 x 是正数且不为 +0，结果为 +1. 20.2.2.30 Math.sin ( x ) 返回x的正弦依赖的近似值。该参数以弧度表示。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞ or -∞，结果为 NaN. 20.2.2.31 Math.sinh ( x ) 返回 x 的双曲正弦的与实现有关的近似。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -∞. 注：sinh(x)的值与(exp(x)-exp(-x))/ 2相同。 20.2.2.32 Math.sqrt ( x ) 返回 x 的平方根的依赖于实现的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 less than 0，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +∞. 20.2.2.33 Math.tan ( x ) 返回 x 的切线的与实现相关的近似值。该参数以弧度表示。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞ or -∞，结果为 NaN. 20.2.2.34 Math.tanh ( x ) 返回 x 的双曲正切的与实现有关的近似值。 若 x 是 NaN，结果为 NaN. 若 x 是 +0，结果为 +0. 若 x 是 -0，结果为 -0. 若 x 是 +∞，结果为 +1. 若 x 是 -∞，结果为 -1. 注：tanh(x) 的值与(exp(x) - exp(-x))/(exp(x) + exp(-x))相同. 20.2.2.35 Math.trunc ( x ) 返回数字x的整数部分，除去所有小数位数。如果x已经是整数，则结果为x。 若 x 是 NaN，结果为 NaN. 若 x 是 -0, 结果为 -0.If x is +0，结果为 +0. 若 x 是 +∞，结果为 +∞. 若 x 是 -∞，结果为 -∞. 若 x 是大于 0 但小于 1，结果为 +0. 若 x 是小于 0 但大于 -1，结果为 -0. 20.3 Date 对象 20.3.1 Date 对象的概述和抽象操作定义 以下函数是对时间值（在20.3.1.1中定义）进行操作的抽象操作。请注意，在每种情况下，如果这些函数之一的任何参数为NaN，则结果将为NaN。 20.3.1.1 时间值和时间范围 Date对象包含一个Number，代表毫秒级的时间瞬间。这样的数字称为时间值。时间值也可以是NaN，表示Date对象不代表特定的时间点。 从1970年1月1日UTC午夜起以毫秒为单位，以ECMAScript度量时间。 ECMAScript中的时间不遵守leap秒；他们被忽略了。时间计算假设每天精确地包含60×60×24×1000 = 86,400,000毫秒，以与每天精确地包含86,400秒的POSIX规范保持一致。 一个数字可以精确表示从-9,007,199,254,740,992到9,007,199,254,740,992（20.1.2.8和20.1.2.6）的所有整数。与1970年1月1日UTC开始的午夜相比，时间值支持的范围较小，范围从-100,000,000天到100,000,000天。相对于UTC 1970年1月1日开始的午夜，这将产生确切的支持时间值范围-8,640,000,000,000,000至8,640,000,000,000,000毫秒。 UTC 1970年1月1日开始的午夜的确切时刻由时间值+0表示 注：公历的400年周期包含97个闰年。根据公历，这每年平均产生365.2425天，或每年平均31,556,952,000毫秒。 ECMAScript对所有时间计算均采用通用的公历。 如本节所述，相对于1970年1月1日UTC午夜开始，Number可以精确表示的最大年份范围为-285,426到285,426年。 如本节所述，相对于UTC 1970年1月1日开始的午夜，时间值可以表示的最大年份范围约为-273,790至273,790年。 20.3.1.2 天数和一天的时间 给定的时间值 t 属于日期 ​ Day(t) = floor(t / msPerDay) 每天的毫秒数是 ​ msPerDay = 86400000 其余时间称为一天中的时间： ​ TimeWithinDay(t) = t modulo msPerDay 20.3.1.3 年数 ECMAScript使用冗长的格里高利历将日期编号映射为年份编号，并确定该年份中的月份和日期。在此日历中，leap年恰好是（可被4整除）和（（不可被100整除）或（可被400整除））的年份。因此，第y年的天数定义为 ​ DaysInYear(y) ​ = 365 if (y modulo 4) ≠ 0 ​ = 366 if (y modulo 4) = 0 and (y modulo 100) ≠ 0 ​ = 365 if (y modulo 100) = 0 and (y modulo 400) ≠ 0 ​ = 366 if (y modulo 400) = 0 所有非闰年都有365天，每个月都有天数，闰年在2月多出一天。y年第一天的日期由: ​ DayFromYear(y) = 365 × (y - 1970) + floor((y - 1969) / 4) - floor((y - 1901) / 100) + floor((y - 1601) / 400) 年初的时间值为: ​ TimeFromYear(y) = msPerDay × DayFromYear(y) 时间值通过以下方式确定一年: ​ YearFromTime(t) = the largest integer y (closest to positive infinity) such that TimeFromYear(y) ≤ t 闰年的函数为1，否则为0: ​ InLeapYear(t) ​ = 0 if DaysInYear(YearFromTime(t)) = 365 ​ = 1 if DaysInYear(YearFromTime(t)) = 366 20.3.1.4 月数 月份由0到11(包括11)范围内的整数标识。将一个时间值t映射为一个月号的MonthFromTime(t)定义为: ​ MonthFromTime(t) ​ = 0 if 0 ≤ DayWithinYear(t) 在 ​ DayWithinYear(t) = Day(t) - DayFromYear(YearFromTime(t)) 月份值为0表示一月； 1表示2月； 2表示3月； 3表示四月； 4表示五月； 5表示6月； 6表示7月； 7表示8月； 8表示9月； 9表示十月； 10表示11月；和11表示12月。请注意，MonthFromTime（0）= 0，对应于1970年1月1日，星期四。 20.3.1.5 日期数 日期编号由范围 1 到 31 中的整数标识。从时间值 t 到日期编号的映射 DateFromTime(t) 由以下定义： ​ DateFromTime(t) ​ = DayWithinYear(t) + 1 if MonthFromTime(t) = 0 ​ = DayWithinYear(t) - 30 if MonthFromTime(t) = 1 ​ = DayWithinYear(t) - 58 - InLeapYear(t) if MonthFromTime(t) = 2 ​ = DayWithinYear(t) - 89 - InLeapYear(t) if MonthFromTime(t) = 3 ​ = DayWithinYear(t) - 119 - InLeapYear(t) if MonthFromTime(t) = 4 ​ = DayWithinYear(t) - 150 - InLeapYear(t) if MonthFromTime(t) = 5 ​ = DayWithinYear(t) - 180 - InLeapYear(t) if MonthFromTime(t) = 6 ​ = DayWithinYear(t) - 211 - InLeapYear(t) if MonthFromTime(t) = 7 ​ = DayWithinYear(t) - 242 - InLeapYear(t) if MonthFromTime(t) = 8 ​ = DayWithinYear(t) - 272 - InLeapYear(t) if MonthFromTime(t) = 9 ​ = DayWithinYear(t) - 303 - InLeapYear(t) if MonthFromTime(t) = 10 ​ = DayWithinYear(t) - 333 - InLeapYear(t) if MonthFromTime(t) = 11 20.3.1.6 周数 特定时间值 t 的个工作日定义为 ​ WeekDay(t) = (Day(t) + 4) modulo 7 工作日的值 0 表示星期日；1 表示星期一；2 表示星期二；3 表示星期三；4 表示星期四；5 表示星期五；6 表示星期六。请注意，WeekDay（0）= 4，对应于 1970 年 1 月 1 日星期四。 20.3.1.7 LocalTZA ( t, isUTC ) LocalTZA（t，isUTC）是一种实现定义的算法，必须返回一个表示毫秒的数字，该数字适合加到时间值上。应该使用以下三段中指定的方式使用当地的有关标准时间和夏令时的政治规则来确定结果。 当 isUTC 为 true 时，LocalTZA（t，true） 应返回本地时区的偏移量，以时间值 t （UTC） 表示的时间以毫秒为单位。当结果添加到 t （UTC） 时，应生成本地时间。当 isUTC 为 true 时，LocalTZA（t，true） 应返回本地时区的偏移量，以时间值 t （UTC） 表示的时间以毫秒为单位。当结果添加到 t （UTC） 时，应生成本地时间。 当 isUTC 为 false 时，LocalTZA（t，false）应返回本地时区的偏移量，以本地时间以毫秒为单位，以时间值 t 本地 = t 表示。当从本地时间 t 本地减去结果时，应生成相应的 UTC。 当t local表示本地时间在负时区转换时重复多次（例如，夏时制结束或由于时区规则更改而导致时区调整减少）或在正时区转换时跳过本地时间（例如，当夏令时开始或由于时区规则更改而增加时区调整时），必须在转换前用时区调整来解释本地时间。 如果实现不支持上述转换，或者在实现内没有时间t的政治规则，则结果必须为0。 注：建议实现使用IANA时区数据库 https://www.iana.org/time-zones/ 的时区信息。 2017年11月5日在美国/纽约，上午1:30重复了两次（倒退），但必须将其解释为UTC-04 AM 1:30，而不是UTC-05 AM 30。 LocalTZA（TimeClip（MakeDate（MakeDay（2017，10，5），MakeTime（1，30，0，0））），false）为-4×msPerHour。 2017年3月12日上午2:30在美国/纽约州不存在，但必须将其解释为UTC-05 2:30 AM（相当于UTC-04 AM 3:30）。 LocalTZA（TimeClip（MakeDate（MakeDay（2017，2，12），MakeTime（2，30，0，0））），false）是-5×msPerHour。 20.3.1.8 LocalTime ( t ) 参数为t的抽象操作LocalTime通过执行以下步骤将t从UTC转换为本地时间： 返回 t + LocalTZA(t, true). 注：当重复次数较多时（例如，夏令时结束或时区调整减少），两个不同的时间值（t（UTC））在负时区转换时转换为相同的本地时间t local。 20.3.1.9 UTC ( t ) 参数为t的抽象运算UTC将t从本地时间转换为UTC。它执行以下步骤： 返回 t - LocalTZA(t, false). 注：UTC（LocalTime（t））不一定总是等于t。 LocalTime（UTC（t local））也不一定总是等于t local。 20.3.1.10 小时，分钟，秒和毫秒 以下抽象操作在分解时间值时很有用： ​ HourFromTime(t) = floor(t / msPerHour) modulo HoursPerDay ​ MinFromTime(t) = floor(t / msPerMinute) modulo MinutesPerHour ​ SecFromTime(t) = floor(t / msPerSecond) modulo SecondsPerMinute ​ msFromTime(t) = t modulo msPerSecond 此处 ​ HoursPerDay = 24 ​ MinutesPerHour = 60 ​ SecondsPerMinute = 60 ​ msPerSecond = 1000 ​ msPerMinute = 60000 = msPerSecond × SecondsPerMinute ​ msPerHour = 3600000 = msPerMinute × MinutesPerHour 20.3.1.11 MakeTime ( hour, min, sec, ms ) 抽象操作MakeTime根据其四个参数计算毫秒数，这些参数必须是ECMAScript Number值。该运算符的功能如下： 若 hour 不是有限或 min 不是有限的，或者 sec 不是有限的，或者 ms 不是有限的，返回 NaN. 令 h 为 ! ToInteger(hour). 令 m 为 ! ToInteger(min). 令 s 为 ! ToInteger(sec). 令 milli 为 ! ToInteger(ms). 令 t 为 h msPerHour + m msPerMinute + s msPerSecond + milli, 根据IEEE 754-2008规则执行算术(也就是说，就像使用ECMAScript运算符和+). 返回 t. 20.3.1.12 MakeDay ( year, month, date ) 抽象操作MakeDay通过其三个参数（必须为ECMAScript Number值）来计算天数。该运算符的功能如下： 若 year 不是有限或 month 不是有限的或 date 不是有限的，返回 NaN. 令 y 为 ! ToInteger(year). 令 m 为 ! ToInteger(month). 令 dt 为 ! ToInteger(date). 令 ym 为 y + floor(m / 12). 令 mn 为 m modulo 12. 找到一个值t使得 YearFromTime(t) 是 ym，MonthFromTime(t) 是 mn，DateFromTime(t) 是 1; 但是如果这不可能（因为某些参数超出范围），返回 NaN. 返回 Day(t) + dt - 1. 20.3.1.13 MakeDate ( day, time ) 抽象操作MakeDate根据其两个参数计算毫秒数，该参数必须为ECMAScript Number值。该运算符的功能如下： 若 day 不是有限的，或 time 不是有限的，返回 NaN. 返回 day × msPerDay + time. 20.3.1.14 TimeClip ( time ) 抽象操作TimeClip根据其参数计算毫秒数，该参数必须为ECMAScript Number值。该运算符的功能如下： 若 time 不是无限，返回 NaN. 若 abs(time) > 8.64 × 1015，返回 NaN. 令 clippedTime 为 ! ToInteger(time). 若 clippedTime 是 -0，设置 clippedTime 为 +0. 返回 clippedTime. 注：步骤4的要点是允许实现选择时间值的内部表示形式，例如，以64位有符号整数或64位浮点值的形式表示。根据实现的不同，此内部表示形式可能会也可能不会区分-0和+0。 20.3.1.15 日期时间字符串格式 ECMAScript基于简化的ISO 8601日历日期扩展格式，为日期时间定义了字符串交换格式。格式如下：YYYY-MM-DDTHH:mm:ss.sssZ 字段如下： YYYY 是公历中从0000到9999年的十进制数字。 - \"-\"（连字符）在字符串中实际出现两次。 MM 是一年中从01（一月）到12（十二月）的月份。 DD 是从01到31的月份。 T \"T\" 实际出现在字符串中，以指示时间元素的开始。 HH 是自午夜以来经过的完整小时数，从00到24的两位十进制数字。 : \":\"（冒号）在字符串中实际出现两次。 mm 是从小时开始到现在的完整分钟数，从00到59的两位十进制数字。 ss 是从分钟开始算起的完整秒数，从00到59的两位十进制数字。 . \".\"（点）字面上出现在字符串中。 sss 是从秒的开始算起的完整毫秒数，为三个十进制数字。 Z 是指定为\"Z\"（对于UTC）或\"+\"或\"-\"后跟时间表达式HH:mm的时区偏移量 此格式包括仅日期形式： YYYY YYYY-MM YYYY-MM-DD 它还包括“日期时间”格式，该格式由上述仅日期格式之一构成，后跟以下时间格式之一，并附加了可选的时区偏移量： THH:mm THH:mm:ss THH:mm:ss.sss 所有数字都必须以10为底。如果缺少MM或DD字段，则将“ 01”用作值。如果HH，mm或ss字段不存在，则将“ 00”用作值，而将sss字段不存在的值设为“ 000”。如果没有时区偏移，则仅日期形式将被解释为UTC时间，而日期时间形式将被解释为本地时间。 包含超出范围或不符合要求的字段的字符串不是此格式的有效实例。 注1：由于每天都是从午夜开始和结束，所以可以使用两种表示法 00:00 和 24:00 来区分可以与一个日期关联的两个午夜。这意味着以下两个符号指的是完全相同的时间点：1995-02-04T24:00和1995-02-05T00:00。后一种形式的这种解释为“日历日结束”与ISO 8601一致，即使该规范保留了它来描述时间间隔，也不允许在单个时间点表示中使用它。 注2：尚无国际标准规定民用时区（如CET，EST等）的缩写，有时甚至在两个截然不同的时区使用相同的缩写。因此，ISO 8601和此格式均指定时区偏移量的数字表示。 20.3.1.15.1 年扩展 从1970年1月1日（20.3.1.1）开始，向前或向后覆盖大约273,790年的全部时间值范围，则需要表示0之前或9999之后的年份。ISO8601允许扩展年份表示，但前提是必须与合作伙伴达成共识信息交流。在简化的ECMAScript格式中，这种扩展的年份表示形式应为6位数字，并始终以+或-开头。 0年被认为是正数，因此以+号开头。与Date Time字符串格式匹配的字符串，如果扩展的年份表示超出时间值范围的时间，则Date.parse将其视为无法识别，并导致该函数返回NaN而不退回到实现特定的行为或启发式方法 注：带有扩展年份的日期时间值示例： -271821-04-20T00:00:00Z 271822 B.C. -000001-01-01T00:00:00Z 2 B.C. +000000-01-01T00:00:00Z 1 B.C. +000001-01-01T00:00:00Z 1 A.D. +001970-01-01T00:00:00Z 1970 A.D. +002009-12-15T00:00:00Z 2009 A.D. +275760-09-13T00:00:00Z 275760 A.D. 20.3.2 Date 构造器 Date构造函数： 是内部对象％Date％。 是全局对象的Date属性的初始值。 在作为构造函数调用时创建并初始化一个新的Date对象。 当作为函数而不是构造函数调用时，返回表示当前时间（UTC）的字符串。 是一个函数，其行为根据其参数的数量和类型而重载。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定的Date行为的子类构造函数必须包括对Date构造函数的超级调用，以使用[[DateValue]]内部插槽创建和初始化子类实例。 具有 \"length\" 属性，其值为7。 20.3.2.1 Date ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ) 仅当使用至少两个参数调用Date构造函数时，此描述才适用。 调用Date函数时，将执行以下步骤： 令 numberOfArgs 为传递给此函数调用的参数数量。 断言：numberOfArgs ≥ 2. 若 NewTarget 是 undefined，那么 令 now 为Number，它是标识当前时间的时间值（UTC）。 返回 ToDateString(now). 否则， 令 y 为 ? ToNumber(year). 令 m 为 ? ToNumber(month). 若 date 存在，令 dt 为 ? ToNumber(date); 否则，令 dt 为 1. 若 hours 存在，令 h 为 ? ToNumber(hours); 否则，令 h 为 0. 若 minutes 存在，令 min 为 ? ToNumber(minutes); 否则，令 min 为 0. 若 seconds 存在，令 s 为 ? ToNumber(seconds); 否则，令 s 为 0. 若 ms 存在，令 milli 为 ? ToNumber(ms); 否则，令 milli 为 0. 若 y 是 NaN，令 yr 为 NaN. 否则， 令 yi 为 ! ToInteger(y). 若 0 ≤ yi ≤ 99, 令 yr 为 1900 + yi; 除此之外，令 yr 为 y. 令 finalDate 为 MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)). 令 O 为 ? OrdinaryCreateFromConstructor(NewTarget, \"%DatePrototype%\", « [[DateValue]] »). 设置 O.[[DateValue]] 为 TimeClip(UTC(finalDate)). 返回 O. 20.3.2.2 Date ( value ) 仅当使用仅一个参数调用Date构造函数时，此描述才适用 调用Date函数时，将执行以下步骤： 令 numberOfArgs 为传递给此函数调用的参数数量。 断言：numberOfArgs = 1. 若 NewTarget 是 undefined，那么 令 now 为Number，它是标识当前时间的时间值（UTC）。 返回 ToDateString(now). 否则， 若 Type(value) 是对象，并且value具有一个[[DateValue]]内部插槽，那么 令 tv 为 thisTimeValue(value). 否则， 令 v 为 ? ToPrimitive(value). 若 Type(v) 是 String，那么 断言：下一步永远不会返回突然完成，因为Type（v）是String。 令 tv 为 将v解析为日期的结果，与解析方法（20.3.3.2）完全相同。 否则， 令 tv 为 ? ToNumber(v). 令 O 为 ? OrdinaryCreateFromConstructor(NewTarget, \"%DatePrototype%\", « [[DateValue]] »). 设置 O.[[DateValue]] 为 TimeClip(tv). 返回 O. 20.3.2.3 Date ( ) 仅当不带参数调用Date构造函数时，此描述才适用。 调用Date函数时，将执行以下步骤： 令 numberOfArgs 为传递给此函数调用的参数数量。 断言：numberOfArgs = 0. 若 NewTarget 是 undefined，那么 令 now 为Number，它是标识当前时间的时间值（UTC）。 返回 ToDateString(now). 否则， 令 O 为 ? OrdinaryCreateFromConstructor(NewTarget, \"%DatePrototype%\", « [[DateValue]] »). 设置 O.[[DateValue]] 为标识当前时间的时间值（UTC）。 返回 O. 20.3.3 Date 构造器属性 Date构造函数： 有一个[[Prototype]]内部插槽，其值是固有对象％FunctionPrototype％。 具有以下属性： 20.3.3.1 Date.now ( ) now函数返回一个Number值，该值是指定对now进行回调的UTC日期和时间的时间值。 20.3.3.2 Date.parse ( string ) 解析函数将ToString运算符应用于其参数。如果ToString导致突然完成，则立即返回完成记录。否则parse将结果String解释为日期和时间。它返回一个数字，即与日期和时间相对应的UTC时间值。根据字符串的内容，字符串可以解释为本地时间，UTC时间或其他时区中的时间。该函数首先尝试根据日期时间字符串格式（20.3.1.15）中描述的格式（包括扩展年份）解析字符串。如果字符串不符合该格式，则该函数可能会退回到任何特定于实现的启发式或特定于实现的日期格式。无法识别的字符串或包含超出范围的格式字段值的字符串应使Date.parse返回NaN。 如果x是在特定ECMAScript实现中毫秒数为零的任何Date对象，则如果引用的所有属性都有其初始值，则以下所有表达式在该实现中应产生相同的数值： x.valueOf() Date.parse(x.toString()) Date.parse(x.toUTCString()) Date.parse(x.toISOString()) 但是，表达式 Date.parse(x.toLocaleString()) 不需要产生与前面三个表达式相同的Number值，并且通常，如果给定任何不符合Date Time字符串格式（20.3.1.15）的String值，则Date.parse产生的值取决于实现。而toString或toUTCString方法无法在该实现中产生 20.3.3.3 Date.prototype Date.prototype的初始值为内部对象％DatePrototype％。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 20.3.3.4 Date.UTC ( year [ , month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] ] ) 调用UTC函数时，将执行以下步骤： 令 y 为 ? ToNumber(year). 若 month 存在，令 m 为 ? ToNumber(month); 否则，令 m 为 0. 若 date 存在，令 dt 为 ? ToNumber(date); 否则，令 dt 为 1. 若 hours 存在，令 h 为 ? ToNumber(hours); 否则，令 h 为 0. 若 minutes 存在，令 min 为 ? ToNumber(minutes); 否则，令 min 为 0. 若 seconds 存在，令 s 为 ? ToNumber(seconds); 否则，令 s 为 0. 若 ms 存在，令 milli 为 ? ToNumber(ms); 否则，令 milli 为 0. 若 y 是 NaN，令 yr 为 NaN. 否则， 令 yi 为 ! ToInteger(y). 若 0 ≤ yi ≤ 99, 令 yr 为 1900 + yi; 除此之外，令 yr 为 y. 返回 TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))). UTC函数的 \"length\" 属性为7。 注：UTC函数与Date构造函数有两个不同之处：它以数字形式返回时间值，而不是创建Date对象，并且将UTC中的参数解释为本地时间。 20.3.4 Date 原型对象属性 Date原型对象： 是内部对象％DatePrototype％。 本身就是一个普通的对象。 不是Date实例，并且没有[[DateValue]]内部插槽。 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 除非明确定义，否则以下定义的Date原型对象的方法不是通用的，并且传递给它们的this值必须是具有[[DateValue]]内部插槽且已初始化为时间值的对象。 抽象操作 thisTimeValue（value）执行以下步骤： 若 Type(value) 是对象，并且value具有一个[[DateValue]]内部插槽，那么 返回 value.[[DateValue]]. 抛出 TypeError 异常 在对作为Date原型对象的属性的函数的以下描述中，短语“ this Date object”是指作为函数调用的this值的对象。如果此值的类型不是Object，则抛出TypeError异常。方法规范中的短语“此时间值”是指通过调用抽象操作thisTimeValue并将方法调用的this值作为参数传递而返回的结果。 20.3.4.1 Date.prototype.constructor Date.prototype.constructor的初始值为内部对象％Date％ 20.3.4.2 Date.prototype.getDate ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 DateFromTime(LocalTime(t)). 20.3.4.3 Date.prototype.getDay ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 WeekDay(LocalTime(t)). 20.3.4.4 Date.prototype.getFullYear ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 YearFromTime(LocalTime(t)). 20.3.4.5 Date.prototype.getHours ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 HourFromTime(LocalTime(t)) 20.3.4.6 Date.prototype.getMilliseconds ( ) The following steps are performed 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 msFromTime(LocalTime(t)) 20.3.4.7 Date.prototype.getMinutes ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 MinFromTime(LocalTime(t)). 20.3.4.8 Date.prototype.getMonth ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 MonthFromTime(LocalTime(t)). 20.3.4.9 Date.prototype.getSeconds ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 SecFromTime(LocalTime(t)). 20.3.4.10 Date.prototype.getTime ( ) 执行以下步骤： 返回 ? thisTimeValue(this value). 20.3.4.11 Date.prototype.getTimezoneOffset ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 (t - LocalTime(t)) / msPerMinute 20.3.4.12 Date.prototype.getUTCDate ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 DateFromTime(t). 20.3.4.13 Date.prototype.getUTCDay ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 WeekDay(t). 20.3.4.14 Date.prototype.getUTCFullYear ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 YearFromTime(t) 20.3.4.15 Date.prototype.getUTCHours ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 HourFromTime(t). 20.3.4.16 Date.prototype.getUTCMilliseconds ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 msFromTime(t). 20.3.4.17 Date.prototype.getUTCMinutes ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 MinFromTime(t). 20.3.4.18 Date.prototype.getUTCMonth ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 MonthFromTime(t). 20.3.4.19 Date.prototype.getUTCSeconds ( ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，返回 NaN. 返回 SecFromTime(t). 20.3.4.20 Date.prototype.setDate ( date ) 执行以下步骤： 令 t 为 LocalTime(? thisTimeValue(this value)). 令 dt 为 ? ToNumber(date). 令 newDate 为 MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)). 令 u 为 TimeClip(UTC(newDate)). 设置 the [[DateValue]]此Date对象的内部插槽为 u. 返回 u. 20.3.4.21 Date.prototype.setFullYear ( year [ , month [ , date ] ] ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN, 设置 t to +0; 除此之外，set t 为 LocalTime(t). 令 y 为 ? ToNumber(year). 若 month 不存在, 令 m 为 MonthFromTime(t); 除此之外，令 m 为 ? ToNumber(month). 若 date 不存在, 令 dt 为 DateFromTime(t); 除此之外，令 dt 为 ? ToNumber(date). 令 newDate 为 MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)). 令 u 为 TimeClip(UTC(newDate)). 设置 the [[DateValue]]此Date对象的内部插槽为 u. 返回 u. setFullYear方法的 \"length\" 属性为3。 注意：如果不存在month，则此方法的行为就好像存在一个具有值getMonth（）的month一样。如果date不存在，则其行为就好像存在值getDate（）的date一样。 20.3.4.22 Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] ) 执行以下步骤： 令 t 为 LocalTime(? thisTimeValue(this value)). 令 h 为 ? ToNumber(hour). 若 min 不存在, 令 m 为 MinFromTime(t); 除此之外，令 m 为 ? ToNumber(min). 若 sec 不存在, 令 s 为 SecFromTime(t); 除此之外，令 s 为 ? ToNumber(sec). 若 ms 不存在, 令 milli 为 msFromTime(t); 除此之外，令 milli 为 ? ToNumber(ms). 令 date 为 MakeDate(Day(t), MakeTime(h, m, s, milli)). 令 u 为 TimeClip(UTC(date)). 设置 the [[DateValue]]此Date对象的内部插槽为 u. 返回 u. setHours方法的 \"length\" 属性为4。 注：如果不存在min，则此方法的行为就像使用值getMinutes（）存在min一样。如果sec不存在，则其行为就好像sec存在，其值是getSeconds（）。如果不存在ms，则其行为就好像存在ms且其值为getMilliseconds（）。 20.3.4.23 Date.prototype.setMilliseconds ( ms ) 执行以下步骤： 令 t 为 LocalTime(? thisTimeValue(this value)). 设置 ms 为 ? ToNumber(ms). 令 time 为 MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms). 令 u 为 TimeClip(UTC(MakeDate(Day(t), time))). 设置 the [[DateValue]]此Date对象的内部插槽为 u. 返回 u 20.3.4.24 Date.prototype.setMinutes ( min [ , sec [ , ms ] ] ) 执行以下步骤： 令 t 为 LocalTime(? thisTimeValue(this value)). 令 m 为 ? ToNumber(min). 若 sec 不存在, 令 s 为 SecFromTime(t); 除此之外，令 s 为 ? ToNumber(sec). 若 ms 不存在, 令 milli 为 msFromTime(t); 除此之外，令 milli 为 ? ToNumber(ms). 令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)). 令 u 为 TimeClip(UTC(date)). 设置 the [[DateValue]]此Date对象的内部插槽为 u. 返回 u setMinutes 方法的 \"length\" 属性为3。 注：如果不存在sec，则此方法的行为就像sec存在，其值是getSeconds（）。如果不存在ms，则其行为就好像ms的值是getMilliseconds（）。 20.3.4.25 Date.prototype.setMonth ( month [ , date ] ) 执行以下步骤： 令 t 为 LocalTime(? thisTimeValue(this value)). 令 m 为 ? ToNumber(month). 若 date 不存在, 令 dt 为 DateFromTime(t); 除此之外，令 dt 为 ? ToNumber(date). 令 newDate 为 MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)). 令 u 为 TimeClip(UTC(newDate)). 设置 the [[DateValue]]此Date对象的内部插槽为 u. 返回 u. setMonth 方法的 \"length\" 属性为2。 注：如果不存在date，则此方法的行为就像使用值getDate（）存在date一样。 20.3.4.26 Date.prototype.setSeconds ( sec [ , ms ] ) 执行以下步骤： 令 t 为 LocalTime(? thisTimeValue(this value)). 令 s 为 ? ToNumber(sec). 若 ms 不存在, 令 milli 为 msFromTime(t); 除此之外，令 milli 为 ? ToNumber(ms). 令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)). 令 u 为 TimeClip(UTC(date)). 设置 the [[DateValue]]此Date对象的内部插槽为 u. 返回 u. setSeconds 方法的 \"length\" 属性为2。 注：如果不存在ms，则此方法的行为就像ms存在，其值是getMilliseconds（）。 20.3.4.27 Date.prototype.setTime ( time ) 执行以下步骤： Perform ? thisTimeValue(this value). 令 t 为 ? ToNumber(time). 令 v 为 TimeClip(t). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v. 20.3.4.28 Date.prototype.setUTCDate ( date ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 令 dt 为 ? ToNumber(date). 令 newDate 为 MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)). 令 v 为 TimeClip(newDate). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v 20.3.4.29 Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 若 t 是 NaN，设置 t 为 +0. 令 y 为 ? ToNumber(year). 若 month 不存在, 令 m 为 MonthFromTime(t); 除此之外，令 m 为 ? ToNumber(month). 若 date 不存在, 令 dt 为 DateFromTime(t); 除此之外，令 dt 为 ? ToNumber(date). 令 newDate 为 MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)). 令 v 为 TimeClip(newDate). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v setUTCFullYear 方法的 \"length\" 属性为3。 注：如果不存在month，则此方法的行为就像使用值getUTCMonth（）一样存在month。如果date不存在，则其行为就好像存在值getUTCDate（）的date一样。 20.3.4.30 Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 令 h 为 ? ToNumber(hour). 若 min 不存在, 令 m 为 MinFromTime(t); 除此之外，令 m 为 ? ToNumber(min). 若 sec 不存在, 令 s 为 SecFromTime(t); 除此之外，令 s 为 ? ToNumber(sec). 若 ms 不存在, 令 milli 为 msFromTime(t); 除此之外，令 milli 为 ? ToNumber(ms). 令 newDate 为 MakeDate(Day(t), MakeTime(h, m, s, milli)). 令 v 为 TimeClip(newDate). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v setUTCHours 方法的 \"length\" 属性为4。 注：如果不存在min，则此方法的行为就好像存在值getUTCMinutes（）的min一样。如果秒不是 如果存在，则其行为就像sec存在，其值是getUTCSeconds（）。如果不存在ms，则其行为就好像ms的值是getUTCMilliseconds（）。 20.3.4.31 Date.prototype.setUTCMilliseconds ( ms ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 令 milli 为 ? ToNumber(ms). 令 time 为 MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli). 令 v 为 TimeClip(MakeDate(Day(t), time)). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v. 20.3.4.32 Date.prototype.setUTCMinutes ( min [ , sec [ , ms ] ] ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 令 m 为 ? ToNumber(min). 若 sec 不存在，令 s 为 SecFromTime(t). 否则， 令 s 为 ? ToNumber(sec). 若 ms 不存在，令 milli 为 msFromTime(t). 否则， 令 milli 为 ? ToNumber(ms). 令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)). 令 v 为 TimeClip(date). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v. setUTCMinutes 方法的 \"length\" 属性为3。 注：如果不存在sec，则此方法的行为就像sec存在，其值是getUTCSeconds（）。如果不存在ms，则该函数的行为就好像存在ms，且其值由getUTCMilliseconds（）返回。 20.3.4.33 Date.prototype.setUTCMonth ( month [ , date ] ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 令 m 为 ? ToNumber(month). 若 date 不存在，令 dt 为 DateFromTime(t). 否则， 令 dt 为 ? ToNumber(date). 令 newDate 为 MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)). 令 v 为 TimeClip(newDate). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v setUTCMonth 方法的 \"length\" 属性为2。 注：如果不存在date，则此方法的行为就像使用值getUTCDate（）存在date一样。 20.3.4.34 Date.prototype.setUTCSeconds ( sec [ , ms ] ) 执行以下步骤： 令 t 为 ? thisTimeValue(this value). 令 s 为 ? ToNumber(sec). 若 ms 不存在，令 milli 为 msFromTime(t). 否则， 令 milli 为 ? ToNumber(ms). 令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)). 令 v 为 TimeClip(date). 设置 the [[DateValue]]此Date对象的内部插槽为 v. 返回 v. setUTCSeconds 方法的 \"length\" 属性为2。 注：如果不存在ms，则此方法的行为就像ms存在，其值是getUTCMilliseconds（）。 20.3.4.35 Date.prototype.toDateString ( ) 执行以下步骤： 令 O 为 this Date object. 令 tv 为 ? thisTimeValue(O). 若 tv 是 NaN，返回 \"Invalid Date\". 令 t 为 LocalTime(tv). 返回 DateString(t). 20.3.4.36 Date.prototype.toISOString ( ) 此函数返回一个String值，该值表示与该时间值相对应的时间中的实例。字符串的格式是20.3.1.15中定义的日期时间字符串格式。所有字段都存在于字符串中。如果此时间值不是有限数字，或者年份不是可以用该格式表示的值（如果需要，则使用扩展年份格式），将抛出RangeError异常。 20.3.4.37 Date.prototype.toJSON ( key ) 此函数提供JSON.stringify（24.5.2）使用的Date对象的String表示形式。 使用参数键调用toJSON方法时，将执行以下步骤： 令 O 为 ? ToObject(this value). 令 tv 为 ? ToPrimitive(O, hint Number). 若 Type(tv) is Number and tv 不是 finite，返回 null. 返回 ? Invoke(O, \"toISOString\") 注1：该参数被忽略。 注2：toJSON函数是有意通用的。它不需要其此值是Date对象。因此，可以将其转移到其他种类的对象中用作方法。但是，它确实要求任何此类对象都具有toISOString方法。 20.3.4.38 Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的Date.prototype.toLocaleDateString方法。如果ECMAScript实现不包含ECMA-402 API，则使用以下toLocaleDateString方法的规范 该函数返回一个字符串值。 String的内容与实现有关，但是旨在以一种方便的，易于理解的形式表示当前时区中Date的“ date”部分，该形式对应于宿主环境的当前语言环境的约定。 ECMA-402规范中定义了此方法的可选参数的含义；不包含ECMA-402支持的实现不得将这些参数位置用于其他任何用途。 20.3.4.39 Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的Date.prototype.toLocaleString方法。如果ECMAScript实现不包含ECMA-402 API，则使用以下toLocaleString方法的规范。 该函数返回一个字符串值。 String的内容取决于实现，但是旨在以一种方便且易于阅读的形式表示当前时区中的Date，该形式对应于主机环境当前语言环境的约定。 ECMA-402规范中定义了此方法的可选参数的含义；不包含ECMA-402支持的实现不得将这些参数位置用于其他任何用途。 20.3.4.40 Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的Date.prototype.toLocaleTimeString方法。如果ECMAScript实现不包含ECMA-402 API，则使用以下toLocaleTimeString方法的规范。 该函数返回一个字符串值。 String的内容与实现有关，但是旨在以一种方便的，易于理解的形式表示当前时区中Date的“时间”部分，该形式与宿主环境的当前语言环境的约定相对应。 ECMA-402规范中定义了此方法的可选参数的含义；不包含ECMA-402支持的实现不得将这些参数位置用于其他任何用途。 20.3.4.41 Date.prototype.toString ( ) 执行以下步骤： 令 tv 为 ? thisTimeValue(this value). 返回 ToDateString(tv). 注1：对于任何毫秒数为零的Date对象d，Date.parse（d.toString（））的结果等于d.valueOf（）。见20.3.3.2。 注2：toString函数不是通用的；如果此值不是Date对象，则抛出TypeError异常。因此，不能将其作为方法传递给其他类型的对象。 20.3.4.41.1 RS: TimeString ( tv ) 执行以下步骤： 断言：Type(tv) is Number. 断言：tv is not NaN. 令 hour 为 HourFromTime（tv）的字符串表示形式，格式为两位十进制数字，如有必要，在左侧填充零。 令 minute 为 MinFromTime（tv）的字符串表示形式，格式为两位十进制数字，如有必要，在左侧填充零。 令 second 为 SecFromTime（tv）的字符串表示形式，格式为两位十进制数字，如有必要，在左侧填充零。 返回小时，“:”，分钟，“:”，秒，代码单元0x0020（SPACE）和“ GMT”的字符串连接。 20.3.4.41.2 RS: DateString ( tv ) 执行以下步骤： 断言：Type(tv) 是 Number. 断言：tv 不是 NaN. 令 weekday 为表 49 中带有数字WeekDay（tv）的条目的名称。 令 month 为表 50 中条目的名称，其编号为MonthFromTime（tv）。 令 day 为 DateFromTime（tv）的字符串表示形式，格式为两位十进制数字，如有必要，在左侧填充零。 令 year 为 YearFromTime（tv）的字符串表示形式，格式为至少四位数的十进制数字，如有必要，在左侧用零填充。 返回 星期几，代码单位0x0020（空格），月份，代码单位0x0020（空格），日期，代码单位0x0020（空格）和年份的字符串连接。ar. 表49：星期几的名称 数字 名称 0 \"Sun\" 1 \"Mon\" 2 \"Tue\" 3 \"Wed\" 4 \"Thu\" 5 \"Fri\" 6 \"Sat\" 表50：一年中的月份名称 数字 名称 0 \"Jan\" 1 \"Feb\" 2 \"Mar\" 3 \"Apr\" 4 \"May\" 5 \"Jun\" 6 \"Jul\" 7 \"Aug\" 8 \"Sep\" 9 \"Oct\" 10 \"Nov\" 11 \"Dec\" 20.3.4.41.3 RS: TimeZoneString ( tv ) 执行以下步骤： 断言：Type(tv) is Number. 断言：tv is not NaN. 令 offset 为 LocalTZA(tv, true). 若 offset ≥ 0, 令 offsetSign 为 \"+\"; 除此之外，令 offsetSign 为 \"-\". 令 offsetMin 为 MinFromTime（abs（offset））的字符串表示形式，格式为两位十进制数，如有必要，在左侧填充零。 令 offsetHour 为 HourFromTime（abs（offset））的字符串表示形式，格式为两位十进制数字，如有必要，在左侧填充零。 令 tzName 为实现定义的字符串，可以是代码单元0x0020（空格），代码单元0x0028（左括号），实现相关的时区名称和代码单元0x0029（右括号）的空字符串或字符串串联。 返回offsetSign，offsetHour，offsetMin和tzName的字符串串联。 20.3.4.41.4 RS: ToDateString ( tv ) 执行以下步骤： 断言：Type(tv) is Number. 若 tv 是 NaN，返回 \"Invalid Date\". 令 t 为 LocalTime(tv). 返回DateString（t），代码单元0x0020（空格），TimeString（t）和TimeZoneString（tv）的字符串连接。 20.3.4.42 Date.prototype.toTimeString ( ) 执行以下步骤： 令 O 为此Date对象。 令 tv 为 ? thisTimeValue(O). 若 tv 是 NaN，返回 \"Invalid Date\". 令 t 为 LocalTime(tv). 返回TimeString（t）和TimeZoneString（tv）的字符串连接 20.3.4.43 Date.prototype.toUTCString ( ) 执行以下步骤： 令 O 为此Date对象。 令 tv 为 ? thisTimeValue(O). 若 tv 是 NaN，返回 \"Invalid Date\". 令 weekday 为表49中带有数字WeekDay（tv）的条目的名称。 令 month 为表50中条目的名称，其编号为MonthFromTime（tv）。 令 day 为DateFromTime（tv）的字符串表示形式，格式为两位十进制数字，如有必要，在左侧填充零。 令 year 为YearFromTime（tv）的字符串表示形式，格式为至少四位数的十进制数字，如有必要，在左侧用零填充。 返回 星期几，“,”，代码单元0x0020（SPACE），日期，代码单元0x0020（SPACE），月份，代码单元0x0020（SPACE），年份，代码单元0x0020（SPACE）和TimeString（tv）的字符串连接。 20.3.4.44 Date.prototype.valueOf ( ) 执行以下步骤： 返回 ? thisTimeValue(this value) 20.3.4.45 Date.prototype [ @@toPrimitive ] ( hint ) ECMAScript语言操作员调用此函数以将Date对象转换为原始值。提示的允许值为“default”，“number”和“string”。日期对象在内置ECMAScript对象之间是唯一的，因为它们将“default”视为等同于“string”，所有其他内置ECMAScript对象将“default”视为等同于“number”。 当使用参数提示调用@@toPrimitive方法时，将执行以下步骤： 令 O 为 this 值。 若 Type(O) 不是 Object，抛出 TypeError 异常。 若 hint 是字符串值 \"string\" 或字符串值 \"default\"，那么 令 tryFirst 为 \"string\". 否则，若 hint 是字符串值 \"number\"，那么 令 tryFirst 为 \"number\". 否则，抛出 TypeError 异常 返回 ? OrdinaryToPrimitive(O, tryFirst). 该函数的名称属性的值为“ [Symbol.toPrimitive]”。 该属性具有以下特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 20.3.5 Date 实例属性 Date实例是从Date原型对象继承属性的普通对象。日期实例还具有一个[[DateValue]]内部插槽。内部[[DateValue]]插槽是此Date对象表示的时间值。 "},"text-processing.html":{"url":"text-processing.html","title":"21 文字处理","keywords":"","body":"21 文字处理 21.1 String 对象 21.1.1 String 构造器 String构造器： 是内部对象％String％。 是全局对象的String属性的初始值。 在作为构造函数调用时创建并初始化一个新的String对象。 当作为函数而不是构造函数调用时执行类型转换。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定的String行为的子类构造函数必须包括对String构造函数的超级调用，以使用[[StringData]]内部插槽创建和初始化子类实例。 21.1.1.1 String ( value ) 当使用参数值调用String时，将执行以下步骤： 如果没有参数传递给该函数调用，则将其设为“”。 否则， 若 NewTarget 是 undefined，并且 Type(value) 是 Symbol，返回 SymbolDescriptiveString(value). 令 s 为 ? ToString(value). 若 NewTarget 是 undefined，返回 s. 返回 ! StringCreate(s, ? GetPrototypeFromConstructor(NewTarget, \"%StringPrototype%\")). 21.1.2 String 构造器属性 String构造器： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 具有以下特性: 21.1.2.1 String.fromCharCode ( ...codeUnits ) 可以使用组成rest参数codeUnits的任意数量的参数调用String.fromCharCode函数。采取以下步骤: 令 codeUnits 为包含传递给此函数的参数的列表。 令 length 为codeUnits中的元素数量。 令 elements 为一个新的空列表。 令 nextIndex 为 0. 重复，当 nextIndex 令 next 为 codeUnits[nextIndex]. 令 nextCU 为 ? ToUint16(next). 添加 nextCU 到元素的结尾。 nextIndex 增加 1 返回代码单元按顺序为列表元素中的元素的字符串值。如果长度为0，则返回空字符串。 fromCharCode函数的“length”属性是1。 21.1.2.2 String.fromCodePoint ( ...codePoints ) 可以使用组成rest参数codePoints的任意数量的参数调用String.fromCodePoint函数。采取以下步骤: 令 codePoints 为包含传递给此函数的参数的列表。 令 length 为代码点中的元素数量。 令 elements 为一个新的空列表。 令 nextIndex 为 0. 重复，当 nextIndex 令 next 为 codePoints[nextIndex]. 令 nextCP 为 ? ToNumber(next). 若 SameValue(nextCP, ! ToInteger(nextCP)) 是 false, 抛出 RangeError 异常. 若 nextCP 0x10FFFF, 抛出 RangeError 异常. 添加 nextCP 的 utf16 编码的元素到元素的结尾。 nextIndex 增加 1 返回代码单元按顺序为列表元素中的元素的字符串值。如果长度为0，则返回空字符串。 fromCharCode函数的“length”属性是1。 21.1.2.3 String.prototype 字符串的初始值。prototype是内部对象%StringPrototype%。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 21.1.2.4 String.raw ( template, ...substitutions ) String.raw 函数可以用可变数量的参数来调用。第一个参数是template，其余的参数构成列表替换。采取以下步骤: 令 substitutions 为由传递给这个函数的所有参数组成的列表，从第二个参数开始。如果传递的参数少于两个，则列表为空。 令 numberOfSubstitutions 为替换中元素的数量。 令 cooked 为 ? ToObject(template). 令 raw 为 ? ToObject(? Get(cooked, \"raw\")). 令 literalSegments 为 ? ToLength(? Get(raw, \"length\")). 若 literalSegments ≤ 0，返回空字符串. 令 stringElements 为一个新的空列表。 令 nextIndex 为 0. 重复， 令 nextKey 为 ! ToString(nextIndex). 令 nextSeg 为 ? ToString(? Get(raw, nextKey)). 添加 nextSeg 的代码单元元素的顺序 到 stringElements 的结尾。 若 nextIndex + 1 = literalSegments，那么 返回代码单元按顺序为stringElements列表中的元素的字符串值。如果stringElements没有元素，则返回空字符串。 若 nextIndex 否则，令 next 为空字符串 令 nextSub 为 ? ToString(next). 添加 nextSeg 的代码单元元素的顺序 到 stringElements 的结尾。 nextIndex 增加1 注：String.raw 是用于标记模板的标记函数(12.3.7)。当这样调用时，第一个参数将是格式良好的模板对象，而rest参数将包含替换值。 21.1.3 String 原型对象属性 字符串原型对象: 是内部对象%StringPrototype%。 是一个字符串异类对象，并具有为此类对象指定的内部方法。 有一个[[StringData]]内部插槽，其值为空String。 具有 \"length\" 属性，其初始值为0，其属性为 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 除非另有明确说明，否则以下定义的String原型对象的方法不是通用的，并且传递给它们的this值必须是String值或具有[[StringData]]内部插槽且已初始化为String的对象值 抽象操作thisStringValue（value）执行以下步骤： 若 Type(value) 是 String，返回 value. 若 Type(value) 是对象和值具有一个[[StringData]]内部插槽，那么 令 s 为 value.[[StringData]]. 断言：Type(s) 是 String. 返回 s. 抛出 TypeError 异常. 21.1.3.1 String.prototype.charAt ( pos ) 注1：返回单个元素String，该字符串包含在String值内的索引pos处的代码单元，该值由将该对象转换为String产生。如果该索引处没有元素，则结果为空String。结果是一个String值，而不是String对象。 如果pos是Number类型的值为整数的值，则x.charAt（pos）的结果等于x.substring（pos，pos + 1）的结果 当使用一个参数pos调用charAt方法时，将执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 position 为 ? ToInteger(pos). 令 size 为S的长度. 若 position 返回长度为1的字符串值，包含一个来自S的代码单元，即索引位置的代码单元。 注2：charAt函数是有意通用的。它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.2 String.prototype.charCodeAt ( pos ) 注1：返回一个数字（小于216的非负整数），该数字是在String内的索引pos处代码单元的数字值，该值是将此对象转换为String所得到的。如果该索引处没有元素，则结果为NaN。 当使用一个参数pos调用charCodeAt方法时，将执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 position 为 ? ToInteger(pos). 令 size 为S的长度. 若 position 返回一个Number类型的值，其值是字符串S中位于索引位置的代码单元的数值。 注2：charCodeAt函数是有意通用的。它不需要其this值是String对象。因此，可以将其转移到其他类型的对象中作为一种方法。 21.1.3.3 String.prototype.codePointAt ( pos ) 注1：返回一个小于0x110000的非负整数，该整数是UTF-16编码的代码点（6.1.4）的代码点值，从该对象转换为String所得的String索引处的字符串pos开始。如果该索引处没有元素，则结果不确定。如果有效的UTF-16代理对不是从pos开始，则结果是在pos的代码单元 当使用一个参数pos调用codePointAt方法时，将执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 position 为 ? ToInteger(pos). 令 size 为S的长度。 若 position 令 first 为字符串S中索引位置的代码单元的数值。 若 first 0xDBFF 或 position + 1 = size，返回 first. 令 second 为字符串S中位于索引位置+1处的代码单元的数值。 若 second 0xDFFF，返回 first. 返回 UTF16Decode(first, second). 注2：codePointAt函数是有意通用的。它不需要其this值是String对象。因此，可以将其转移到其他类型的对象中作为一种方法。 21.1.3.4 String.prototype.concat ( ...args ) 注1：调用concat方法时，它返回由该对象的代码单元（转换为字符串）组成的字符串值，然后是转换为字符串的每个参数的代码单元。结果是一个String值，而不是String对象。 当使用零个或多个参数调用concat方法时，将执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 args 为一个列表，其元素是传递给此函数的参数。 令 R 为 S. 重复，而args不为空 从args中删除第一个元素，然后让next为该元素的值。 令 nextString 为 ? ToString(next). 将R设置为R和nextString的上一个值的字符串串联。 返回 R. concat方法的“ length”属性为1。 注2：concat函数是有意通用的。它不需要其this值是String对象。因此，可以将其转移到其他类型的对象中作为一种方法。 21.1.3.5 String.prototype.constructor String.prototype.constructor的初始值为内部对象％String％。 21.1.3.6 String.prototype.endsWith ( searchString [ , endPosition ] ) 采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 isRegExp 为 ? IsRegExp(searchString). 若 isRegExp 是 true, 抛出 TypeError 异常. 令 searchStr 为 ? ToString(searchString). 令 len 为S的长度. 若 endPosition 是 undefined, 令 pos 为 len，否则令 pos 为 ? ToInteger(endPosition). 令 end 为 min(max(pos, 0), len). 令 searchLength 为searchStr的长度。 令 start 为 end - searchLength. 若 start 小于 0，返回 false. 若从长度searchLength开始的S的代码单元序列与searchStr的完整代码单元序列相同，返回 true. 除此之外，返回 false. 注 1 如果searchString转换为String的代码单元序列与此对象（转换为String）从endPosition-length（this）开始的相应代码单元序列相同，则返回true。否则返回false。 注 2 如果第一个参数是RegExp，则抛出异常，以允许将来的版本定义允许此类参数值的扩展。 注 3 endsWith函数是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.7 String.prototype.includes ( searchString [ , position ] ) include方法采用两个参数searchString和position，并执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 isRegExp 为 ? IsRegExp(searchString). 若 isRegExp 是 true, 抛出 TypeError 异常. 令 searchStr 为 ? ToString(searchString). 令 pos 为 ? ToInteger(position). 断言：若 position 是 undefined，那么 pos 是 0. 令 len 为S的长度。 令 start 为 min(max(pos, 0), len). 令 searchLen 为searchStr的长度。 如果存在不小于起始值的整数k使得k + searchLen不大于len，并且对于所有小于searchLen的非负整数j，则S中位于索引k + j的代码单元与位于索引处的代码单元相同在searchStr中的j，返回true；但是，如果没有这样的整数k，则返回false。 注 1 如果searchString作为将该对象转换为String的结果的子字符串出现，则在大于或等于position的一个或多个索引处，返回true；否则，返回true。否则，返回false。如果未定义位置，则假定为0，以便搜索所有String。 注 2 如果第一个参数是RegExp，则抛出异常，以允许将来的版本定义允许此类参数值的扩展。 注 3 包含函数是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.8 String.prototype.indexOf ( searchString [ , position ] ) 注 1：如果searchString作为将此对象转换为String的结果的子字符串出现，则在大于或等于position的一个或多个索引处，将返回最小的索引；否则，返回-1。如果未定义位置，则假定为0，以便搜索所有String。 indexOf方法采用两个参数searchString和position，并执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 searchStr 为 ? ToString(searchString). 令 pos 为 ? ToInteger(position). 断言：若 position 是 undefined，那么 pos 是 0. 令 len 为S的长度。 令 start 为 min(max(pos, 0), len). 令 searchLen 为searchStr的长度。 返回不小于开始的最小可能整数k，使得k + searchLen不大于len，并且对于所有小于searchLen的非负整数j，S中位于索引k + j的代码单元与位于索引j的代码单元相同在searchStr内；但是如果没有这样的整数k，则返回值-1。 注 2：indexOf函数是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.9 String.prototype.lastIndexOf ( searchString [ , position ] ) 注 1：如果searchString作为将该对象转换为String的结果的子字符串出现在一个或多个小于或等于position的索引处，则返回最大的索引；否则，返回-1。如果position未定义，则采用String值的长度，以便搜索所有String。 lastIndexOf方法采用两个参数searchString和position，并执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 searchStr 为 ? ToString(searchString). 令 numPos 为 ? ToNumber(position). 断言：若 position 是 undefined，那么 numPos 是 NaN. 若 numPos 是 NaN, 令 pos 为 +∞; 除此之外，令 pos 为 ! ToInteger(numPos). 令 len 为S的长度. 令 start 为 min(max(pos, 0), len). 令 searchLen 为searchStr的长度。 返回不大于start的最大可能的非负整数k，以使k + searchLen不大于len，并且对于所有小于searchLen的非负整数j，S中位于索引k + j的代码单元与位于索引处的代码单元相同j在searchStr内；但是如果没有这样的整数k，则返回值-1。 注 2 lastIndexOf函数是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.10 String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的localeCompare方法。如果ECMAScript实现不包含ECMA-402 API，则使用以下localeCompare方法的规范。 当使用带有作为参数的参数调用localeCompare方法时，它返回的数字不是NaN，它表示此值（转换为String）与该值（转换为String）的区域设置敏感的String比较结果。这两个字符串是S和That。这两个字符串以实现定义的方式进行比较。该结果旨在按主机默认语言环境指定的排序顺序对String值进行排序，并将为负，零或正，具体取决于S排在前面，还是S排在后面； S是排在后面还是相等。分别以排序顺序表示。 在执行比较之前，请执行以下步骤来准备字符串： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 That 为 ? ToString(that). ECMA-402规范中定义了此方法的可选第二和第三参数的含义；不包含ECMA-402支持的实现不得将任何其他解释分配给这些参数位置。 如果localeCompare方法被视为this和that两个参数的函数，则它是所有String集合上的一致比较函数（如22.1.3.27中所定义）。 实际的返回值是由实现定义的，以允许实现者在值中编码其他信息，但是需要该函数来定义所有String的总顺序。此函数必须将根据Unicode标准规范等效的字符串视为相同，并且在比较被认为等效的字符串时必须返回0。 注 1 localeCompare方法本身并不直接适合作为Array.prototype.sort的参数，因为后者需要两个参数的函数。 注 2 此功能旨在依赖宿主环境可用于ECMAScript环境的任何语言敏感比较功能，并根据宿主环境当前语言环境的规则进行比较。但是，无论主机提供了什么比较功能，此函数都必须将根据Unicode标准规范等效的字符串视为相同。建议此函数不要遵循Unicode兼容性等效或分解。有关规范等效性的定义和讨论，请参见Unicode标准第2章和第3章，以及Unicode标准附件＃15，Unicode规范化形式（https://unicode.org/reports/tr15/）和Unicode技术说明＃5 ，应用中的规范对等（https://www.unicode.org/notes/tn5/）。另请参阅Unicode技术标准＃10，Unicode排序算法（https://unicode.org/reports/tr10/）。 注 3 localeCompare函数是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.11 String.prototype.match ( regexp ) 当使用参数regexp调用match方法时，将执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 若 regexp 不是 undefined 或 null，那么 令 matcher 为 ? GetMethod(regexp, @@match). 若 matcher 不是 undefined，那么 返回 ? Call(matcher, regexp, « O »). 令 S 为 ? ToString(O). 令 rx 为 ? RegExpCreate(regexp, undefined). 返回 ? Invoke(rx, @@match, « S »). 注：匹配功能是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.12 String.prototype.normalize ( [ form ] ) 当使用一个参数形式调用normalize方法时，将执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 若 form 不存在，或 form 是 undefined, 设置 form 为 \"NFC\". 令 f 为 ? ToString(form). 若 f 不是 \"NFC\", \"NFD\", \"NFKC\", 或 \"NFKD\"其中之一, 抛出 RangeError 异常. 令 ns 为字符串值，它是将S标准化为https://unicode.org/reports/tr15/中指定的以f命名的标准化形式的结果。 返回 ns. 注：规范化功能是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他类型的对象中作为一种方法。 21.1.3.13 String.prototype.padEnd ( maxLength [ , fillString ] ) 调用padEnd方法时，将执行以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 intMaxLength 为 ? ToLength(maxLength). 令 stringLength 为S的长度. 若 intMaxLength 不大于 stringLength，返回 S. 若 fillString 是 undefined, 令 filler 为仅由代码单元0x0020（空格）组成的字符串值。 否则，令 filler 为 ? ToString(fillString). 若 filler 是空字符串，返回 S. 令 fillLen 为 intMaxLength - stringLength. 令 truncatedStringFiller 为String值，该值由填充的重复串联组成，这些填充被截断为长度fillLen。 返回 S 和 truncatedStringFiller 的字符串连接。 注 1 将限制第一个参数maxLength，使其不小于该值的长度。 注 2 第二个可选参数fillString默认为“”(由代码单元0x0020空格组成的字符串值)。 21.1.3.14 String.prototype.padStart ( maxLength [ , fillString ] ) 当调用padStart方法时，采取以下步骤: 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 intMaxLength 为 ? ToLength(maxLength). 令 stringLength 为S的长度. 若 intMaxLength 不大于 stringLength，返回 S. 若 fillString 是 undefined, 令 filler 为仅由代码单元0x0020(空格)组成的字符串值。 否则， 令 filler 为 ? ToString(fillString). 若 filler 是空字符串，返回 S. 令 fillLen 为 intMaxLength - stringLength. 令 truncatedStringFiller 为由重复连接的填充符组成的字符串值，将其截断为长度fillLen。 返回truncatedStringFiller和S的字符串连接。 注 1 将限制第一个参数maxLength，使其不小于该值的长度。 注 2 第二个可选参数fillString默认为“”(由代码单元0x0020空格组成的字符串值)。 21.1.3.15 String.prototype.repeat ( count ) 将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 n 为 ? ToInteger(count). 若 n 若 n 是 +∞, 抛出 RangeError 异常. 若 n 是 0，返回空字符串. 返回由S的n个副本组成的String值 注 1 此方法创建String值，该值由该对象的代码单元（转换为String）重复的计数时间组成。 注 2 重复功能是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.16 String.prototype.replace ( searchValue, replaceValue ) 当用参数searchValue和replaceValue调用replace方法时，将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 若 searchValue 既不是undefined，也不是null，那么 令 replacer 为 ? GetMethod(searchValue, @@replace). 若 replacer 不是 undefined，那么 返回 ? Call(replacer, searchValue, « O, replaceValue »). 令 string 为 ? ToString(O). 令 searchString 为 ? ToString(searchValue). 令 functionalReplace 为 IsCallable(replaceValue). 若 functionalReplace 是 false，那么 设置 replaceValue 为 ? ToString(replaceValue). 搜索字符串以查找searchString的第一个匹配项，并令pos为匹配子字符串的第一个代码单元的字符串内的索引，而让match为searchString，返回 string. 若 functionalReplace 是 true，那么 令 replValue 为 ? Call(replaceValue, undefined, « matched, pos, string »). 令 replStr 为 ? ToString(replValue). 否则， 令 captures 为一个新的空列表。 令 replStr 为 GetSubstitution(matched, string, pos, captures, undefined, replaceValue). 令 tailPos 为 pos + 匹配的代码单元数。 令 newString 为 string 的第一个pos代码单元，replStr，从索引tailPos开始的字符串的尾部子字符串的字符串级联。如果pos为0，则串联的第一个元素将为空String。 返回 newString. 注 替换功能是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.16.1 RS: GetSubstitution ( matched, str, position, captures, namedCaptures, replacement )222 抽象操作GetSubstitution执行以下步骤： 断言：Type(matched) 是 String. 令 matchLength 为匹配的代码单元数。 断言：Type(str) 是 String. 令 stringLength 为 str 中的代码单位数。 断言：position是一个非负整数。 断言：position ≤ stringLength. 断言：captures是一个可能为空的字符串列表。 断言：Type(replacement) 是 String. 令 tailPos 为 position + matchLength. 令 m 为捕获中元素的数量。 若 namedCaptures 不是 undefined，那么 设置 namedCaptures 为 ? ToObject(namedCaptures). 令 result 为替换产生的字符串值，方法是按照表51的指定在执行替换时将代码单元元素从替换复制到结果。这些$替换从左到右完成，并且一旦执行了这样的替换，就不会生成新的替换文本有待进一步更换。 返回 result. 表51：替换文本符号替换 代码单元 Unicode Characters Replacement text 0x0024, 0x0024 $$ $ 0x0024, 0x0026 $& matched 0x0024, 0x0060 `$`` 如果position为0，则替换为空String。否则，替换将是str的子字符串，该子字符串从索引0开始并且其最后一个代码单元位于索引position -1。 0x0024, 0x0027 $' 如果 tailPos ≥ stringLength ，则替换为空String。否则，替换将是str的子字符串，该子字符串从索引tailPos开始并一直持续到str的结尾。 0x0024, N 此处 0x0031 ≤ N ≤ 0x0039 $n，n是 1 2 3 4 5 6 7 8 9 其中之一，并且 $n 后没有十进制数字 捕获的第n个元素，其中n是1到9范围内的一位数字。如果n≤m并且捕获的第n个元素undefined，请改用空字符串。如果n> m，则不进行替换。 0x0024, N, N 此处 0x0030 ≤ N ≤ 0x0039 $nn，n 是0 1 2 3 4 5 6 7 8 9 其中之一 捕获的第n个元素，其中n是1到9范围内的一个数字。如果n≤m并且捕获的第n个元素未定义，请改用空字符串。如果n> m，则不进行替换。 0x0024, 0x003C $ 1. 若 namedCaptures 是 undefined，替换文本为字符串\"$2. 否则， 1. 扫描到下一个 > U+003E (大于符号). 2. 如果未找到，则替换文本为字符串“ $ 3. 否则， 1. 令groupName作为所包含的子字符串。 2. 令 capture 为 ? Get(namedCaptures, groupName). 3. 若 capture 是 undefined, 通过 > 将文本替换为空字符串。 4. 否则, 通过>将文本替换为 ? ToString(capture). 0x0024 $ 在与以上任何条件都不匹配的任何上下文中。 $ 21.1.3.17 String.prototype.search ( regexp ) 当使用参数regexp调用搜索方法时，将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 若 regexp 既不是undefined，也不是null，那么 令 searcher 为 ? GetMethod(regexp, @@search). 若 searcher 不是 undefined，那么 返回 ? Call(searcher, regexp, « O »). 令 string 为 ? ToString(O). 令 rx 为 ? RegExpCreate(regexp, undefined). 返回 ? Invoke(rx, @@search, « string ») 注：搜索功能是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他种类的对象中用作方法。 21.1.3.18 String.prototype.slice ( start, end ) slice方法有两个参数，即start和end，并返回将该对象转换为String的结果的子字符串，该子字符串从索引start开始并运行至但不包括索引end（或end，如果不包括，则通过String的结尾）未定义）。如果start为负，则将其视为sourceLength + start，其中sourceLength是字符串的长度。如果end为负，则将其视为sourceLength + end，其中sourceLength是字符串的长度。结果是一个String值，而不是String对象。将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 len 为S的长度. 令 intStart 为 ? ToInteger(start). 若 end 是 undefined, 令 intEnd 为 len; else 令 intEnd 为 ? ToInteger(end). 若 intStart 若 intEnd 令 span 为 max(to - from, 0). 返回包含从S开始的跨度连续代码单元的String值，该代码单元从索引from处的代码单元开始。 注：slice函数是有意通用的；它不需要其this值是String对象。因此，可以将其转移到其他类型的对象中作为一种方法。 21.1.3.19 String.prototype.split ( separator, limit ) 返回一个Array对象，此对象转换为String的结果的子字符串已存储在其中。通过从左到右搜索是否出现分隔符来确定子字符串。这些出现不属于返回数组中任何子字符串的一部分，而是用于划分String值。分隔符的值可以是任意长度的字符串，也可以是具有@@split方法的对象，例如RegExp。 调用split方法时，将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 若 separator 既不是undefined，也不是null，那么 令 splitter 为 ? GetMethod(separator, @@split). 若 splitter 不是 undefined，那么 返回 ? Call(splitter, separator, « O, limit »). 令 S 为 ? ToString(O). 令 A 为 ! ArrayCreate(0). 令 lengthA 为 0. 若 limit 是 undefined, 令 lim 为 232 - 1; 否则，令 lim 为 ? ToUint32(limit). 令 s 为S的长度. 令 p 为 0. 令 R 为 ? ToString(separator). 若 lim = 0，返回 A. 若 separator 是 undefined，那么 执行 ! CreateDataProperty(A, \"0\", S). 返回 A. 若 s = 0，那么 令 z 为 SplitMatch(S, 0, R). 若 z 不是 false，返回 A. 执行 ! CreateDataProperty(A, \"0\", S). 返回 A. 令 q 为 p. 重复, 直到 q ≠ s 令 e 为 SplitMatch(S, q, R). 若 e 是 false, q 增加1. 否则 e 是整数索引 ≤ s, 若 e = p, q 增加1. 否则 e ≠ p, 令 T 为字符串值等于S的子字符串，由下标p(包括)到q(不包括)的代码单元组成。 执行 ! CreateDataProperty(A, ! ToString(lengthA), T). lengthA 增加 1. 若 lengthA = lim，返回 A. 设置 p 为 e. 设置 q 为 p. 令 T 为字符串值等于S的子字符串，由下标p(包括)到下标S(不包括)的代码单元组成。 执行 ! CreateDataProperty(A, ! ToString(lengthA), T). 返回 A. 注 1 分隔符的值可以是空字符串。在本例中，separator不匹配输入字符串开头或结尾的空子字符串，也不匹配前面的分隔符匹配结尾的空子字符串。如果分隔符是空字符串,字符串分割成单个代码单元元素；结果数组的长度等于字符串的长度，每个子字符串包含一个代码单元。 如果这个对象(或皈依)空字符串,结果取决于分离器可以匹配空字符串。如果可以，则结果数组不包含任何元素。否则,结果数组包含一个元素,它是空字符串。 如果分隔符未定义，则结果数组只包含一个字符串，即this值(转换为字符串)。如果没有定义限制,那么输出数组截断,包含不超过限制元素。 注 2 分裂函数是故意通用的;它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.19.1 RS: SplitMatch ( S, q, R ) SplitMatch抽象操作接受三个参数，一个字符串S、一个整数q和一个字符串R，执行以下步骤以返回匹配的false或end索引: 断言：Type(R) 是 String. 令 r 为R中代码单位的数量。 令 s 为S中代码单位的数量。 若 q + r > s，返回 false. 若在0(含)和r(不含)之间存在一个整数i，使得S中q + i下标处的码元与r中i下标处的码元不同，返回 false. 返回 q + r. 21.1.3.20 String.prototype.startsWith ( searchString [ , position ] ) 将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 isRegExp 为 ? IsRegExp(searchString). 若 isRegExp 是 true, 抛出 TypeError 异常. 令 searchStr 为 ? ToString(searchString). 令 pos 为 ? ToInteger(position). 断言：若 position 是 undefined，那么 pos 是 0. 令 len 为S的长度. 令 start 为 min(max(pos, 0), len). 令 searchLength 为searchStr的长度。 若 searchLength + start is大于 len，返回 false. 若S从长度searchLength开始的码元序列与searchStr的全码元序列相同，返回 true. 除此之外，返回 false. 注 1 如果转换为字符串的searchString的代码单元序列与此对象(转换为字符串)从索引位置开始的相应代码单元相同，则此方法返回true。否则返回false。 注 2 如果指定的第一个参数是RegExp，则抛出异常，以便允许将来的版本定义允许此类参数值的扩展。 注 3 带有函数的startsWith是故意通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用 21.1.3.21 String.prototype.substring ( start, end ) substring方法接受两个参数start和end，并返回将该对象转换为字符串的结果的子字符串，从索引开始并运行到(但不包括)字符串的索引结束(如果end未定义，则通过字符串结束)。结果是一个字符串值，而不是一个字符串对象。 如果参数是NaN或负数，则用0代替；如果其中一个参数大于字符串的长度，则用字符串的长度替换它。 如果开始大于结束，则交换它们。 将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 令 len 为S的长度. 令 intStart 为 ? ToInteger(start). 若 end 是 undefined, 令 intEnd 为 len; 否则，令 intEnd 为 ? ToInteger(end). 令 finalStart 为 min(max(intStart, 0), len). 令 finalEnd 为 min(max(intEnd, 0), len). 令 from 为 min(finalStart, finalEnd). 令 to 为 max(finalStart, finalEnd). 返回长度为to - from的字符串值，包含来自S的代码单位，即从下到- 1的代码单位，按升序排列。 注 子字符串函数是通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.22 String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的toLocaleLowerCase方法。 如果ECMAScript实现不包含ECMA-402 API，则使用以下toLocaleLowerCase方法规范。 该函数将字符串值解释为UTF-16编码的编码点序列，如6.1.4所述。 这个函数的工作方式与toLowerCase完全相同，不同之处在于它的结果是为主机环境的当前语言环境生成正确的结果，而不是独立于语言环境的结果。只有在少数情况下(比如土耳其语)，这种语言的规则与常规的Unicode大小写映射冲突时才会有所不同。 该方法的可选参数的含义在ECMA-402规范中定义；不包括ECMA-402支持的实现不能将这些参数位置用于其他任何地方。 注：toLocaleLowerCase函数是故意通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.23 String.prototype.toLocaleUpperCase ( [ reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的toLocaleUpperCase方法。 如果ECMAScript实现不包含ECMA-402 API，则使用以下toLocaleUpperCase方法规范。 该函数将字符串值解释为UTF-16编码的编码点序列，如6.1.4所述。 这个函数的工作方式与toUpperCase完全相同，只是它的结果是为主机环境的当前语言环境生成正确的结果，而不是独立于语言环境的结果。只有在少数情况下(比如土耳其语)，这种语言的规则与常规的Unicode大小写映射冲突时才会有所不同。 该方法的可选参数的含义在ECMA-402规范中定义；不包括ECMA-402支持的实现不能将这些参数位置用于其他任何地方。 注：toLocaleUpperCase函数是故意通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用 21.1.3.24 String.prototype.toLowerCase ( ) 该函数将字符串值解释为UTF-16编码的编码点序列，如6.1.4所述。将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value) 令 S 为 ? ToString(O). 令 cpList 为按顺序包含S的6.1.4中定义的代码点的列表，从S的第一个元素开始。 令 cuList 为根据Unicode默认大小写转换算法，其中元素是toLowercase(cpList)的结果。 令 L 为代码单元为cuList代码点的utf16编码的字符串值。 返回 L. 结果必须根据Unicode字符数据库中的不区分区域设置的大小写映射(这不仅显式地包括UnicodeData.txt文件，还包括它所附带的SpecialCasings.txt文件中的所有不区分区域设置的映射)。 注 1 某些代码点的案例映射可能产生多个代码点。在这种情况下，结果字符串可能与源字符串的长度不同。因为toUpperCase和toLowerCase都具有上下文敏感的行为，所以函数不是对称的。换句话说，s.toUpperCase(). tolowercase()不一定等于s.toLowerCase()。 注 2 toLowerCase函数是故意通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.25 String.prototype.toString ( ) 当toString方法被调用时， 将采取以下步骤： 返回 ? thisStringValue(this value). 注：对于String对象，toString方法恰好返回与valueOf方法相同的内容。 21.1.3.26 String.prototype.toUpperCase ( ) 该函数将字符串值解释为UTF-16编码的编码点序列，如6.1.4所述。 此函数的行为与String.prototype完全相同。除了字符串是使用Unicode默认大小写转换的toUppercase算法映射的。 注：toUpperCase函数是故意通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.27 String.prototype.trim ( ) 该函数将字符串值解释为UTF-16编码的编码点序列，如6.1.4所述。 将采取以下步骤： 令 S 为 this 值. 返回 ? TrimString(S, \"start+end\") 注：修剪函数是故意通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.27.1 RS: TrimString ( string, where ) 调用带有参数字符串和where的抽象操作TrimString，并将字符串值字符串解释为UTF-16编码的编码点序列，如6.1.4中所述。它执行以下步骤: 令 str 为 ? RequireObjectCoercible(string). 令 S 为 ? ToString(str). 若 where 是 \"start\", 令 T删除前导空白的S的副本的字符串值。 否则若 where 是 \"end\", 令 T 为删除尾随空格的S的副本的字符串值。 否则， 断言：where 是 \"start+end\". 令 T 为字符串值，它是S的副本，去掉了开头和结尾的空白。 返回 T. 空白的定义是空白和行结束符的结合。在确定Unicode编码点是否属于Unicode通用类别“Space_Separator”(“Zs”)时，代码单元序列被解释为6.1.4中指定的UTF-16编码的编码点序列。 21.1.3.28 String.prototype.trimEnd ( ) 该函数将字符串值解释为UTF-16编码的编码点序列，如6.1.4所述。 将采取以下步骤： 令 S 为 this value. 返回 ? TrimString(S, \"end\"). 注：trimEnd函数是故意通用的;它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.29 String.prototype.trimStart ( ) 该函数将字符串值解释为UTF-16编码的编码点序列，如6.1.4所述。 将采取以下步骤： 令 S 为 this value. 返回 ? TrimString(S, \"start\"). 注：trimStart函数是故意通用的；它不要求它的这个值是一个字符串对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 21.1.3.30 String.prototype.valueOf ( ) 当valueOf方法被调用时，将采取以下步骤： 返回 ? thisStringValue(this value). 21.1.3.31 String.prototype [ @@iterator ] ( ) 当@@iterator方法被调用时，它返回一个迭代器对象(25.1.1.2)，迭代一个字符串值的代码点，将每个代码点作为一个字符串值返回。将采取以下步骤： 令 O 为 ? RequireObjectCoercible(this value). 令 S 为 ? ToString(O). 返回 CreateStringIterator(S). 这个函数的name属性的值是“[Symbol.iterator]”。 21.1.4 String 实例属性 字符串实例是字符串外来对象，并具有为此类对象指定的内部方法。字符串实例从字符串原型对象继承属性。字符串实例也有一个[[StringData]]内部槽。 字符串实例有一个“length”属性和一组具有整数索引名称的可枚举属性。 21.1.4.1 length 此字符串对象表示的字符串值中的元素数。 初始化字符串对象后，此属性将保持不变。它有属性{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 21.1.5 String 迭代器对象 字符串迭代器是一个对象，它表示对某个特定字符串实例对象的特定迭代。字符串迭代器对象没有指定的构造函数。相反，String迭代器对象是通过调用String实例对象的某些方法来创建的 21.1.5.1 CreateStringIterator ( string ) 字符串对象的几个方法返回迭代器对象。带有参数字符串的抽象操作CreateStringIterator用于创建这样的迭代器对象。它执行以下步骤: 断言：Type(string) 是 String. 令 iterator 为 ObjectCreate(%StringIteratorPrototype%, « [[IteratedString]], [[StringIteratorNextIndex]] »). 设置 iterator.[[IteratedString]] 为 string. 设置 iterator.[[StringIteratorNextIndex]] 为 0. 返回 iterator. 21.1.5.2 The %StringIteratorPrototype% Object % StringIteratorPrototype %对象: 具有所有字符串迭代器对象继承的属性。 是一个普通的对象。 有一个[[Prototype]]内部插槽，其值是内部对象％IteratorPrototype％。 具有以下属性： 21.1.5.2.1 %StringIteratorPrototype%.next ( ) 令 O 为 this 值。 若 Type(O) 不是 Object, 抛出 TypeError 异常. 若 O 没有字符串迭代器实例（21.1.5.3）的所有内部插槽，抛出 TypeError 异常. 令 s 为 O.[[IteratedString]]. 若 s 是 undefined，返回 CreateIterResultObject(undefined, true). 令 position 为 O.[[StringIteratorNextIndex]]. 令 len 为S的长度. 若 position ≥ len，那么 设置 O.[[IteratedString]] 为 undefined. 返回 CreateIterResultObject(undefined, true). 令 first 为s中位于索引位置的代码单元的数值。 若 first 0xDBFF 或 position + 1 = len, 令 resultString 为首先由单个代码单元组成的String值。 否则， 令 second 为String内索引位置+1处的代码单元的数值。 若 second 0xDFFF, 令 resultString 为首先由单个代码单元组成的String值。 否则， 令 resultString 为 首先是代码单元的字符串连接，然后是代码单元的字符串连接。 令 resultSize 为 resultString 中的代码单元数。 设置 O.[[StringIteratorNextIndex]] 为 position + resultSize. 返回 CreateIterResultObject(resultString, false). 21.1.5.2.2 %StringIteratorPrototype% [ @@toStringTag ] @@toStringTag属性的初始值为String值“ String Iterator”。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 21.1.5.3 String 迭代器实例的属性 字符串迭代器实例是从％StringIteratorPrototype％内部对象继承属性的普通对象。最初使用表52中列出的内部插槽创建String Iterator实例。 表52：字符串迭代器实例的内部插槽 内部插槽 描述 [[IteratedString]] 要迭代其代码单元的String值。 [[StringIteratorNextIndex]] 此迭代要检查的下一个字符串索引的整数索引。 21.2 RegExp（正则表达式）对象 RegExp对象包含一个正则表达式和关联的标志。 注：正则表达式的形式和功能是根据Perl 5编程语言中的正则表达式工具建模的。 21.2.1 模式 RegExp构造函数将以下语法应用于输入模式字符串。如果语法不能将字符串解释为模式的展开，则会发生错误。 语法 Pattern[U, N] :: Disjunction[?U, ?N] Disjunction[U, N] :: Alternative[?U, ?N] Alternative[?U, ?N] | Disjunction[?U, ?N] Alternative[U, N] :: [empty] Alternative[?U, ?N] Term[?U, ?N] Term[U, N] :: Assertion[?U, ?N] Atom[?U, ?N] Atom[?U, ?N] Quantifier Assertion[U, N] :: ^ $ \\ b \\ B ( ? = Disjunction[?U, ?N] ) ( ? ! Disjunction[?U, ?N] ) ( ? RegExpIdentifierName[U] :: RegExpIdentifierStart[?U] RegExpIdentifierName[?U] RegExpIdentifierPart[?U] RegExpIdentifierStart[U] :: UnicodeIDStart $ _ \\ RegExpUnicodeEscapeSequence[?U] RegExpIdentifierPart[U] :: UnicodeIDContinue $ \\ RegExpUnicodeEscapeSequence[?U] RegExpUnicodeEscapeSequence[U] :: [+U] u LeadSurrogate \\u TrailSurrogate [+U] u LeadSurrogate [+U] u TrailSurrogate [+U] u NonSurrogate [~U] u Hex4Digits [+U] u{ CodePoint } 每个与其关联的 u LeadSurrogate的选择不明确的 \\u TrailSurrogate都应与最接近的可能的 u LeadSurrogate关联，否则，它们将没有对应的 \\u TrailSurrogate。 LeadSurrogate :: Hex4Digits but only if the SV of Hex4Digits is in the inclusive range 0xD800 to 0xDBFF TrailSurrogate :: Hex4Digits but only if the SV of Hex4Digits is in the inclusive range 0xDC00 to 0xDFFF NonSurrogate :: Hex4Digits but only if the SV of Hex4Digits is not in the inclusive range 0xD800 to 0xDFFF IdentityEscape[U] :: [+U] SyntaxCharacter [+U] / [~U] SourceCharacter but not UnicodeIDContinue DecimalEscape :: NonZeroDigit DecimalDigitsopt [lookahead ∉ DecimalDigit] CharacterClassEscape[U] :: d D s S w W [+U] p{ UnicodePropertyValueExpression } [+U] P{ UnicodePropertyValueExpression } UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue LoneUnicodePropertyNameOrValue UnicodePropertyName :: UnicodePropertyNameCharacters UnicodePropertyNameCharacters :: UnicodePropertyNameCharacter UnicodePropertyNameCharactersopt UnicodePropertyValue :: UnicodePropertyValueCharacters LoneUnicodePropertyNameOrValue :: UnicodePropertyValueCharacters UnicodePropertyValueCharacters :: UnicodePropertyValueCharacter UnicodePropertyValueCharactersopt UnicodePropertyValueCharacter :: UnicodePropertyNameCharacter 0 1 2 3 4 5 6 7 8 9 UnicodePropertyNameCharacter :: ControlLetter _ CharacterClass[U] :: [ [lookahead ∉ { ^ }] ClassRanges[?U] ] [ ^ ClassRanges[?U] ] ClassRanges[U] :: [empty] NonemptyClassRanges[?U] NonemptyClassRanges[U] :: ClassAtom[?U] ClassAtom[?U] NonemptyClassRangesNoDash[?U] ClassAtom[?U] - ClassAtom[?U] ClassRanges[?U] NonemptyClassRangesNoDash[U] :: ClassAtom[?U] ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U] ClassAtomNoDash[?U] - ClassAtom[?U] ClassRanges[?U] ClassAtom[U] :: - ClassAtomNoDash[?U] ClassAtomNoDash[U] :: SourceCharacter but not one of \\ or ] or - \\ ClassEscape[?U] ClassEscape[U] :: b [+U] - CharacterClassEscape[?U] CharacterEscape[?U] 21.2.1.1 SS: Early Errors Pattern :: Disjunction 如果 NcapturingParens≥2^32-1，则为语法错误。 如果Pattern包含多个GroupSpecifier，且其封闭的RegExpIdentifierNames具有相同的StringValue，则t为语法错误。 QuantifierPrefix :: { DecimalDigits , DecimalDigits } 如果第一个DecimalDigits的MV大于第二个DecimalDigits的MV，则是语法错误。 AtomEscape :: k GroupName 如果封闭的模式不包含带有封闭的RegExpIdentifierName的GroupSpecifier，则其语法值为String等于此生产的GroupName的RegExpIdentifierName的StringValue，这是语法错误。 AtomEscape :: DecimalEscape It is a Syntax Error if the CapturingGroupNumber of DecimalEscape is larger than NcapturingParens (21.2.2.1). NonemptyClassRanges :: ClassAtom - ClassAtom ClassRanges 如果第一个ClassAtom的IsCharacterClass为true或第二个ClassAtom的IsCharacterClass为true，则为语法错误。 如果第一个ClassAtom的IsCharacterClass为false，第二个ClassAtom的IsCharacterClass为false，并且第一个ClassAtom的CharacterValue大于第二个ClassAtom的CharacterValue，则是语法错误。 NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassRanges 如果ClassAtomNoDash的IsCharacterClass为true或ClassAtom的IsCharacterClass为true，则为语法错误。 如果ClassAtomNoDash的IsCharacterClass为false，ClassAtom的IsCharacterClass为false，并且ClassAtomNoDash的CharacterValue大于ClassAtom的CharacterValue，则是语法错误。 RegExpIdentifierStart :: \\ RegExpUnicodeEscapeSequence 如果SV（RegExpUnicodeEscapeSequence）不为“ $”或“ _”或与UnicodeIDStart词汇语法生成匹配的代码点的UTF16Encoding，则为语法错误。 RegExpIdentifierPart :: \\ RegExpUnicodeEscapeSequence 如果SV（RegExpUnicodeEscapeSequence）都不是“ $”或“ _”，或者不是或的UTF16Encoding，或者不是UnicodeIDContinue词汇语法产生的Unicode代码点的UTF16Encoding，则是语法错误。 UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue 如果UnicodePropertyName的SourceText Unicode代码点列表与表54的“属性名称和别名”列中列出的Unicode属性名或属性别名的Unicode代码点列表不同，则这是语法错误。 如果UnicodePropertyValue的Unicode代码点列表与UnicodePropertyValue的值或值别名或UnicodePropertyName的SourceText给出的Unicode属性值或值别名的Unicode代码点列表不同，则会出现语法错误。表56或表57对应表的“属性值和别名”列。 UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue 如果作为LoneUnicodePropertyNameOrValue的SourceText的Unicode代码点列表与作为表56的“属性值和别名”列中列出的Unicode常规类别或常规类别别名的Unicode代码点列表不同，则会出现语法错误。 ，也不会在表55的“属性名称和别名”列中列出二进制属性或二进制属性别名。 21.2.1.2 SS: CapturingGroupNumber DecimalEscape :: NonZeroDigit 返回NonZeroDigit的MV。 DecimalEscape :: NonZeroDigit DecimalDigits 令 n 为DecimalDigits中的代码点数。 返回 (NonZeroDigit的MV × 10n)加上DecimalDigits的MV。 11.8.3中定义了“ NonZeroDigit的MV”和“ DecimalDigits的MV”。 21.2.1.3 SS: IsCharacterClass ClassAtom :: - ClassAtomNoDash :: SourceCharacter but not one of \\ or ] or - ClassEscape :: b ClassEscape :: - ClassEscape :: CharacterEscape 返回 false. ClassEscape :: CharacterClassEscape 返回 true. 21.2.1.4 SS: CharacterValue ClassAtom :: - 返回U + 002D的代码点值（减号）。 ClassAtomNoDash :: SourceCharacter but not one of \\ or ] or - 令 ch 为SourceCharacter匹配的代码点。 返回ch的代码点值。 ClassEscape :: b 返回U + 0008（退格）的代码点值。 ClassEscape :: - 返回U + 002D的代码点值(减号). CharacterEscape :: ControlEscape 返回根据表53的代码点值。 表53：ControlEscape代码点值 ControlEscape 代码点值 代码点 Unicode名称 符号 t 9 U+0009 CHARACTER TABULATION \\ n 10 U+000A LINE FEED (LF) \\ v 11 U+000B LINE TABULATION \\ f 12 U+000C FORM FEED (FF) \\ r 13 U+000D CARRIAGE RETURN (CR) \\ CharacterEscape :: c ControlLetter 令 ch 为ControlLetter匹配的代码点。 令 i 为ch的代码点值。 返回将i除以32的余数。 CharacterEscape :: 0 [lookahead ∉ DecimalDigit] 返回U + 0000（NULL）的代码点值。 注：\\0代表字符，不能跟十进制数字。 CharacterEscape :: HexEscapeSequence 返回十六进制转义序列SV的代码单元的数值。 RegExpUnicodeEscapeSequence :: u LeadSurrogate \\u TrailSurrogate 令 lead 为LeadSurrogate的CharacterValue。 令 trail 为TrailSurrogate的CharacterValue。 令 cp 为 UTF16Decode(lead, trail). 返回cp的代码点值。 RegExpUnicodeEscapeSequence :: u LeadSurrogate 返回LeadSurrogate的CharacterValue。 RegExpUnicodeEscapeSequence :: u TrailSurrogate 返回TrailSurrogate的CharacterValue。 RegExpUnicodeEscapeSequence :: u NonSurrogate 返回TrailSurrogate的CharacterValue。 RegExpUnicodeEscapeSequence :: u Hex4Digits 返回Hex4Digits的MV RegExpUnicodeEscapeSequence :: u{ CodePoint } 返回CodePoint的MV LeadSurrogate :: Hex4Digits TrailSurrogate :: Hex4Digits NonSurrogate :: Hex4Digits 返回HexDigits的MV。 CharacterEscape :: IdentityEscape 令 ch 为与IdentityEscape匹配的代码点。 返回ch的代码点值。 21.2.1.5 SS: SourceText UnicodePropertyNameCharacters :: UnicodePropertyNameCharacter UnicodePropertyNameCharacters UnicodePropertyValueCharacters :: UnicodePropertyValueCharacter UnicodePropertyValueCharacters 返回按源文本顺序列出与此生产匹配的源文本中的Unicode代码点的列表。 21.2.1.6 SS: StringValue RegExpIdentifierName[U] :: RegExpIdentifierStart[?U] RegExpIdentifierName[?U] RegExpIdentifierPart[?U] 返回由对应于RegExpIdentifierName的代码单元序列组成的String值。在确定序列时，首先用RegExpUnicodeEscapeSequence表示的代码点替换\\ RegExpUnicodeEscapeSequence的出现，然后通过UTF16Encoding每个代码点将整个RegExpIdentifierName的代码点转换为代码单元。 21.2.2 模式语义 使用下面描述的过程将正则表达式模式转换为内部过程。鼓励实现使用比下面列出的算法更有效的算法，只要结果相同即可。内部过程用作RegExp对象的[[RegExpMatcher]]内部插槽的值。 模式是BMP模式还是Unicode模式，具体取决于其关联标志是否包含“ u”。 BMP模式与解释为由一系列16位值组成的字符串匹配，这些值是基本多语言平面范围内的Unicode代码点。 Unicode模式与解释为由使用UTF-16编码的Unicode代码点组成的字符串匹配。在描述BMP模式的行为的上下文中，“字符”表示单个16位Unicode BMP代码点。在描述Unicode模式的行为的上下文中，“字符”表示UTF-16编码的代码点（6.1.4）。在任一上下文中，“字符值”是指相应的未编码代码点的数值。 定义Pattern的语法和语义，就好像Pattern的源代码是SourceCharacter值的列表，其中每个SourceCharacter对应于一个Unicode代码点。如果BMP模式包含非BMP SourceCharacter，则整个模式使用UTF-16进行编码，并且该编码的各个代码单元用作列表的元素。 注 例如，将源文本中表示的模式视为单个非BMP字符U + 1D11E（音乐符号G CLEF）。解释为Unicode模式，它将是由单个代码点0x1D11E组成的单个元素（字符）列表。但是，将其解释为BMP模式后，首先对其进行UTF-16编码，以生成一个由两个单元组成的List，该List由代码单元0xD834和0xDD1E组成。 模式作为ECMAScript字符串值传递给RegExp构造函数，其中非BMP字符采用UTF-16编码。例如，以字符串值表示的单字符MUSICAL SYMBOL G CLEF模式是长度为2的字符串，其元素是代码单元0xD834和0xDD1E。因此，无需进一步转换字符串即可将其处理为由两个模式字符组成的BMP模式。但是，要将其处理为Unicode模式，必须在生成由单个模式字符组成的List（代码点U + 1D11E）时使用UTF16Decode。 一个实现可能实际上并没有执行往返于UTF-16的转换，但是此规范的语义要求模式匹配的结果就像执行了此类转换一样。 21.2.2.1 表示法 以下说明使用以下变量： 输入是一个列表，该列表按顺序包含由正则表达式模式匹配的所有所有字符。每个字符都可以是一个代码单元或一个代码点，具体取决于所涉及的图案类型。输入法Input [n]表示Input的第n个字符，其中n的范围可以在0（含）和InputLength（不含）之间。 InputLength是输入中的字符数。 NcapturingParens是模式中左捕捉括号的总数（即Atom ::（GroupSpecifier Disjunction）解析节点的总数）。左捕获括号是与Atom ::（GroupSpecifier Disjunction）产生的（终端匹配的任何（模式字符）。 如果RegExp对象的[[OriginalFlags]]内部插槽包含“ s”，则DotAll为true，否则为false。 如果RegExp对象的[[OriginalFlags]]内部插槽包含“ i”，则IgnoreCase为true，否则为false。 如果RegExp对象的[[OriginalFlags]]内部插槽包含“ m”，则Multiline为true，否则为false。 如果RegExp对象的[[OriginalFlags]]内部插槽包含“ u”，则Unicode为true，否则为false。 此外，以下描述使用以下内部数据结构： CharSet是数学上的字符集，取决于Unicode标志的状态，可以是代码单位或代码点。 “所有字符”是指所有代码单位值或所有代码点值，也取决于Unicode的状态。 一个State是一个有序对（endIndex，捕获），其中endIndex是一个整数，捕获是NcapturingParens值的列表。状态用于表示正则表达式匹配算法中的部分匹配状态。 endIndex是一个值，加上该模式到目前为止匹配的最后一个输入字符的索引，而captures保存捕获括号的结果。捕获的第n个元素是一个List，代表通过第n组捕获括号获得的值，或者如果尚未达到第n组捕获括号，则为undefined。由于回溯，许多状态可能在匹配过程的任何时候被使用。 MatchResult要么是状态，要么是表示匹配失败的特殊令牌失败。 Continuation过程是一个内部闭包（即一个内部过程，其中一些参数已绑定到值），该闭包采用一个State参数并返回MatchResult结果。如果内部闭包引用了在创建闭包的函数中绑定的变量，则闭包将使用这些变量在创建闭包时具有的值。 Continuation尝试将模式的其余部分（由闭包的已绑定参数指定）与Input匹配，从其State参数给出的中间状态开始。如果比赛成功，Continuation会返回到达的最终状态；如果匹配失败，则Continuation返回失败。 Matcher过程是一个内部闭包，它使用两个参数（一个State和一个Continuation）并返回MatchResult结果。 Matcher尝试从其State参数给定的中间状态开始，将模式的中间子模式（由闭包的已绑定参数指定）与Input进行匹配。 Continuation参数应该是与模式的其余部分匹配的闭包。在匹配模式的子模式以获得新的状态之后，匹配器随后在该新状态上调用Continuation以测试模式的其余部分是否也可以匹配。如果可以，则匹配器返回由Continuation返回的状态。如果不是，则匹配器可能会在其选择点尝试不同的选择，重复调用Continuation，直到成功或所有可能性用尽。 AssertionTester过程是一个内部闭包，它接受State参数并返回布尔结果。断言测试器针对Input中的当前位置测试特定条件（由闭包的已绑定参数指定），如果条件匹配则返回true，否则返回false。 21.2.2.2 模式 Pattern :: Disjunction 的评估如下： 用+1作为方向参数计算析取，得到一个匹配器m。 返回一个内部闭包，它接受两个参数，一个String str和一个整数索引，并执行以下步骤： 断言：index ≤ str的长度。 若 Unicode 是 true, 令序列组成的输入是一个列表的代码点str解读为utf - 16编码(6.1.4)Unicode字符串。否则,令输入是一个列表的代码单元组成的序列str。输入的元素将为整个算法用于21.2.2。输入的每个元素都被认为是一个字符。 令InputLength输入中包含的字符数。这个变量将为整个算法用于21.2.2。 令 listIndex 为从str的元素索引中得到的字符的输入的索引。 令 c 为一个延续，它总是以成功的MatchResult返回它的状态参数。 令 cap 为NcapturingParens未定义值的列表，通过NcapturingParens索引1。 令 x 为 the State (listIndex, cap). 调用 m(x, c) 并且返回它的结果。 注：模式计算(“编译”)一个内部过程值。然后，RegExpBuiltinExec可以将此过程应用于字符串和字符串中的偏移量，以确定模式是否将从字符串中的偏移量开始匹配，如果匹配，则捕获括号的值将是什么。21.2.2中的算法是这样设计的:编译一个模式可能会抛出一个SyntaxError异常；另一方面，一旦成功地编译了模式，应用产生的内部过程来查找字符串中的匹配就不能抛出异常(除了主机定义的任何异常，如内存不足) 21.2.2.3 析取 与参数的方向。 产生式 Disjunction :: Alternative 如下解释执行： 用参数direction对Alternative求值，得到一个Matcher m1。 返回 m. 产生式 Disjunction :: Alternative | Disjunction 如下解释执行： 用参数direction对Alternative求值，得到一个Matcher m1。 用参数direction对Disjunction求值，得到一个Matcher m2。 返回一个内部Matcher闭包，它接受两个参数，一个状态x，一个延续c，并在计算时执行以下步骤: 调用 m1(x, c) 并且，令 r 为它自己的结果 若 r 不是 failure，返回 r. 调用 m2(x, c) 并且返回它自己的结果 注 |正则表达式运算符将两种选择分开。模式首先尝试匹配左侧的Alternative（随后是正则表达式的后继）；如果失败，它将尝试匹配正确的Disjunction（紧随其后的是正则表达式）。如果左侧的Alternative，右侧的Disjunction和续集都具有选择点，则尝试尝试续集中的所有选择，然后再转到左侧的Alternative中的下一个选项。如果左侧“选择”中的选择已用尽，则尝试使用右侧“分离”而不是左侧“选择”。 |跳过的模式的一部分内的任何捕获括号。产生未定义的值，而不是字符串。因此，例如 /a|ab/.exec(\"abc\") 返回结果“ a”而不是“ ab”。此外， /((a)|(ab))((c)|(bc))/.exec(\"abc\") 返回数组 [\"abc\", \"a\", \"a\", undefined, \"bc\", undefined, \"bc\"] 并不是 [\"abc\", \"ab\", undefined, \"ab\", \"c\", \"c\", undefined] 尝试两种选择的顺序与方向的值无关。 21.2.2.4 选择项 带有参数方向。 产生式 Alternative :: [empty] 如下解释执行： 返回一个Matcher，它接受两个参数，即State x和Continuation c，并返回调用c（x）的结果。 产生式 Alternative :: Alternative Term 如下解释执行： 用参数direction对Alternative求值，得到一个Matcher m1。 用参数direction对Term求值，得到一个Matcher m2。 若 direction 等于 +1，那么 返回一个内部Matcher闭包，该闭包采用两个参数（State x和Continuation c），并在解释执行时执行以下步骤： 令 d 为一个接受State参数y并返回调用m2（y，c）的结果的Continuation。 调用 m1(x, d)并且返回它的结果 否则， 1. 断言：direction 等于 -1. 2. 返回一个内部Matcher闭包，该闭包接受两个参数（State x和Continuation c），并在评估时执行以下步骤： 1. 令 d 为一个采用State参数y并返回调用m1（y，c）的结果的Continuation。 2. 调用 m2(x, d)并且返回它的结果 注：连续字词尝试同时匹配Input的连续部分。当direction等于+1时，如果左侧的Alternative，右侧的Term和正则表达式的后代都具有选择点，则在继续选择右侧Term中的下一个选项之前，将尝试该续集中的所有选择，并且所有在继续进行左侧“替代”中的下一个选择之前，请先尝试正确的“术语”中的选择。当direction等于-1时，Alternate和Term的评估顺序颠倒。 21.2.2.5 匹配项 带有参数direction. 产生式 Term :: Assertion 如下解释执行： 返回一个内部Matcher闭包，该闭包接受两个参数（状态x和连续性c），并在评估时执行以下步骤： 解释执行 Assertion 以获得 AssertionTester t。 调用 t(x) 并且令 r 为得到的布尔值。 若 r 是 false，返回 failure. 调用 c(x)并且返回它的结果 注：AssertionTester 是独立于 direction 的。 产生式 Term :: Atom 如下解释执行： 返回 Matcher，即是用参数 direction 对Atom求值的结果。 产生式 Term :: Atom Quantifier 如下解释执行： 用参数direction对Atom求值，得到一个Matcher m。 解释执行量词以获取三个结果：最小整数，最大整数（或∞）和布尔值greedy。 断言：若 max 是 finite，那么最大值不小于最小值。 令 parenIndex 为整个正则表达式中出现在该术语左侧的左捕获括号的数量。这是此术语之前或附带的Atom ::（GroupSpecifier Disjunction）解析节点的总数。 令 parenCount 为 Atom 中左捕捉括号的数量。这是Atom包围的Atom ::（GroupSpecifier Disjunction）解析节点的总数。 返回一个内部Matcher闭包，该闭包接受两个参数（状态x和连续性c），并在评估时执行以下步骤： 调用 RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount)并且返回它的结果 21.2.2.5.1 RS: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount ) 抽象操作RepeatMatcher采用八个参数，一个Matcher m，一个整数min，一个整数（或∞），一个布尔值greedy，一个State x，一个Continuation c，一个整数parenIndex和一个整数parenCount，并执行以下步骤。 ： 若 max 是 zero，返回 c(x). 令 d 为内部Continuation闭包，它接受一个State参数y并在解释执行时执行以下步骤： 若 min为零，y的endIndex等于x的endIndex，返回 failure. 若 min 是零, 令 min2 为零; 否则 令 min2 为 min - 1. 若 max 是 ∞, 令 max2 为 ∞; 否则 令 max2 为 max - 1. 调用 RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount)并且返回它的结果 令 cap 为 x的捕获列表的副本。 对于满足parenIndex 令 e 为x的endIndex。 令 xr 为 the State (e, cap). 若 min 不是 zero，返回 m(xr, d). 若 greedy 是 false，那么 调用 c(x)，并且令 z 为其结果。 若 z 不是 failure，返回 z. 调用 m(xr, d)并且返回它的结果 调用 m(xr, d) 并且令 z 为它的结果。 若 z 不是 failure，返回 z. 调用 c(x)并且返回它的结果 注 1 原子后面跟着量词的次数重复由量词指定的次数。量词可以是非贪婪的，在这种情况下，Atom模式在仍与续集匹配的情况下被重复最少的次数，也可以是贪婪的情况，在这种情况下，Atom样式在仍与续集匹配的情况下，被重复尽可能多的次数。 Atom模式是重复的，而不是它匹配的输入字符序列，因此Atom的不同重复可以匹配不同的输入子字符串。 注 2 如果Atom和正则表达式的后续都有选择点，则首先匹配Atom尽可能多的次数(如果非贪婪，则匹配次数越少越好)。在Atom的最后一次重复中，在进行下一个选择之前，将尝试后续中的所有选择。在原子的次(n - 1)次重复中，在进行下一个选择之前，尝试原子的最后(n)次重复中的所有选择；在这一点上，原子的重复或多或少是可能的；在进行(n - 1)st原子重复的下一个选择之前(同样，从尽可能少的或尽可能多的开始)，这些都已耗尽。 比较 /a[a-z]{2,4}/.exec(\"abcdefghi\") 返回“ abcde” /a[a-z]{2,4}?/.exec(\"abcdefghi\") 返回“ abc”。 还考虑 /(aa|aabaac|ba|b|c)*/.exec(\"aabaac\") 根据上面的选择点排序，它返回数组 [\"aaba\", \"ba\"] 而不是以下任何一个： [\"aabaac\", \"aabaac\"] [\"aabaac\", \"c\"] 选择点的上述排序可用于编写一个正则表达式，该正则表达式计算两个数字的最大公约数（以一元表示法表示）。以下示例计算的gcd为10和15： \"aaaaaaaaaa,aaaaaaaaaaaaaaa\".replace(/^(a+)\\1*,\\1+$/, \"$1\") 它以一元符号“ aaaaa”返回gcd。 注 3 每次重复Atom时，RepeatMatcher的步骤4都会清除Atom的捕获。我们可以在正则表达式中看到它的行为 /(z)((a+)?(b+)?(c))*/.exec(\"zaacbbbcac\") 返回数组 [\"zaacbbbcac\", \"z\", \"ac\", \"a\", undefined, \"c\"] 并不是 [\"zaacbbbcac\", \"z\", \"ac\", \"a\", \"bbb\", \"c\"] 因为最外面的*的每次迭代都会清除量化的Atom中包含的所有捕获的字符串，在这种情况下，该原子包括编号为2、3、4和5的捕获字符串。 注 4 RepeatMatcher d闭包的第1步指出，一旦满足了最小重复次数，则不再考虑与空字符序列匹配的Atom扩展。这样可以防止正则表达式引擎陷入以下模式的无限循环： /(a)/.exec(\"b\") 或者稍微复杂一点： /(a*)b\\1+/.exec(\"baaaac\") 返回数组 [\"b\", \"\"] 21.2.2.6 断言 产生式 Assertion :: ^ 如下解释执行： 返回内部AssertionTester闭包，它带有State参数x并在评估时执行以下步骤： 令 e 为x的endIndex。 若 e 是 zero，返回 true. 若 Multiline 是 false，返回 false. 若字符输入[e - 1]是LineTerminator之一，返回 true. 返回 false. 注：即使当y标记与模式一起使用时，^也始终只匹配输入的开头，或者(如果Multiline为真)匹配一行的开头。 产生式 Assertion :: $ 如下解释执行： 返回一个内部AssertionTester闭包，它接受一个状态参数x，并在计算时执行以下步骤: 令 e 为x的endIndex。 若 e 等于 InputLength，返回 true. 若 Multiline 是 false，返回 false. 若字符输入[e] 是LineTerminator之一，返回 true. 返回 false 产生式 Assertion :: \\ b 如下解释执行： 返回内部AssertionTester闭包，它带有State参数x并在评估时执行以下步骤： 令 e 为x的endIndex。 调用 IsWordChar(e - 1)，并且令 a 为布尔结果。 调用 IsWordChar(e)，并且令 b 为布尔结果。 若 a 是 true，并且 b 是 false，返回 true. 若 a 是 false，并且 b 是 true，返回 true. 返回 false. 产生式 Assertion :: \\ B 如下解释执行： 返回内部AssertionTester闭包，它带有State参数x并在评估时执行以下步骤： 令 e 为x的endIndex。 调用 IsWordChar(e - 1)，并且令 a 为布尔结果。 调用 IsWordChar(e)，并且令 b 为布尔结果。 若 a 是 true，并且 b 是 false，返回 false. 若 a 是 false，并且 b 是 true，返回 false. 返回 true. 产生式 Assertion :: ( ? = Disjunction ) 如下解释执行： 用+1作为其direction参数评估Disjunction，以获得Matcher m。 返回一个内部Matcher闭包，它使用两个参数（状态x和连续性c），并执行以下步骤： 令 d 为始终返回其State参数作为成功MatchResult的Continuation。 调用 m(x, d)，并且令 r 为其结果。 若 r 是 failure，返回 failure. 令 y 为 r 的 State。 令 cap 为 y 捕获列表。 令 xe 为x的endIndex。 令 z 为 State (xe, cap). 调用 c(z)并且返回它的结果 产生式 Assertion :: ( ? ! Disjunction ) 如下解释执行： 用+1作为其direction参数评估Disjunction，以获得Matcher m。 返回一个内部Matcher闭包，它使用两个参数（状态x和连续性c），并执行以下步骤： 令 d 为始终返回其State参数作为成功MatchResult的Continuation。 调用 m(x, d)，并且令 r 为其结果. 若 r 不是 failure，返回 failure. 调用 c(x)并且返回它的结果 产生式 Assertion :: ( ? 以 -1 作为 direction 参数求 Disjunction，以获得Matcher m。 返回一个内部Matcher闭包，它使用两个参数（状态x和连续性c），并执行以下步骤： 令 d 为始终返回其State参数作为成功MatchResult的Continuation。 调用 m(x, d)，并且令 r 为其结果。 若 r 是 failure，返回 failure. 令 y 为 r 的 State。 令 cap 为 y 的捕获列表。 令 xe 为 x 的endIndex。 令 z 为 State (xe, cap). 调用 c(z)并且返回它的结果 产生式 Assertion :: ( ? 以 -1 作为 direction 参数求 Disjunction，以获得Matcher m。 返回一个内部Matcher闭包，它使用两个参数（状态x和连续性c），并执行以下步骤： 令 d 为始终返回其State参数作为成功MatchResult的Continuation。 调用 m(x, d)，并且令 r 为其结果。 若 r 不是 failure，返回 failure. 调用 c(x)并且返回它的结果 21.2.2.6.1 RS: WordCharacters ( ) 抽象操作WordCharacters执行以下步骤： 令 A 为包含六十三个字符的一组字符： a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 0 1 2 3 4 5 6 7 8 9 _ 令 U 为一个空集。 对于不在A中Canonicalize（c）在A中的每个字符c，请将c添加到U中。 断言：除非Unicode和IgnoreCase都为true，否则U为空。 将集合U中的字符添加到集合A中。 返回 A. 21.2.2.6.2 RS: IsWordChar ( e ) 抽象运算IsWordChar使用整数参数e并执行以下步骤： 若 e is -1 or e 是 InputLength，返回 false. 令 c 为字符输入[e]. 令 wordChars 为 ! WordCharacters() 的结果。 若 c 在 wordChars 中，返回 true. 返回 false. 21.2.2.7 量词 产生式 Quantifier :: QuantifierPrefix 如下解释执行： 评估QuantifierPrefix可获得两个结果：最小整数和最大整数（或∞）。 返回三个结果min，max和true。 产生式 Quantifier :: QuantifierPrefix ? 如下解释执行： 评估QuantifierPrefix可获得两个结果：最小整数和最大整数（或∞）。 返回三个结果min，max和false。 产生式 QuantifierPrefix :: * 如下解释执行： 返回两个结果为0和∞。 产生式 QuantifierPrefix :: + 如下解释执行： 返回两个结果1和∞。 产生式 QuantifierPrefix :: ? 如下解释执行： 返回两个结果0和1。 产生式 QuantifierPrefix :: { DecimalDigits } 如下解释执行： 令 i 为DecimalDigits的MV（请参见11.8.3）。 返回 i 和 i 两个结果。 产生式 QuantifierPrefix :: { DecimalDigits , } 如下解释执行： 令 i 为DecimalDigits的MV。 返回两个结果i和∞。 产生式 QuantifierPrefix :: { DecimalDigits , DecimalDigits } 如下解释执行： 令 i 为第一个DecimalDigits的MV。 令 j 为第二个DecimalDigits的MV。 返回两个结果i和j。 21.2.2.8 原子 带有参数direction. 产生式 Atom :: PatternCharacter 如下解释执行： 令 ch 为由PatternCharacter匹配的字符。 令 A 为包含字符ch的单元素CharSet。 调用 CharacterSetMatcher(A, false, direction)并返回其Matcher结果。 产生式 Atom :: . 如下解释执行： 若 DotAll 是 true，那么 令 A 为所有字符的集合。 除此之外, 令 A 为除LineTerminator外的所有字符的集合。 调用 CharacterSetMatcher(A, false, direction)并返回其Matcher结果。 产生式 Atom :: \\ AtomEscape 如下解释执行： 评估CharacterClass以获得CharSet A和布尔值反转。 调用 CharacterSetMatcher(A, invert, direction)并返回其Matcher结果。 产生式 Atom :: ( GroupSpecifier Disjunction ) 如下解释执行： 用参数direction对Disjunction求值，得到一个Matcher m。 令 parenIndex 为整个正则表达式中位于此Atom左侧的左捕获括号的数量。这是此Atom之前或包含Atom ::（GroupSpecifier Disjunction）解析节点的总数。 返回一个内部Matcher闭包，它使用两个参数（状态x和连续性c），并执行以下步骤： 令 d 为内部Continuation闭包，它接受一个State参数y并执行以下步骤： 令 cap 为y的捕获列表的副本。 令 xe 为x的endIndex。 令 ye 为 y 的 endIndex. 若 direction 等于 +1，那么 断言：xe ≤ ye. 令 s 为一个新的列表，其元素是从索引xe（含）到ye（不含）的Input字符。 否则， 断言：direction 等于 -1. 断言：ye ≤ xe. 令 s 为一个新的列表，其元素是从ye（含）到xe（不含）的Input字符。 设置 cap[parenIndex + 1] 为 s. 令 z 为 State (ye, cap). 调用 c(z)并且返回它的结果 调用 m(x, d)并且返回它的结果 产生式 Atom :: ( ? : Disjunction ) 如下解释执行： 返回 Matcher，即是用 direction 参数解析执行 Disjunction 的结果。 21.2.2.8.1 RS: CharacterSetMatcher ( A, invert, direction ) 抽象操作CharacterSetMatcher接受三个参数，一个字符集 a，一个Boolean标志 invert，一个整数 direction，并执行以下步骤： 返回一个内部Matcher闭包，它接受两个参数，一个状态x，一个延续c，并在计算时执行以下步骤： 令 e 为 x 的endIndex。 令 f 为 e + direction. 若 f InputLength，返回 failure. 令 index 为 min(e, f). 令 ch 为字符输入[index]. 令 cc 为 Canonicalize(ch). 若 invert 是 false，那么 若集合A中不存在这样一个 Canonicalize(a) 是 cc，返回 failure. 否则， 断言：invert 是 true. 若集合A中不存在这样一个 Canonicalize(a) 是 cc，返回 failure. 令 cap 为 x 的 captures 列表。 令 y 为 State (f, cap)。 调用 c(y)并且返回它的结果。 21.2.2.8.2 RS: Canonicalize ( ch ) 规范化的抽象操作采用字符参数ch，并执行以下步骤: 若 IgnoreCase 是 false，返回 ch. 若 Unicode 是 true，那么 如果Unicode字符数据库的CaseFolding.txt文件为ch提供了一个简单或常见的大小写折叠映射，则返回将该映射应用到ch的结果。 返回 ch. 否则， 断言：ch 是 UTF-16 代码单元 令 s 为由单个代码单元ch组成的字符串值。 令 u 为与对String.prototype执行算法得到的结果相同。使用s作为这个值的toUpperCase。 断言：Type(u) 是 String. 若 u 不包含单个代码单元，返回 ch. 令 cu 为u的单个代码单元元素。 若 ch ≥ 128 的数值和 cu 返回 cu. 注 1 形式（Disjunction）的括号既可以将Disjunction模式的各个组成部分组合在一起，又可以保存匹配结果。结果可以用在反向引用中（\\后跟一个非零的十进制数字），可以在替换字符串中引用，也可以从匹配内部过程的正则表达式中作为数组的一部分返回。要禁止捕获括号，请改用（ ? : Disjunction）形式。 注 2 形式（ ? = Disjunction）指定零宽度的正向超前。为了使它成功，“分离”中的模式必须在当前位置匹配，但是在匹配后继序列之前，当前位置不会前进。如果“分离”可以几种方式在当前位置匹配，则仅尝试第一个。与其他正则表达式运算符不同，它没有回溯到（？= form（此异常行为是从Perl继承的）。仅当Disjunction包含捕获括号并且模式的后继包含对那些捕获的反向引用时，才有意义。 例如， /(?=(a+))/.exec(\"baaabac\") 在第一个b之后立即匹配空String，因此返回数组： [\"\", \"aaa\"] 为了说明缺乏回溯到前瞻性，请考虑： /(?=(a+))a*b\\1/.exec(\"baaabac\") 该表达式返回 [\"aba\", \"a\"] 并不是： [\"aaaba\", \"a\"]. 注 3 形式（?!Disjunction）指定零宽度的负前瞻。为了使它成功，“分离”内的模式必须在当前位置不匹配。在匹配续集之前，当前位置不会前进。析取可以包含捕获的括号，但是对它们的反向引用仅在析取本身内部才有意义。对模式中其他位置的这些捕获括号的反向引用始终返回未定义的，因为负前瞻必须失败才能使模式成功。例如， /(.?)a(?!(a+)b\\2c)\\2(.)/.exec(\"baaabaac\") 查找a，而不是紧随其后的是a的正数n，a b，另一个n a（由第一个\\ 2指定）和a。第二个\\ 2在负前瞻之外，因此它与undefined匹配，因此总是成功。整个表达式返回数组： [\"baaabaac\", \"ba\", undefined, \"abaac\"] 注 4 在Unicode为true的情况下，如果大小写无关紧要，则在比较所有字符之前，立即使用Unicode标准提供的简单映射对所有字符进行隐式大小写折叠。简单映射始终映射到单个代码点，因此不会映射例如“ß”（U + 00DF）到“ SS”。但是，它可能会将基本拉丁语范围之外的代码点映射到例如“ ſ”（U + 017F）到“ s”内的字符。如果Unicode为false，则不会映射此类字符。这样可以防止Unicode代码点（例如U + 017F和U + 212A）匹配正则表达式（例如/ [a-z] / i），但它们将匹配/ [a-z] / ui。 21.2.2.8.3 RS: UnicodeMatchProperty ( p ) 抽象操作UnicodeMatchProperty采用参数p（它是Unicode代码点列表），并执行以下步骤： 断言：p是Unicode代码点列表，与Unicode代码点列表相同，后者是表54或表55的“属性名称和别名”列中列出的Unicode属性名称或属性别名。 令 c 为 在相应行的“规范属性名称”列中给出的p的规范属性名称。 返回 c 的Unicode代码点列表。 实现必须支持表54和表55中列出的Unicode属性名称和别名。为确保互操作性，实现不得支持任何其他属性名称或别名。 注 1 例如，Script_Extensions（属性名称）和scx（属性别名）有效，但script_extensions或Scx无效。 注 2 列出的属性构成UTS18 RL1.2要求的超集 表54：非二进制Unicode属性别名及其规范属性名称 属性名称和别名 规范属性名称 General_Category``gc General_Category Script``sc Script Script_Extensions``scx Script_Extensions 表55：二进制Unicode属性别名及其规范属性名称 属性名称和别名 规范属性名称 ASCII ASCII ASCII_Hex_Digit``AHex ASCII_Hex_Digit Alphabetic``Alpha Alphabetic Any Any Assigned Assigned Bidi_Control``Bidi_C Bidi_Control Bidi_Mirrored``Bidi_M Bidi_Mirrored Case_Ignorable``CI Case_Ignorable Cased Cased Changes_When_Casefolded``CWCF Changes_When_Casefolded Changes_When_Casemapped``CWCM Changes_When_Casemapped Changes_When_Lowercased``CWL Changes_When_Lowercased Changes_When_NFKC_Casefolded``CWKCF Changes_When_NFKC_Casefolded Changes_When_Titlecased``CWT Changes_When_Titlecased Changes_When_Uppercased``CWU Changes_When_Uppercased Dash Dash Default_Ignorable_Code_Point``DI Default_Ignorable_Code_Point Deprecated``Dep Deprecated Diacritic``Dia Diacritic Emoji Emoji Emoji_Component Emoji_Component Emoji_Modifier Emoji_Modifier Emoji_Modifier_Base Emoji_Modifier_Base Emoji_Presentation Emoji_Presentation Extended_Pictographic Extended_Pictographic Extender``Ext Extender Grapheme_Base``Gr_Base Grapheme_Base Grapheme_Extend``Gr_Ext Grapheme_Extend Hex_Digit``Hex Hex_Digit IDS_Binary_Operator``IDSB IDS_Binary_Operator IDS_Trinary_Operator``IDST IDS_Trinary_Operator ID_Continue``IDC ID_Continue ID_Start``IDS ID_Start Ideographic``Ideo Ideographic Join_Control``Join_C Join_Control Logical_Order_Exception``LOE Logical_Order_Exception Lowercase``Lower Lowercase Math Math Noncharacter_Code_Point``NChar Noncharacter_Code_Point Pattern_Syntax``Pat_Syn Pattern_Syntax Pattern_White_Space``Pat_WS Pattern_White_Space Quotation_Mark``QMark Quotation_Mark Radical Radical Regional_Indicator``RI Regional_Indicator Sentence_Terminal``STerm Sentence_Terminal Soft_Dotted``SD Soft_Dotted Terminal_Punctuation``Term Terminal_Punctuation Unified_Ideograph``UIdeo Unified_Ideograph Uppercase``Upper Uppercase Variation_Selector``VS Variation_Selector White_Space``space White_Space XID_Continue``XIDC XID_Continue XID_Start``XIDS XID_Start 21.2.2.8.4 RS: UnicodeMatchPropertyValue ( p, v ) 抽象操作UnicodeMatchPropertyValue具有两个参数p和v，每个参数都是Unicode代码点列表，并执行以下步骤： 断言：p是Unicode代码点列表，与Unicode代码点列表相同，后者是表54的“规范属性名称”列中列出的规范的，未混叠的Unicode属性名称。 断言：v是Unicode代码点列表，与Unicode代码点列表相同，后者是表56或表57的“属性值和别名”列中列出的Unicode属性p的属性值或属性值别名。 令 value 为 v 的规范属性值（在相应行的“规范属性值”列中给出）。 返回Unicode代码点列表。 实现必须支持表56和表57中列出的Unicode属性值名称和别名。为确保互操作性，实现不得支持任何其他属性值名称或别名。 注 1 例如，Xpeo和Old_Persian是有效的Script_Extensions值，但xpeo和Old Persian不是。 注 2 此算法不同于UAX44中列出的符号值的匹配规则：不区分大小写，空格，U + 002D（减号）和U + 005F（下划线），并且不支持Is前缀。 表56：Unicode属性 General_Category的值别名和规范值。 属性值和别名 规范属性值 Cased_Letter``LC Cased_Letter Close_Punctuation``Pe Close_Punctuation Connector_Punctuation``Pc Connector_Punctuation Control``Cc``cntrl Control Currency_Symbol``Sc Currency_Symbol Dash_Punctuation``Pd Dash_Punctuation Decimal_Number``Nd``digit Decimal_Number Enclosing_Mark``Me Enclosing_Mark Final_Punctuation``Pf Final_Punctuation Format``Cf Format Initial_Punctuation``Pi Initial_Punctuation Letter``L Letter Letter_Number``Nl Letter_Number Line_Separator``Zl Line_Separator Lowercase_Letter``Ll Lowercase_Letter Mark``M``Combining_Mark Mark Math_Symbol``Sm Math_Symbol Modifier_Letter``Lm Modifier_Letter Modifier_Symbol``Sk Modifier_Symbol Nonspacing_Mark``Mn Nonspacing_Mark Number``N Number Open_Punctuation``Ps Open_Punctuation Other``C Other Other_Letter``Lo Other_Letter Other_Number``No Other_Number Other_Punctuation``Po Other_Punctuation Other_Symbol``So Other_Symbol Paragraph_Separator``Zp Paragraph_Separator Private_Use``Co Private_Use Punctuation``P``punct Punctuation Separator``Z Separator Space_Separator``Zs Space_Separator Spacing_Mark``Mc Spacing_Mark Surrogate``Cs Surrogate Symbol``S Symbol Titlecase_Letter``Lt Titlecase_Letter Unassigned``Cn Unassigned Uppercase_Letter``Lu Uppercase_Letter 表57：Unicode属性Script 和Script_Extensions Property value and aliases Canonical property value Adlam``Adlm Adlam Ahom``Ahom Ahom Anatolian_Hieroglyphs``Hluw Anatolian_Hieroglyphs Arabic``Arab Arabic Armenian``Armn Armenian Avestan``Avst Avestan Balinese``Bali Balinese Bamum``Bamu Bamum Bassa_Vah``Bass Bassa_Vah Batak``Batk Batak Bengali``Beng Bengali Bhaiksuki``Bhks Bhaiksuki Bopomofo``Bopo Bopomofo Brahmi``Brah Brahmi Braille``Brai Braille Buginese``Bugi Buginese Buhid``Buhd Buhid Canadian_Aboriginal``Cans Canadian_Aboriginal Carian``Cari Carian Caucasian_Albanian``Aghb Caucasian_Albanian Chakma``Cakm Chakma Cham``Cham Cham Cherokee``Cher Cherokee Common``Zyyy Common Coptic``Copt``Qaac Coptic Cuneiform``Xsux Cuneiform Cypriot``Cprt Cypriot Cyrillic``Cyrl Cyrillic Deseret``Dsrt Deseret Devanagari``Deva Devanagari Dogra``Dogr Dogra Duployan``Dupl Duployan Egyptian_Hieroglyphs``Egyp Egyptian_Hieroglyphs Elbasan``Elba Elbasan Ethiopic``Ethi Ethiopic Georgian``Geor Georgian Glagolitic``Glag Glagolitic Gothic``Goth Gothic Grantha``Gran Grantha Greek``Grek Greek Gujarati``Gujr Gujarati Gunjala_Gondi``Gong Gunjala_Gondi Gurmukhi``Guru Gurmukhi Han``Hani Han Hangul``Hang Hangul Hanifi_Rohingya``Rohg Hanifi_Rohingya Hanunoo``Hano Hanunoo Hatran``Hatr Hatran Hebrew``Hebr Hebrew Hiragana``Hira Hiragana Imperial_Aramaic``Armi Imperial_Aramaic Inherited``Zinh``Qaai Inherited Inscriptional_Pahlavi``Phli Inscriptional_Pahlavi Inscriptional_Parthian``Prti Inscriptional_Parthian Javanese``Java Javanese Kaithi``Kthi Kaithi Kannada``Knda Kannada Katakana``Kana Katakana Kayah_Li``Kali Kayah_Li Kharoshthi``Khar Kharoshthi Khmer``Khmr Khmer Khojki``Khoj Khojki Khudawadi``Sind Khudawadi Lao``Laoo Lao Latin``Latn Latin Lepcha``Lepc Lepcha Limbu``Limb Limbu Linear_A``Lina Linear_A Linear_B``Linb Linear_B Lisu``Lisu Lisu Lycian``Lyci Lycian Lydian``Lydi Lydian Mahajani``Mahj Mahajani Makasar``Maka Makasar Malayalam``Mlym Malayalam Mandaic``Mand Mandaic Manichaean``Mani Manichaean Marchen``Marc Marchen Medefaidrin``Medf Medefaidrin Masaram_Gondi``Gonm Masaram_Gondi Meetei_Mayek``Mtei Meetei_Mayek Mende_Kikakui``Mend Mende_Kikakui Meroitic_Cursive``Merc Meroitic_Cursive Meroitic_Hieroglyphs``Mero Meroitic_Hieroglyphs Miao``Plrd Miao Modi``Modi Modi Mongolian``Mong Mongolian Mro``Mroo Mro Multani``Mult Multani Myanmar``Mymr Myanmar Nabataean``Nbat Nabataean New_Tai_Lue``Talu New_Tai_Lue Newa``Newa Newa Nko``Nkoo Nko Nushu``Nshu Nushu Ogham``Ogam Ogham Ol_Chiki``Olck Ol_Chiki Old_Hungarian``Hung Old_Hungarian Old_Italic``Ital Old_Italic Old_North_Arabian``Narb Old_North_Arabian Old_Permic``Perm Old_Permic Old_Persian``Xpeo Old_Persian Old_Sogdian``Sogo Old_Sogdian Old_South_Arabian``Sarb Old_South_Arabian Old_Turkic``Orkh Old_Turkic Oriya``Orya Oriya Osage``Osge Osage Osmanya``Osma Osmanya Pahawh_Hmong``Hmng Pahawh_Hmong Palmyrene``Palm Palmyrene Pau_Cin_Hau``Pauc Pau_Cin_Hau Phags_Pa``Phag Phags_Pa Phoenician``Phnx Phoenician Psalter_Pahlavi``Phlp Psalter_Pahlavi Rejang``Rjng Rejang Runic``Runr Runic Samaritan``Samr Samaritan Saurashtra``Saur Saurashtra Sharada``Shrd Sharada Shavian``Shaw Shavian Siddham``Sidd Siddham SignWriting``Sgnw SignWriting Sinhala``Sinh Sinhala Sogdian``Sogd Sogdian Sora_Sompeng``Sora Sora_Sompeng Soyombo``Soyo Soyombo Sundanese``Sund Sundanese Syloti_Nagri``Sylo Syloti_Nagri Syriac``Syrc Syriac Tagalog``Tglg Tagalog Tagbanwa``Tagb Tagbanwa Tai_Le``Tale Tai_Le Tai_Tham``Lana Tai_Tham Tai_Viet``Tavt Tai_Viet Takri``Takr Takri Tamil``Taml Tamil Tangut``Tang Tangut Telugu``Telu Telugu Thaana``Thaa Thaana Thai``Thai Thai Tibetan``Tibt Tibetan Tifinagh``Tfng Tifinagh Tirhuta``Tirh Tirhuta Ugaritic``Ugar Ugaritic Vai``Vaii Vai Warang_Citi``Wara Warang_Citi Yi``Yiii Yi Zanabazar_Square``Zanb Zanabazar_Square 21.2.2.9 转义原子 带有参数direction. 产生式 AtomEscape :: DecimalEscape 如下解释执行： 评估DecimalEscape以获取整数n。 断言：n ≤ NcapturingParens. 调用 BackreferenceMatcher(n, direction)，并且返回其Matcher结果 产生式 AtomEscape :: CharacterEscape 如下解释执行： 评估CharacterEscape以获取字符ch。 令 A 为包含字符ch的单元素CharSet。 调用 CharacterSetMatcher(A, false, direction)，并且返回其Matcher结果 产生式 AtomEscape :: CharacterClassEscape 如下解释执行： 评估CharacterClassEscape以获取CharSetA。 调用 CharacterSetMatcher(A, false, direction)，并且返回其Matcher结果 注：形式为\\的转义序列，后跟一个非零的十进制数字n，它与第n组捕获括号（21.2.2.1）的结果匹配。如果正则表达式的捕获括号少于n个，则会出现错误。如果正则表达式具有n个或多个捕获括号，但第n个因未捕获任何东西而未定义，则后向引用始终会成功。 产生式 AtomEscape :: k GroupName 如下解释执行： 在封闭模式中搜索RegExpIdentifierName的GroupSpecifier实例，该实例的StringValue等于GroupName中包含的RegExpIdentifierName的StringValue。 断言：找到唯一的此类GroupSpecifier。 令 parenIndex 为整个正则表达式中位于定位的GroupSpecifier左侧的左捕获括号的数量。这是位于或封闭所定位GroupSpecifier之前的Atom ::（GroupSpecifier Disjunction）解析节点的总数。 调用 BackreferenceMatcher(parenIndex, direction)，并且返回其Matcher结果 21.2.2.9.1 RS: BackreferenceMatcher ( n, direction ) 抽象操作BackreferenceMatcher接受两个参数，整数n和整数direction，并执行以下步骤： 返回一个内部Matcher闭包，它使用两个参数（状态x和连续性c），并执行以下步骤： 令 cap 为 x 的捕获列表。 令 s 为 cap[n]. 若 s 是 undefined，返回 c(x). 令 e 为x的endIndex。 令 len 为 s 中的元素数。 令 f 为 e + direction × len. 若 f InputLength，返回 failure. 令 g 为 min (e, f). 若存在一个介于0（含）和len（不含）之间的整数i，以使 Canonicalize（s [i]）不是与Canonicalize（Input [g + i]）相同的字符值，返回 failure. 令 y 为 State (f, cap). 调用 c(y)并且返回它的结果 21.2.2.10 转义字符 CharacterEscape产品评估如下： CharacterEscape :: ControlEscape c ControlLetter 0 [lookahead ∉ DecimalDigit] HexEscapeSequence RegExpUnicodeEscapeSequence IdentityEscape 令 cv 为此CharacterEscape的CharacterValue。 返回字符值为cv的字符。 21.2.2.11 转义十进制 DecimalEscape生产评估如下： DecimalEscape :: NonZeroDigit DecimalDigits 返回此DecimalEscape的CapturingGroupNumber。 注：如果\\后跟一个十进制数字n（其第一位数字不为0），则转义序列被视为反向引用。如果n大于整个正则表达式中左捕获括号的总数，则会出现错误。 21.2.2.12 转义字符类 产生式 CharacterClassEscape :: d 如下解释执行： 返回十个字符的字符集，包含字符0到9（含0和9）。 产生式 CharacterClassEscape :: D 如下解释执行： 返回由CharacterClassEscape :: d返回的集合中未包括的所有字符的集合。 产生式 CharacterClassEscape :: s 如下解释执行： 返回包含WhiteSpace或LineTerminator产品右侧的字符的字符集。 产生式 CharacterClassEscape :: S 如下解释执行： 返回由CharacterClassEscape ::: s返回的所有字符集中的字符集。 产生式 CharacterClassEscape :: w 如下解释执行： 返回WordCharacters（）返回的所有字符的集合。 产生式 CharacterClassEscape :: W 如下解释执行： 返回CharacterClassEscape :: w返回的集合中未包括的所有字符的集合。 生产的CharacterClassEscape :: p {UnicodePropertyValueExpression}通过返回CharSet进行评估，该CharSet包含UnicodePropertyValueExpression返回的CharSet中包含的所有Unicode代码点。 生产的CharacterClassEscape :: P {UnicodePropertyValueExpression}通过返回包含所有未包含在UnicodePropertyValueExpression返回的CharSet中的所有Unicode代码点的CharSet进行评估。 产生式 UnicodePropertyValueExpression :: UnicodePropertyName = UnicodePropertyValue 如下解释执行： 令 ps 为UnicodePropertyName的SourceText。 令 p 为 ! UnicodeMatchProperty(ps). 断言：p是表54的“属性名称和别名”列中列出的Unicode属性名称或属性别名。 令 vs 为UnicodePropertyValue的SourceText。 令 v 为 ! UnicodeMatchPropertyValue(p, vs). 返回包含所有Unicode代码点的字符集的CharSet，这些字符集的字符数据库定义包含值为v的属性p。 产生式 UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue 如下解释执行： 令 s 为LoneUnicodePropertyNameOrValue的SourceText。 若 ! UnicodeMatchPropertyValue(\"General_Category\", s)与Unicode代码点列表相同，后者是表56的“属性值和别名”列中列出的Unicode常规类别或常规类别别名的名称，然后 返回 包含所有Unicode代码点的字符集的字符集，其字符数据库定义包括值为s的属性“ General_Category”。 令 p 为 ! UnicodeMatchProperty(s). 断言：p是表55的“属性名称和别名”列中列出的二进制Unicode属性或二进制属性别名。 返回包含所有Unicode代码点的字符集的字符集，这些字符集的字符数据库定义包含值为“ True”的属性p。 21.2.2.13 字符类 产生式 CharacterClass :: [ ClassRanges ] 如下解释执行： 评估ClassRanges以获得CharSetA。 返回两个结果A和False。 产生式 CharacterClass :: [ ^ ClassRanges ] 如下解释执行： 评估ClassRanges以获得CharSetA。 返回两个结果A和true。 21.2.2.14 字符范围集 产生式 ClassRanges :: [empty] 如下解释执行： 返回空的CharSet。 产生式 ClassRanges :: NonemptyClassRanges 如下解释执行： 返回CharSet是评估NonemptyClassRanges的结果。 21.2.2.15 非空字符范围集 产生式 NonemptyClassRanges :: ClassAtom 如下解释执行： 返回CharSet是评估ClassAtom的结果。 产生式 NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash 如下解释执行： 评估ClassAtom以获得CharSetA。 评估NonemptyClassRangesNoDash以获得CharSetB。 返回字符集A和B的并集。 产生式 NonemptyClassRanges :: ClassAtom - ClassAtom ClassRanges 如下解释执行： 评估第一个ClassAtom以获得CharSetA。 评估第二个ClassAtom以获得CharSetB。 评估ClassRanges以获得CharSetC。 调用 CharacterRange(A, B)，并且令 D 为 得到的CharSet。 返回字符集D和C的并集。 21.2.2.15.1 RS: CharacterRange ( A, B ) 抽象操作CharacterRange采用两个CharSet参数A和B并执行以下步骤： 断言：A和B都只包含一个字符。 令 a 为CharSet A中的一个字符。 令 b 为CharSet B中的一个字符。 令 i 为字符a的字符值。 令 j 为字符b的字符值。 断言：i ≤ j. 返回包含所有编号为i到j（包括i）的字符的集合。 21.2.2.16 无连接符非空字符范围集 产生式 NonemptyClassRangesNoDash :: ClassAtom 如下解释执行： 返回 CharSet 是评估ClassAtom的结果。 产生式 NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash 如下解释执行： 评估ClassAtomNoDash以获取CharSetA。 评估NonemptyClassRangesNoDash以获得CharSetB。 返回字符集A和B的并集 产生式 NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassRanges 如下解释执行： 评估ClassAtomNoDash以获取CharSetA。 评估ClassAtom以获得CharSetB。 评估ClassRanges以获得CharSetC。 调用 CharacterRange(A, B)，并且令 D 为得到的CharSet。 返回字符集D和C的并集。 注 1 ClassRanges可以扩展为单个ClassAtom和/或两个以虚线分隔的ClassAtom范围。在后一种情况下，ClassRanges包括第一个ClassAtom和第二个ClassAtom之间的所有字符（包括首尾）。如果ClassAtom不代表单个字符（例如，如果是\\ w），或者第一个ClassAtom的字符值大于第二个ClassAtom的字符值，则会发生错误。 注 2 即使模式忽略大小写，在确定哪些字符属于该范围时，范围两端的大小写也很重要。因此，例如，模式/ [EF] / i仅匹配字母E，F，e和f，而模式/ [Ef] / i则匹配Unicode Basic Latin块中的所有大小写字母，例如以及符号[，\\，]，^，_和`。 注 3 -字符可以按字面意义对待，也可以表示范围。如果它是ClassRanges的第一个或最后一个字符，范围说明的开始或结束限制，或者紧随范围说明，则将按字面意义对待它。 21.2.2.17 字符类原子 产生式 ClassAtom :: - 如下解释执行： 返回包含单个字符的字符集-U + 002D（减号）。 产生式 ClassAtom :: ClassAtomNoDash 如下解释执行： 返回 CharClas s是评估ClassAtomNoDash的结果。 21.2.2.18 非连接符字符类原子 产生式 ClassAtomNoDash :: SourceCharacter but not one of \\ or ] or - 如下解释执行： 返回包含与SourceCharacter匹配的字符的CharSet。 产生式 ClassAtomNoDash :: \\ ClassEscape 如下解释执行： 返回CharSet是评估ClassEscape的结果。 21.2.2.19 字符可用转义 ClassEscape产品评估如下： ClassEscape :: b ClassEscape :: - ClassEscape :: CharacterEscape 令 cv 为此ClassEscape的CharacterValue。 令 c 为字符值为cv的字符。 返回包含单个字符的字符集c。 ClassEscape :: CharacterClassEscape 返回 CharSet 是评估CharacterClassEscape的结果。 注 ClassAtom可以使用正则表达式其余部分中允许的任何转义序列，但\\ b，\\ B和反向引用除外。在CharacterClass内部，\\ b表示退格字符，而\\ B和反向引用会引发错误。在ClassAtom内部使用反向引用会导致错误。 21.2.3 RegExp 构造器 RegExp构造函数： 是内部对象％RegExp％。 是全局对象的RegExp属性的初始值。 当作为函数而不是构造函数调用时，创建并初始化一个新的RegExp对象。因此，函数调用RegExp（…）等效于具有相同参数的对象创建表达式new RegExp（…）。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定的RegExp行为的子类构造函数必须包括对RegExp构造函数的超级调用，以使用必需的内部插槽创建和初始化子类实例。 21.2.3.1 RegExp ( pattern, flags ) 将采取以下步骤： 令 patternIsRegExp 为 ? IsRegExp(pattern). 若 NewTarget 是 undefined，那么 令 newTarget 为 the active function object. 若 patternIsRegExp is true and flags 是 undefined，那么 令 patternConstructor 为 ? Get(pattern, \"constructor\"). 若 SameValue(newTarget, patternConstructor) 是 true，返回 pattern. 否则，令 newTarget 为 NewTarget. 若 Type(pattern) 是 Object，并且 pattern 有 [[RegExpMatcher]] 内置插槽，那么 令 P 为 pattern.[[OriginalSource]]. 若 flags 是 undefined, 令 F 为 pattern.[[OriginalFlags]]. 否则，令 F 为 flags. 否则若 patternIsRegExp 是 true，那么 令 P 为 ? Get(pattern, \"source\"). 若 flags 是 undefined，那么 令 F 为 ? Get(pattern, \"flags\"). 否则，令 F 为 flags. 否则， 令 P 为 pattern. 令 F 为 flags. 令 O 为 ? RegExpAlloc(newTarget). 返回 ? RegExpInitialize(O, P, F). 注 如果使用StringLiteral提供模式，则在RegExp处理字符串之前执行通常的转义序列替换。 如果模式必须包含一个要被RegExp识别的转义序列，则必须在StringLiteral中转义任何U+005C(反向SOLIDUS)代码点，以防止在形成StringLiteral内容时将它们删除 21.2.3.2 RegExp构造器的抽象操作 21.2.3.2.1 RS: RegExpAlloc ( newTarget ) 当调用带有newTarget参数的抽象操作RegExpAlloc时，将采取以下步骤： 令 obj 为 ? OrdinaryCreateFromConstructor(newTarget, \"%RegExpPrototype%\", « [[RegExpMatcher]],[[OriginalSource]], [[OriginalFlags]] »). 执行 ! DefinePropertyOrThrow(obj, \"lastIndex\", PropertyDescriptor { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }). 返回 obj. 21.2.3.2.2 RS: RegExpInitialize ( obj, pattern, flags ) 当调用带有参数obj、模式和标志的抽象操作RegExpInitialize时，将采取以下步骤： 若 pattern 是 undefined, 令 P 为空字符串. 否则，令 P 为 ? ToString(pattern). 若 flags 是 undefined, 令 F 为空字符串. 否则， 令 F 为 ? ToString(flags). 若 F 包含除\"g\", \"i\", \"m\", \"s\", \"u\", or \"y\"或者它包含相同的代码单元不止一次，抛出 SyntaxError 异常. 若 F 包括 \"u\", 令 BMP 为 false；否则令 BMP 为 true. 若 BMP 是 true，那么 使用21.2.1中的语法解析P，并将其16位元素解释为Unicode BMP编码点。UTF-16解码不应用于元素。 解析的目标符号是Pattern[~U， ~N]。如果解析的结果包含GroupName，则使用目标符号模式[~U， +N]重新解析，并使用此结果。抛出SyntaxError异常如果P不符合语法,如果任何元素的P被解析不匹配,或是否存在任何早期的错误条件。 令 patternCharacters 为一个列表，它的元素是P的代码单元元素。 否则， 使用21.2.1中的语法解析P，并将P解释为UTF-16编码的Unicode编码点(6.1.4)。解析的目标符号是Pattern[+U， +N]。抛出SyntaxError异常如果P不符合语法,如果任何元素的P被解析不匹配,或是否存在任何早期的错误条件。 令 patternCharacters 为一个列表，它的元素是将UTF-16解码应用到P的元素序列后产生的代码点。 设置 obj.[[OriginalSource]] 为 P. 设置 obj.[[OriginalFlags]] 为 F. 设置 obj.[[RegExpMatcher]] 为使用模式字符作为源字符值的模式列表，并使用F作为标志参数，通过应用21.2.2中提供的语义来评估P的上述解析的内部过程。 执行 ? Set(obj, \"lastIndex\", 0, true). 返回 obj. 21.2.3.2.3 RS: RegExpCreate ( P, F ) 当调用带有参数P和F的抽象操作RegExpCreate时，将采取以下步骤： 令 obj 为 ? RegExpAlloc(%RegExp%). 返回 ? RegExpInitialize(obj, P, F). 21.2.3.2.4 RS: EscapeRegExpPattern ( P, F ) 调用带有参数P和F的EscapeRegExpPattern抽象操作时，发生以下情况: 假设S是一个模式[~U](模式[+U]，如果F包含\"U\")形式的字符串，它等价于P, P被解释为UTF-16编码的Unicode编码点(6.1.4)，其中某些编码点如下所述转义。S可能与P相同，也可能不相同；但是，将S求值为模式[~U](如果F包含\"U\"，则模式[+U])所产生的内部过程必须与构造对象的[[RegExpMatcher]]内部槽所给出的内部过程具有相同的行为。对这个抽象操作使用相同的P和F值的多次调用必须产生相同的结果。 模式中出现的代码点/或任何LineTerminator必须在S中转义，以确保可以将“ /”，S，“ /”和F的字符串连接解析为（在适当的词法上下文中）为RegularExpressionLiteral，其行为与构造的正则表达式相同。例如，如果P为“ /”，则S可以为“ \\ /”或“ \\ u002F”，但不能为“ /”，因为///后跟F将被解析为SingleLineComment而不是A RegularExpressionLiteral。如果P是空字符串，则可以通过使S为“（？:)”来满足此规范。 返回 S. 21.2.4 RegExp 构造器属性 RegExp构造函数： 有一个[[Prototype]]内部插槽，其值是固有对象％FunctionPrototype％。 具有以下属性： 21.2.4.1 RegExp.prototype RegExp.prototype的初始值为内部对象％RegExpPrototype％。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 21.2.4.2 get RegExp [ @@species ] RegExp [@@species]是一个访问器属性，其设置的访问器功能未定义。它的get访问器功能执行以下步骤： 返回 this 值。 该函数的名称属性的值为“ get [Symbol.species]”。 注：RegExp原型方法通常使用其this对象的构造函数来创建派生对象。但是，子类构造函数可以通过重新定义其@@species属性来覆盖该默认行为。 21.2.5 RegExp 原型对象属性 RegExp原型对象： 是内部对象％RegExpPrototype％。 是一个普通的对象。 不是RegEx实例，并且没有[[RegExp Matcher]]内部插槽或RegExp实例对象的任何其他内部插槽。 有一个[[Prototype]]内部插槽，其值是固有对象％ObjectPrototype％。 注：RegExp原型对象没有自己的valueOf属性。但是，它从Object原型对象继承了valueOf属性。 21.2.5.1 RegExp.prototype.constructor RegExp.prototype.constructor的初始值为内部对象％RegExp％。 21.2.5.2 RegExp.prototype.exec ( string ) 与正则表达式执行字符串的正则表达式匹配，并返回包含匹配结果的Array对象；如果字符串不匹配，则返回null。 在字符串ToString（string）中搜索正则表达式模式，如下所示： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[RegExpMatcher]] 内部插槽, 抛出 TypeError 异常. 令 S 为 ? ToString(string). 返回 ? RegExpBuiltinExec(R, S). 21.2.5.2.1 RS: RegExpExec ( R, S ) 具有参数R和S的抽象操作RegExpExec执行以下步骤： 断言：Type(R) 是 Object。 断言：Type(S) 是 String。 令 exec 为 ? Get(R, \"exec\"). 若 IsCallable(exec) 是 true，那么 令 result 为 ? Call(exec, R, « S »). 若 Type(result) 不是 Object 或 Null, 抛出 TypeError 异常. 返回 result. 若 R 没有 [[RegExpMatcher]] 内部插槽, 抛出 TypeError 异常. 返回 ? RegExpBuiltinExec(R, S). 注：如果找不到可调用的exec属性，则该算法将退回到尝试使用内置RegExp匹配算法的过程。这为为先前版本编写的代码提供了兼容的行为，在先前版本中，大多数使用正则表达式的内置算法未执行exec的动态属性查找。 21.2.5.2.2 RS: RegExpBuiltinExec ( R, S ) 具有参数R和S的抽象操作RegExpBuiltinExec执行以下步骤： 断言：R是初始化的RegExp实例。 断言：Type(S) 是 String。 令 length 为S中的代码单位数。 令 lastIndex 为 ? ToLength(? Get(R, \"lastIndex\")). 令 flags 为 R.[[OriginalFlags]]. 若 flags 包含 \"g\", 令 global 为 true, else 令 global 为 false. 若 flags 包含 \"y\", 令 sticky 为 true, else 令 sticky 为 false. 若 global 是 false，并且 sticky 是 false, 设置 lastIndex 为 0. 令 matcher 为 R.[[RegExpMatcher]]. 若 flags 包含 \"u\", 令 fullUnicode 为 true，否则 令 fullUnicode 为 false. 令 matchSucceeded 为 false. 重复，直到 matchSucceeded 是 false 若 lastIndex > length，那么 若 global 是 true，或 sticky 是 true，那么 执行 ? Set(R, \"lastIndex\", 0, true). 返回 null. 令 r 为 matcher(S, lastIndex). 若 r 是 failure，那么 若 sticky 是 true，那么 执行 ? Set(R, \"lastIndex\", 0, true). 返回 null. 设置 lastIndex 为 AdvanceStringIndex(S, lastIndex, fullUnicode). 否则， 断言：r 是 State. 设置 matchSucceeded 为 true. 令 e 为 r 的 endIndex 值。 若 fullUnicode 是 true，那么 e是输入字符列表的索引，由S派生，由匹配器匹配。假设eUTF是S中与Input元素e上的字符相对应的最小索引。如果e大于或等于Input中的元素数，则eUTF是S中的代码单元数。 设置 e 为 eUTF. 若 global 是 true，或 sticky 是 true，那么 执行 ? Set(R, \"lastIndex\", e, true). 令 n 为r的捕获列表中元素的数量。 （该值与21.2.2.1的NcapturingParens相同。） 断言: n 令 A 为 ! ArrayCreate(n + 1). 断言: A的“length”属性的值为n + 1。 执行 ! CreateDataProperty(A, \"index\", lastIndex). 执行 ! CreateDataProperty(A, \"input\", S). 令matchSubstr为匹配的子字符串（即偏移量lastIndex包含在内和偏移量e排除之间的S部分）。 执行 ! CreateDataProperty(A, \"0\", matchedSubstr). 若R包含任何GroupName，那么 令 groups 为 ObjectCreate(null). 否则， 令 groups 为 undefined. 执行 ! CreateDataProperty(A, \"groups\", groups). 对于每个大于 i 且 i ≤ n 的整数 i，执行 令 captureI 为第 i 个 r 的捕获列表的元素。 若 captureI 是 undefined, 令 capturedValue 为 undefined. 否则若 fullUnicode 是 true，那么 断言：captureI是代码点列表。 令 capturedValue 为 String 值，其代码单位是captureI的代码点的UTF16Encoding。 否则 fullUnicode 为 false， 断言：captureI是代码单元列表。 令 capturedValue 为由captureI的代码单元组成的String值。 执行 ! CreateDataProperty(A, ! ToString(i), capturedValue). 若使用GroupName定义R的第i个捕获，那么 令 s 为相应的RegExpIdentifierName的StringValue。 执行 ! CreateDataProperty(groups, s, capturedValue). 返回 A. 21.2.5.2.3 AdvanceStringIndex ( S, index, unicode ) 具有参数S，索引和unicode的抽象操作AdvanceStringIndex执行以下步骤： 断言：Type(S) 是 String。 断言：index是一个整数，使得 0 ≤ index ≤ 253 - 1. 断言：Type(unicode) 是 Boolean。 若 unicode 是 false，返回 index + 1. 令 length 为S中的代码单位数。 若 index + 1 ≥ length，返回 index + 1. 令 first 为S中索引index处的代码单元的数值。 若 first 0xDBFF，返回 index + 1. 令 second 为S中索引index +1处的代码单元的数值。 若 second 0xDFFF，返回 index + 1. 返回 index + 2. 21.2.5.3 获取 RegExp.prototype.dotAll RegExp.prototype.dotAll是一个访问器属性，其设置的访问器函数未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[OriginalFlags]] 内部插槽，那么 若 SameValue(R, %RegExpPrototype%) 是 true，返回 undefined. 除此之外, 抛出 TypeError 异常. 令 flags 为 R.[[OriginalFlags]]. 若 flags 包含代码单元 0x0073 (拉丁文小写字母S)，返回 true. 返回 false 21.2.5.4 获取 RegExp.prototype.flags RegExp.prototype.flags是一个访问器属性，其设置的访问器功能未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 令 result 为空字符串. 令 global 为 ToBoolean(? Get(R, \"global\")). 若 global 是 true, 将代码单元0x0067（拉丁文小写字母G）附加为结果的最后一个代码单元。 令 ignoreCase 为 ToBoolean(? Get(R, \"ignoreCase\")). 若 ignoreCase 是 true, 将代码单元0x0069（拉丁文小写字母I）附加为结果的最后一个代码单元。 令 multiline 为 ToBoolean(? Get(R, \"multiline\")). 若 multiline 是 true, 将代码单元0x006D（拉丁文小写字母M）附加为结果的最后一个代码单元。 令 dotAll 为 ToBoolean(? Get(R, \"dotAll\")). 若 dotAll is true, 将代码单元0x0073（拉丁文小写字母S）附加为结果的最后一个代码单元。 令 unicode 为 ToBoolean(? Get(R, \"unicode\")). 若 unicode is true, 将代码单元0x0075（拉丁文小写字母U）附加为结果的最后一个代码单元。 令 sticky 为 ToBoolean(? Get(R, \"sticky\")). 若 sticky is true, 将代码单元0x0079（拉丁文小写字母Y）附加为结果的最后一个代码单元。 返回 result. 21.2.5.5 获取 RegExp.prototype.global RegExp.prototype.global是一个访问器属性，其设置的访问器功能未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[OriginalFlags]] 内部插槽，那么 若 SameValue(R, %RegExpPrototype%) 是 true，返回 undefined. 除此之外, 抛出 TypeError 异常. 除此之外, 抛出 TypeError 异常. 令 flags 为 R.[[OriginalFlags]]. 若包含代码单元0x0067（拉丁文小写字母G），返回 true. 返回 false. 21.2.5.6 获取 RegExp.prototype.ignoreCase RegExp.prototype.ignoreCase是一个访问器属性，其设置的访问器功能未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[OriginalFlags]] 内部插槽，那么 若 SameValue(R, %RegExpPrototype%) 是 true，返回 undefined. 除此之外, 抛出 TypeError 异常. 令 flags 为 R.[[OriginalFlags]]. 若 flags 包含代码单元0x0069（拉丁文小写字母I），返回 true. 返回 false. 21.2.5.7 RegExp.prototype [ @@match ] ( string ) 用参数字符串调用@@match方法时，将采取以下步骤： 令 rx 为 this 值。 若 Type(rx) 不是 Object, 抛出 TypeError 异常. 令 S 为 ? ToString(string). 令 global 为 ToBoolean(? Get(rx, \"global\")). 若 global 是 false，那么 返回 ? RegExpExec(rx, S). 否则 global 是 true, 令 fullUnicode 为 ToBoolean(? Get(rx, \"unicode\")). 执行 ? Set(rx, \"lastIndex\", 0, true). 令 A 为 ! ArrayCreate(0). 令 n 为 0. 重复， 令 result 为 ? RegExpExec(rx, S). 若 result 是 null，那么 若 n = 0，返回 null. 返回 A. 否则 result 不是 null, 令 matchStr 为 ? ToString(? Get(result, \"0\")). 令 status 为 CreateDataProperty(A, ! ToString(n), matchStr). 断言：status 是 true. 若 matchStr 是空字符串，那么 令 thisIndex 为 ? ToLength(? Get(rx, \"lastIndex\")). 令 nextIndex 为 AdvanceStringIndex(S, thisIndex, fullUnicode). 执行 ? Set(rx, \"lastIndex\", nextIndex, true). n增加 该函数的名称属性的值为“ [Symbol.match]”。 注：IsRegExp抽象操作使用@@match属性来标识具有正则表达式基本行为的对象。不存在@@match属性或该属性的值不将布尔值强制转换为true表示该对象不打算用作正则表达式对象。 21.2.5.8 获取 RegExp.prototype.multiline RegExp.prototype.multiline是一个访问器属性，其设置的访问器函数未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[OriginalFlags]] 内部插槽，那么 若 SameValue(R, %RegExpPrototype%) 是 true，返回 undefined. 除此之外, 抛出 TypeError 异常. 令 flags 为 R.[[OriginalFlags]]. 若 flags 包含代码单元0x006D（拉丁文小写字母M），返回 true. 返回 false. 21.2.5.9 RegExp.prototype [ @@replace ] ( string, replaceValue ) 当使用参数 string 和 replaceValue 调用 @@replace 方法时，将采取以下步骤： 令 rx 为 this 值。 若 Type(rx) 不是 Object, 抛出 TypeError 异常. 令 S 为 ? ToString(string). 令 lengthS 为S中的代码单元元素的数量。 令 functionalReplace 为 IsCallable(replaceValue). 若 functionalReplace 是 false，那么 设置 replaceValue 为 ? ToString(replaceValue). 令 global 为 ToBoolean(? Get(rx, \"global\")). 若 global 是 true，那么 令 fullUnicode 为 ToBoolean(? Get(rx, \"unicode\")). 执行 ? Set(rx, \"lastIndex\", 0, true). 令 results 为一个新的空列表。 令 done 为 false. 重复, 直到 done 是 false 令 result 为 ? RegExpExec(rx, S). 若 result 是 null, 设置 done 为 true. 否则 result 不是 null, 添加 result 到 results 的结尾. 若 global 是 false, 设置 done 到 true. 否则， 令 matchStr 为 ? ToString(? Get(result, \"0\")). 若 matchStr 是空字符串，那么 令 thisIndex 为 ? ToLength(? Get(rx, \"lastIndex\")). 令 nextIndex 为 AdvanceStringIndex(S, thisIndex, fullUnicode). 执行 ? Set(rx, \"lastIndex\", nextIndex, true). 令 accumulatedResult 为空字符串 value. 令 nextSourcePosition 为 0. 对于results中的每个result，执行 令 nCaptures 为 ? ToLength(? Get(result, \"length\")). 设置 nCaptures 为 max(nCaptures - 1, 0). 令 matched 为 ? ToString(? Get(result, \"0\")). 令 matchLength 为匹配的代码单元数。 令 position 为 ? ToInteger(? Get(result, \"index\")). 设置 position 为 max(min(position, lengthS), 0). 令 n 为 1. 令 captures 为一个新的空列表。 重复， 当 n ≤ nCaptures 令 capN 为 ? Get(result, ! ToString(n)). 若 capN 不是 undefined，那么 设置 capN 为 ? ToString(capN). 将capN追加为捕获的最后一个元素。 n 增加 1 令 namedCaptures 为 ? Get(result, \"groups\"). 若 functionalReplace 是 true，那么 令 replacerArgs 为 « matched ». 添加按列表顺序 captures 的元素到列表 replacerArgs 的末尾。 添加 position 和 S 到 replacerArgs. 若 namedCaptures 不是 undefined，那么 将namedCaptures追加为replacerArgs的最后一个元素。 令 replValue 为 ? Call(replaceValue, undefined, replacerArgs). 令 replacement 为 ? ToString(replValue). 否则， 令 replacement 为 GetSubstitution(matched, S, position, captures, namedCaptures, replaceValue). 若 position ≥ nextSourcePosition，那么 注: 位置通常不应向后移动。如果是这样，则表明RegExp子类行为异常，或者使用访问触发的副作用来更改rx的全局标志或其他特征。在这种情况下，将忽略相应的替换。 设置 cumulativeResult 为 accumulatedResult 当前值的字符串连接，即 S 的子字符串，包括从nextSourcePosition（含）到位置（不含）的代码单元，和更换。 设置 nextSourcePosition 为 position + matchLength. 若 nextSourcePosition ≥ lengthS，返回 accumulatedResult. 返回 S 的子字符串（由nextSourcePosition（包括）开始，到S的最终代码单元（包括）），是SummaryResult的字符串连接。 该函数的名称属性的值为“ [Symbol.replace]”。 21.2.5.10 RegExp.prototype [ @@search ] ( string ) 当使用参数字符串调用@@search方法时，将采取以下步骤： 令 rx 为 this 值。 若 Type(rx) 不是 Object, 抛出 TypeError 异常. 令 S 为 ? ToString(string). 令 previousLastIndex 为 ? Get(rx, \"lastIndex\"). 若 SameValue(previousLastIndex, 0) 是 false，那么 执行 ? Set(rx, \"lastIndex\", 0, true). 令 result 为 ? RegExpExec(rx, S). 令 currentLastIndex 为 ? Get(rx, \"lastIndex\"). 若 SameValue(currentLastIndex, previousLastIndex) 是 false，那么 执行 ? Set(rx, \"lastIndex\", previousLastIndex, true). 若 result 是 null，返回 -1. 返回 ? Get(result, \"index\"). 该函数的名称属性的值为“ [Symbol.search]”。 注：执行搜索时，将忽略此RegExp对象的lastIndex和全局属性。 lastIndex属性保持不变。 21.2.5.11 获取 RegExp.prototype.source RegExp.prototype.source是一个访问器属性，其设置的访问器功能未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[OriginalSource]] 内部插槽，那么 若 SameValue(R, %RegExpPrototype%) 是 true，返回 \"(?:)\". 除此之外, 抛出 TypeError 异常. 断言：R有一个[[OriginalFlags]]内部插槽。 令 src 为 R.[[OriginalSource]]. 令 flags 为 R.[[OriginalFlags]]. 返回 EscapeRegExpPattern(src, flags). 21.2.5.12 RegExp.prototype [ @@split ] ( string, limit ) 注 1 返回一个Array对象，其中已将字符串转换为String的结果的子字符串存储在其中。通过从左到右搜索此值正则表达式的匹配项来确定子字符串。这些出现不属于返回数组中任何子字符串的一部分，而是用于划分String值。 这个值可以是空的正则表达式，也可以是匹配空字符串的正则表达式。在本例中，正则表达式不匹配输入字符串开头或结尾的空子字符串，也不匹配前面的分隔符匹配结尾的空子字符串。(例如,如果正则表达式匹配空字符串,字符串分成独立的代码单元元素；结果数组的长度等于字符串的长度，每个子字符串包含一个代码单元。只考虑给定字符串索引处的第一个匹配，即使回溯可能在该索引处产生非空子字符串匹配。(例如,/ \\ ? / \\ [Symbol.split] (ab)等于数组(“a”、“b”),而/ \\ / \\ [Symbol.split] (ab)等于数组(“”,“b”))。 如果字符串是（或转换为）空字符串，则结果取决于正则表达式是否可以匹配空字符串。如果可以，则结果数组不包含任何元素。否则，结果数组包含一个元素，即空字符串 如果正则表达式包含捕获括号，则每次分隔符匹配时，捕获括号的结果（包括任何未定义的结果）都将被拼接到输出数组中。例如， /]+)>/[Symbol.split](\"A\\bold\\and\\coded\\\") 解释执行到数组 [\"A\", undefined, \"B\", \"bold\", \"/\", \"B\", \"and\", undefined, \"CODE\", \"coded\", \"/\", \"CODE\" 如果未定义limit，则输出数组将被截断，以使其包含的元素数不超过limit。 调用@@split方法时，将采取以下步骤： 令 rx 为 this 值。 若 Type(rx) 不是 Object, 抛出 TypeError 异常. 令 S 为 ? ToString(string). 令 C 为 ? SpeciesConstructor(rx, %RegExp%). 令 flags 为 ? ToString(? Get(rx, \"flags\")). 若 flags 包含 \"u\", 令 unicodeMatching 为 true. 否则， 令 unicodeMatching 为 false. 若 flags 包含 \"y\", 令 newFlags 为 flags. 否则， 令 newFlags 为 flag 和“y”的字符串连接。 令 splitter 为 ? Construct(C, « rx, newFlags »). 令 A 为 ! ArrayCreate(0). 令 lengthA 为 0. 若 limit 是 undefined, 令 lim 为 232 - 1; 否则 令 lim 为 ? ToUint32(limit). 令 size 为 S 的长度. 令 p 为 0. 若 lim = 0，返回 A. 若 size = 0，那么 令 z 为 ? RegExpExec(splitter, S). 若 z 不是 null，返回 A. 执行 ! CreateDataProperty(A, \"0\", S). 返回 A. 令 q 为 p. 重复, 直到 q 执行 ? Set(splitter, \"lastIndex\", q, true). 令 z 为 ? RegExpExec(splitter, S). 若 z 是 null, 设置 q 到 AdvanceStringIndex(S, q, unicodeMatching). 否则 z 不是 null, 令 e 为 ? ToLength(? Get(splitter, \"lastIndex\")). 设置 e 为 min(e, size). 若 e = p, set q to AdvanceStringIndex(S, q, unicodeMatching). 否则 e ≠ p, 令 T 为字符串值，它等于S的子字符串，该子字符串由索引p（含）至q（不含）处的代码单元组成。 执行 ! CreateDataProperty(A, ! ToString(lengthA), T). lengthA 增加 1 若 lengthA = lim，返回 A. 设置 p 为 e. 令 numberOfCaptures 为 ? ToLength(? Get(z, \"length\")). 设置 numberOfCaptures 为 max(numberOfCaptures - 1, 0). 令 i 为 1. 重复， 直到 i ≤ numberOfCaptures, 令 nextCapture 为 ? Get(z, ! ToString(i)). 执行 ! CreateDataProperty(A, ! ToString(lengthA), nextCapture). i 增加 1 lengthA 增加 1 若 lengthA = lim，返回 A. 设置 q 为 p. 令 T 为字符串值，它等于S的子字符串，该子字符串由索引p（含）到大小（不含）之间的代码单元组成。 执行 ! CreateDataProperty(A, ! ToString(lengthA), T). 返回 A. 该函数的名称属性的值为“ [Symbol.split]”。 注 2：@@split方法将忽略此RegExp对象的global和sticky属性的值。 21.2.5.13 获取 RegExp.prototype.sticky RegExp.prototype.sticky是一个访问器属性，其设置的访问器功能未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[OriginalFlags]] 内部插槽，那么 若 SameValue(R, %RegExpPrototype%) 是 true，返回 undefined. 除此之外, 抛出 TypeError 异常. 令 flags 为 R.[[OriginalFlags]]. 若 flags 包含代码单元0x0079（拉丁文小写字母Y），返回 true. 返回 false. 21.2.5.14 RegExp.prototype.test ( S ) 将采取以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 令 string 为 ? ToString(S). 令 match 为 ? RegExpExec(R, string). 若 match 不是 null，返回 true; else return false 21.2.5.15 RegExp.prototype.toString ( ) 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 令 pattern 为 ? ToString(? Get(R, \"source\")). 令 flags 为 ? ToString(? Get(R, \"flags\")). 令 result 为“ /”，模式，“ /”和标志的字符串连接。 返回 result. 注：返回的String具有RegularExpressionLiteral的形式，该形式求值为另一个具有与此对象相同行为的RegExp对象。 21.2.5.16 获取 RegExp.prototype.unicode RegExp.prototype.unicode是一个访问器属性，其设置的访问器函数未定义。它的get访问器功能执行以下步骤： 令 R 为 this 值。 若 Type(R) 不是 Object, 抛出 TypeError 异常. 若 R 没有 [[OriginalFlags]] 内部插槽，那么 若 SameValue(R, %RegExpPrototype%) 是 true，返回 undefined. 除此之外, 抛出 TypeError 异常. 令 flags 为 R.[[OriginalFlags]]. 若 flags 包含代码单元0x0075（拉丁文小写字母U），返回 true. 返回 false 21.2.6 RegExp 实例属性 RegExp实例是从RegExp原型对象继承属性的普通对象。 RegExp实例具有内部插槽[[RegExpMatcher]]，[[OriginalSource]]和[[OriginalFlags]]。 [[RegExpMatcher]]内部插槽的值是RegExp对象的Pattern的与实现有关的表示。 注：在ECMAScript 2015之前，RegExp实例被指定为具有自己的数据属性source，global，ignoreCase和multiline。这些属性现在指定为RegExp.prototype的访问器属性。 RegExp实例还具有以下属性： 21.2.6.1 lastIndex lastIndex属性的值指定开始下一个匹配的String索引。使用时将其强制为整数（请参见21.2.5.2.2）。该属性应具有以下属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. "},"indexed-collections.html":{"url":"indexed-collections.html","title":"22 索引集合","keywords":"","body":"22 索引集合 22.1 数组对象 数组对象是异类对象，可以对某些类的属性名称进行特殊处理。有关特殊处理的定义，请参见9.4.2。 22.1.1 Array 构造器 数组构造函数： 是内部对象％Array％。 是全局对象的Array属性的初始值。 在作为构造函数调用时，创建并初始化一个新的Array异类对象。 当作为函数而不是构造函数调用时，还创建并初始化一个新的Array对象。因此，函数调用“ Array（…）”等效于具有相同参数的对象创建表达式“ new Array（…）”。 是一个函数，其行为根据其参数的数量和类型而重载。 设计为可归类的。它可以用作类定义的`extends'子句的值。打算继承奇异的Array行为的子类构造函数必须包括对Array构造函数的super调用，以初始化作为Array异类对象的子类实例。但是，大多数Array.prototype方法是通用方法，并不依赖于this值是Array异类对象。 具有“ length”属性，其值为1。 22.1.1.1 Array ( ) 仅当不带参数调用Array构造函数时，此描述才适用。 令 numberOfArgs 为传递给此函数调用的参数数量。 断言：numberOfArgs = 0. 若 NewTarget 是 undefined, 令 newTarget 为活动函数对象，否则令 newTarget 为 NewTarget。 令 proto 为 ? GetPrototypeFromConstructor(newTarget, \"%ArrayPrototype%\"). 返回 ! ArrayCreate(0, proto). 22.1.1.2 Array ( len ) 仅当仅使用一个参数调用Array构造函数时，此描述才适用。 令 numberOfArgs 为传递给此函数调用的参数数量。 断言：numberOfArgs = 1. 若 NewTarget 是 undefined, 令 newTarget 为活动函数对象，否则令 newTarget 为 NewTarget。 令 proto 为 ? GetPrototypeFromConstructor(newTarget, \"%ArrayPrototype%\"). 令 array 为 ! ArrayCreate(0, proto). 若 Type (len) 不是 Number，那么 令 defineStatus 为 CreateDataProperty(array, \"0\", len). 断言：defineStatus 是 true. 令 intLen 为 1. 否则， 令 intLen 为 ToUint32(len). 若 intLen ≠ len, 抛出 RangeError 异常 执行 ! Set(array, \"length\", intLen, true). 返回 array. 22.1.1.3 Array ( ...items ) 仅当使用至少两个参数调用Array构造函数时，此描述才适用。 调用Array函数时，将执行以下步骤： 令 numberOfArgs 为传递给此函数调用的参数数量。 断言：numberOfArgs ≥ 2. 若 NewTarget 是 undefined，令 newTarget 为活动函数对象，否则令 newTarget 为 NewTarget。 令 proto 为 ? GetPrototypeFromConstructor(newTarget, \"%ArrayPrototype%\"). 令 array 为 ? ArrayCreate(numberOfArgs, proto). 令 k 为 0. 令 items 为从零开始的列表，按顺序包含自变量项。 重复，直到 k 令 Pk 为 ! ToString(k). 令 itemK 为 items[k]. 令 defineStatus 为 CreateDataProperty(array, Pk, itemK). 断言：defineStatus 是 true. k 增加 1。 断言：数组的“ length”属性的值为numberOfArgs。 返回 array. 22.1.2 Array 构造器属性 数组构造函数： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 具有以下属性： 22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] ) 当使用参数项和可选参数mapfn和thisArg调用from方法时，将执行以下步骤： 令 C 为 this 值 若 mapfn 是 undefined, 令 mapping 为 false. 否则， 若 IsCallable(mapfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 mapping 为 true. 令 usingIterator 为 ? GetMethod(items, @@iterator). 若 usingIterator 不是 undefined，那么 若 IsConstructor(C) 是 true，那么 令 A 为 ? Construct(C). 否则， 令 A 为 ! ArrayCreate(0). 令 iteratorRecord 为 ? GetIterator(items, sync, usingIterator). 令 k 为 0. 重复, 若 k ≥ 253 - 1，那么 令 error 为 ThrowCompletion(a newly created TypeError object). 返回 ? IteratorClose(iteratorRecord, error). 令 Pk 为 ! ToString(k). 令 next 为 ? IteratorStep(iteratorRecord). 若 next 是 false，那么 执行 ? Set(A, \"length\", k, true). 返回 A. 令 nextValue 为 ? IteratorValue(next). 若 mapping 是 true，那么 令 mappedValue 为 Call(mapfn, T, « nextValue, k »). 若 mappedValue 是突然完成, 返回 ? IteratorClose(iteratorRecord, mappedValue). 设置 mappedValue 为 mappedValue.[[Value]]. 否则，令 mappedValue 为 nextValue. 令 defineStatus 为 CreateDataPropertyOrThrow(A, Pk, mappedValue). 若 defineStatus 是突然完成, 返回 ? IteratorClose(iteratorRecord, defineStatus). k 增加 1。 注意：items不是Iterable，因此假设它是一个类似数组的对象。 令 arrayLike 为 ! ToObject(items). 令 len 为 ? ToLength(? Get(arrayLike, \"length\")). 若 IsConstructor(C) 是 true，那么 令 A 为 ? Construct(C, « len »). 否则， 令 A 为 ? ArrayCreate(len). 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为 ? Get(arrayLike, Pk). 若 mapping 是 true，那么 令 mappedValue 为 ? Call(mapfn, T, « kValue, k »). 否则，令 mappedValue 为 kValue. 执行 ? CreateDataPropertyOrThrow(A, Pk, mappedValue). k 增加 1。 执行 ? Set(A, \"length\", len, true). 返回 A. 22.1.2.2 Array.isArray ( arg ) isArray函数采用一个参数arg，并执行以下步骤： 返回 ? IsArray(arg). 22.1.2.3 Array.of ( ...items ) 当使用任意数量的参数调用of方法时，将执行以下步骤： 令 len 为传递给此函数的实际参数数。 令 items 为传递给此函数的参数列表。 令 C 为 this 值 若 IsConstructor(C) 是 true，那么 令 A 为 ? Construct(C, « len »). 否则， 令 A 为 ? ArrayCreate(len). 令 k 为 0. 重复，直到 k 令 kValue 为 items[k]. 令 Pk 为 ! ToString(k). 执行 ? CreateDataPropertyOrThrow(A, Pk, kValue). k 增加 1。 执行 ? Set(A, \"length\", len, true). 返回 A. 注 1 假设items参数是格式正确的rest参数值。 注 2 of函数是一种有意设计的通用工厂方法；它不需要其this值是Array构造函数。因此，它可以被其他构造函数传递或继承，这些构造函数可以使用单个数字参数调用。 22.1.2.4 Array.prototype Array.prototype的值为％ArrayPrototype％，即固有的Array原型对象。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 22.1.2.5 获取 Array [ @@species ] Array[@@species]是一个访问器属性，它的set访问器函数是undefined。其get访问器函数执行以下步骤: 返回 this 值 该函数的名称属性的值是“ get [Symbol.species]”。 注 数组原型方法通常使用其“此”对象的构造函数来创建派生对象。但是，子类构造函数可以通过重新定义其@@ species属性来覆盖该默认行为。 22.1.3 Array 原型对象属性 数组原型对象： 是内部对象％ArrayPrototype％。 是一个数组异类对象，并具有为此类对象指定的内部方法。 具有“length”属性，其初始值为0，其属性为{ [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 注 将Array原型对象指定为Array异类对象，以确保与ECMAScript 2015规范之前创建的ECMAScript代码兼容。 22.1.3.1 Array.prototype.concat ( ...arguments ) 当使用零个或多个参数调用concat方法时，它将返回一个数组，该数组包含对象的数组元素，然后依次排列每个参数的数组元素。 采取以下步骤： 令 O 为 ? ToObject(this value). 令 A 为 ? ArraySpeciesCreate(O, 0). 令 n 为 0. 令 items 为一个List，其第一个元素为O，其后续元素按从左到右的顺序是传递给此函数调用的参数。 重复，直到 items 不为空 从 items 中删除第一个元素，并让E为元素的值。 令 spreadable 为 ? IsConcatSpreadable(E). 若 spreadable 是 true，那么 令 k 为 0. 令 len 为 ? ToLength(? Get(E, \"length\")). 若 n + len > 253 - 1, 抛出 TypeError 异常 重复，直到 k 令 P 为 ! ToString(k). 令 exists 为 ? HasProperty(E, P). 若 exists 是 true，那么 令 subElement 为 ? Get(E, P). 执行 ? CreateDataPropertyOrThrow(A, ! ToString(n), subElement). n 增加 1。 k 增加 1。 否则E is added as a single item rather than spread, 若 n ≥ 253 - 1, 抛出 TypeError 异常 执行 ? CreateDataPropertyOrThrow(A, ! ToString(n), E). n 增加 1。 执行 ? Set(A, \"length\", n, true). 返回 A. concat方法的“ length”属性为1。 注 1 必须在步骤6中显式设置“length”属性，以确保在不存在结果数组的尾随元素的情况下其值正确。 注 2 concat函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.1.1 RS: IsConcatSpreadable ( O ) 带有参数O的抽象操作IsConcatSpreadable执行以下步骤: 若 Type(O) 不是 Object, 返回 false. 令 spreadable 为 ? Get(O, @@isConcatSpreadable). 若 spreadable 不是 undefined, 返回 ToBoolean(spreadable). 返回 ? IsArray(O). 22.1.3.2 Array.prototype.constructor Array.prototype.constructor 的初始值为内部对象％Array％。 22.1.3.3 Array.prototype.copyWithin ( target, start [ , end ] ) copyWithin方法最多包含三个参数target，start和end。 注 1 end参数是可选的，this 对象的长度是其默认值。如果target是负数，则将其视为length + target，其中length是数组的长度。如果start为负，则将其视为 length + start。如果end为负数，则视为 length + end。 采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 令 relativeTarget 为 ? ToInteger(target). 若 relativeTarget 令 relativeStart 为 ? ToInteger(start). 若 relativeStart 若 end 是 undefined, 令 relativeEnd 为 len; 否则令 relativeEnd 为 ? ToInteger(end). 若 relativeEnd 令 count 为 min(final - from, len - to). 若 from 令 direction 为 -1. 设置 from 为 from + count - 1. 设置 to to 为 + count - 1. 否则， 令 direction 为 1. 重复，直到 count > 0 令 fromKey 为 ! ToString(from). 令 toKey 为 ! ToString(to). 令 fromPresent 为 ? HasProperty(O, fromKey). 若 fromPresent 是 true，那么 令 fromVal 为 ? Get(O, fromKey). 执行 ? Set(O, toKey, fromVal, true). 否则fromPresent 是 false, 执行 ? DeletePropertyOrThrow(O, toKey). 设置 from 为 from + direction. 设置 to 为 to + direction. count 减少 1。 返回 O. 注 2 copyWithin 函数是故意通用的；它不要求它的这个值是一个数组对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 22.1.3.4 Array.prototype.entries ( ) 采取以下步骤： 令 O 为 ? ToObject(this value). 返回 CreateArrayIterator(O, \"key+value\"). 这个函数是%ArrayProto_entries%内部对象。 22.1.3.5 Array.prototype.every ( callbackfn [ , thisArg ] ) 注 1 callbackfn应该是一个接受三个参数并返回可强制转换为布尔值true或false的值的函数。 every对数组中存在的每个元素按升序调用一次callbackfn，直到找到其中callbackfn返回false的元素为止。如果找到了这样的元素，every将立即返回false。否则，如果callbackfn对所有元素都返回true，则“ every”将返回true。仅对实际存在的数组元素调用callbackfn。它不要求缺少数组元素。 如果提供了thisArg参数，则它将用作每次调用callbackfn的this值。如果未提供，则使用undefined。 使用三个参数调用callbackfn：元素的值，元素的索引和要遍历的对象。 “every”都不会直接改变其调用对象，但是可以通过对callbackfn的调用来改变该对象。 “every”处理的元素范围是在第一次调用callbackfn之前设置的。调用every开始之后附加到数组的元素将不会被callbackfn访问。如果改变了数组的现有元素，则它们传递给callbackfn的值将是“every”访问它们时的值；在调用every之后开始并被访问之前删除的元素不会被访问。 “every”在数学上的作用类似于“为所有的”的量词。特别是对于空数组，它返回true。 当使用一个或两个参数调用“every”方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 令 testResult 为 ToBoolean(? Call(callbackfn, T, « kValue, k, O »)). 若 testResult 是 false, 返回 false. k 增加 1。 返回 true. 注 2 “every”功能是有意通用的；它不需要this值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.6 Array.prototype.fill ( value [ , start [ , end ] ] ) fill 方法最多包含三个参数值：value, start 和 end. 注 1 start和end参数是可选的，默认值为0，且此对象的长度为。如果start为负，则将其视为length + start，其中length是数组的长度。如果end为负，则将其视为length + end。 采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 令 relativeStart 为 ? ToInteger(start). 若 relativeStart 若 end 是 undefined, 令 relativeEnd 为 len; 否则令 relativeEnd 为 ? ToInteger(end). 若 relativeEnd 重复，直到 k 令 Pk 为 ! ToString(k). 执行 ? Set(O, Pk, value, true). k 增加 1。 返回 O. 注 2 “ fill”功能是有意通用的；它不需要this值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.7 Array.prototype.filter ( callbackfn [ , thisArg ] ) 注 1 callbackfn应该是一个接受三个参数并返回可强制转换为布尔值true或false的值的函数。 “filter”对数组中的每个元素按升序调用一次callbackfn，并构造一个新数组，其中所有值均由callbackfn返回true。仅对实际存在的数组元素调用callbackfn。它不要求缺少数组元素。 如果提供了thisArg参数，则它将用作每次调用callbackfn的this值。如果未提供，则使用undefined。 使用三个参数调用callbackfn：元素的值，元素的索引和要遍历的对象。 “filter”不会直接改变其调用对象，但是可以通过对callbackfn的调用来改变该对象。 在第一次调用callbackfn之前设置filter处理的元素范围。在调用filter开始之后追加到数组的元素将不会被callbackfn访问。如果改变了数组的现有元素，它们传递给callbackfn的值将是filter访问它们时的值。在调用filter之后开始访问之前删除的元素不会被访问。 When the filter method is called with one or two arguments, 采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 A 为 ? ArraySpeciesCreate(O, 0). 令 k 为 0. 令 to 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 令 selected 为 ToBoolean(? Call(callbackfn, T, « kValue, k, O »)). 若 selected 是 true，那么 执行 ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue). to 增加 1。 k 增加 1。 返回 A. 22.1.3.8 Array.prototype.find ( predicate [ , thisArg ] ) 使用一个或两个参数谓词和thisArg调用“ find”方法。 注 1 谓词应该是一个接受三个参数并返回可强制转换为布尔值的值的函数。 find对数组的每个元素以升序调用一次谓词，直到找到谓词返回true的谓词。如果找到了这样的元素，find将立即返回该元素值。否则，find返回undefined。 如果提供了thisArg参数，则它将用作每次谓词调用的this值。如果未提供，则使用undefined。 用三个参数调用谓词：元素的值，元素的索引和要遍历的对象。 find 不会直接改变在其上调用它的对象，但是可以通过谓词的调用来改变该对象。 在第一次调用谓词之前设置find处理的元素范围。谓词不会访问在对find的调用开始之后追加到数组的元素。如果改变了数组中的现有元素，它们传递给谓词的值将是find访问它们时的值。 当调用find方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(predicate) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为 ? Get(O, Pk). 令 testResult 为 ToBoolean(? Call(predicate, T, « kValue, k, O »)). 若 testResult 是 true, 返回 kValue. k 增加 1。 返回 undefined. 注 2 find函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.9 Array.prototype.findIndex ( predicate [ , thisArg ] ) 注 1 谓词应该是一个接受三个参数并返回可强制转换为布尔值true或false的值的函数。 “ findIndex”对数组中的每个元素以升序调用一次谓词，直到找到谓词返回true的谓词为止。如果找到了这样的元素，则findIndex立即返回该元素值的索引。否则，findIndex返回-1。 如果提供了thisArg参数，则它将用作每次谓词调用的this值。如果未提供，则使用undefined。 用三个参数调用谓词：元素的值，元素的索引和要遍历的对象。 findIndex 不会直接改变在其上调用它的对象，但是可以通过谓词的调用来改变该对象。 由findIndex处理的元素范围是在第一次调用谓词之前设置的。谓词不会访问在开始调用findIndex之后追加到数组的元素。如果改变了数组中的现有元素，它们传递给谓词的值将是findIndex访问它们时的值。 当使用一个或两个参数调用findIndex方法时，采取以下步骤： 22.1.3.10 Array.prototype.flat( [ depth ] ) 当用零个或一个参数调用flat方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 sourceLen 为 ? ToLength(? Get(O, \"length\")). 令 depthNum 为 1. 若 depth 不是 undefined，那么 设置 depthNum 为 ? ToInteger(depth). 令 A 为 ? ArraySpeciesCreate(O, 0). 执行 ? FlattenIntoArray(A, O, sourceLen, 0, depthNum). 返回 A. 22.1.3.10.1 FlattenIntoArray(target, source, sourceLen, start, depth [ , mapperFunction, thisArg ]) 令 targetIndex 为 start. 令 sourceIndex 为 0. 重复，直到 sourceIndex 令 P 为 ! ToString(sourceIndex). 令 exists 为 ? HasProperty(source, P). 若 exists 是 true，那么 令 element 为 ? Get(source, P). 若 mapperFunction 存在，那么 断言：thisArg is present. 设置 element 为 ? Call(mapperFunction, thisArg , « element, sourceIndex, source »). 令 shouldFlatten 为 false. 若 depth > 0，那么 设置 shouldFlatten 为 ? IsArray(element). 若 shouldFlatten 是 true，那么 令 elementLen 为 ? ToLength(? Get(element, \"length\")). 设置 targetIndex 为 ? FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1). 否则， 若 targetIndex ≥ 253-1, 抛出 TypeError 异常 执行 ? CreateDataPropertyOrThrow(target, ! ToString(targetIndex), element). targetIndex 增加 1。 sourceIndex 增加 1。 返回 targetIndex. 22.1.3.11 Array.prototype.flatMap ( mapperFunction [ , thisArg ] ) 当使用一个或两个参数调用“ flatMap”方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 sourceLen 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(mapperFunction) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 A 为 ? ArraySpeciesCreate(O, 0). 执行 ? FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T). 返回 A. 22.1.3.12 Array.prototype.forEach ( callbackfn [ , thisArg ] ) 注 1 callbackfn应该是一个接受三个参数的函数。 forEach对数组中存在的每个元素以升序调用一次callbackfn。仅对实际存在的数组元素调用callbackfn。它不要求缺少数组元素。 如果提供了thisArg参数，则它将用作每次调用callbackfn的this值。如果未提供，则使用undefined。 使用三个参数调用callbackfn：元素的值，元素的索引和要遍历的对象。 forEach 不会直接改变其调用对象，但是可以通过对callbackfn的调用来改变该对象。 当使用一个或两个参数调用forEach方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 执行 ? Call(callbackfn, T, « kValue, k, O »). k 增加 1。 返回 undefined. 此函数是％ArrayProto_forEach％内部对象。 注 2 forEach函数是有意通用的；它不需要this值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.13 Array.prototype.includes ( searchElement [ , fromIndex ] ) 注 1 “ includes”使用SameValueZero算法以升序将searchElement与数组的元素进行比较，如果在任何位置找到，则返回true；否则，返回true。否则，返回false。 可选的第二个参数fromIndex默认为0（即搜索整个数组）。如果它大于或等于数组的长度，则返回false，即将不搜索数组。如果它为负数，则用作从数组末尾开始的偏移量，以计算fromIndex。如果计算的索引小于0，则将搜索整个数组。 当调用includes方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 len 是 0, 返回 false. 令 n 为 ? ToInteger(fromIndex). 断言：If fromIndex is undefined，那么 n is 0. 若 n ≥ 0，那么 令 k 为 n. 否则n 令 k 为 len + n. 若 k 重复，直到 k 令 elementK 为 the result of ? Get(O, ! ToString(k)). 若 SameValueZero(searchElement, elementK) 是 true, 返回 true. k 增加 1。 返回 false. 注2 包含函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 注 3 “includes”方法在两个方面有意不同于类似的“ indexOf”方法。首先，它使用SameValueZero算法而不是严格相等比较，从而可以检测NaN数组元素。其次，它不会跳过缺少的数组元素，而是将它们视为undefined。 22.1.3.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] ) 注 1 indexOf使用严格相等比较算法按升序将searchElement与数组的元素进行比较，如果发现一个或多个索引，则返回最小的索引；否则，返回-1。 可选的第二个参数fromIndex默认为0（即搜索整个数组）。如果它大于或等于数组的长度，则返回-1，即不会搜索该数组。如果它为负数，则用作从数组末尾开始的偏移量，以计算fromIndex。如果计算的索引小于0，则将搜索整个数组。 当使用一个或两个参数调用indexOf方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 len 是 0, 返回 -1. 令 n 为 ? ToInteger(fromIndex). 断言：If fromIndex is undefined，那么 n is 0. 若 n ≥ len, 返回 -1. 若 n ≥ 0，那么 若 n 是 -0, 令 k 为 +0; 否则令 k 为 n. 否则n 令 k 为 len + n. 若 k 重复，直到 k 令 kPresent 为 ? HasProperty(O, ! ToString(k)). 若 kPresent 是 true，那么 令 elementK 为 ? Get(O, ! ToString(k)). 令 same 为执行严格相等比较searchElement === elementK的结果。 若 same 是 true, 返回 k. k 增加 1。 返回 -1. 注 2 indexOf函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.15 Array.prototype.join ( separator ) 注 1 数组的元素将转换为字符串，然后将这些字符串连接起来，并根据出现的分隔符进行分隔。如果未提供分隔符，则使用单个逗号作为分隔符。 join方法采用一个参数，分隔符，并执行以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 separator 是 undefined, 令 sep 为 \",\". 否则，令 sep 为 ? ToString(separator). 令 R 为空字符串。 令 k 为 0. 重复，直到 k 若 k > 0,将R设置为R和sep的字符串连接。 令 element 为 ? Get(O, ! ToString(k)). 若 element 是 undefined 或 null, 令 next 为空字符串; 否则, 令 next 为 ? ToString(element). 设置 R 为 R 和 next 的字符串连接。 k 增加 1。 返回 R. 注 2 “ join”功能是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他种类的对象中用作方法。 22.1.3.16 Array.prototype.keys ( ) 采取以下步骤： 令 O 为 ? ToObject(this value). 返回 CreateArrayIterator(O, \"key\"). 此函数是％ArrayProto_keys％内部对象。 22.1.3.17 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] ) 注 1 “ lastIndexOf”使用严格相等比较算法按降序将searchElement与数组元素进行比较，如果在一个或多个索引处找到，则返回最大的索引；否则，返回-1。 可选的第二个参数fromIndex默认为数组的长度减去一（即搜索整个数组）。如果它大于或等于数组的长度，则将搜索整个数组。如果它为负数，则用作从数组末尾开始的偏移量，以计算fromIndex。如果计算的索引小于0，则返回-1。 当使用一个或两个参数调用“ lastIndexOf”方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 len 是 0, 返回 -1. 若 fromIndex 存在, 令 n 为 ? ToInteger(fromIndex); 否则令 n 为 len - 1. 若 n ≥ 0，那么 若 n 是 -0, 令 k 为 +0; 否则令 k 为 min(n, len - 1). 否则n 令 k 为 len + n. 重复，直到 k ≥ 0 令 kPresent 为 ? HasProperty(O, ! ToString(k)). 若 kPresent 是 true，那么 令 elementK 为 ? Get(O, ! ToString(k)). 令 same 为执行严格相等比较searchElement === elementK的结果。 若 same 是 true, 返回 k. k 减少 1。 返回 -1. 注 2 lastIndexOf函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.18 Array.prototype.map ( callbackfn [ , thisArg ] ) 注 1 callbackfn应该是一个接受三个参数的函数。 map会对数组中的每个元素按升序调用一次callbackfn，然后从结果中构造一个新的Array。仅对实际存在的数组元素调用callbackfn。它不要求缺少数组元素。 如果提供了thisArg参数，则它将用作每次调用callbackfn的this值。如果未提供，则使用undefined。 使用三个参数调用callbackfn：元素的值，元素的索引和要遍历的对象。 map 不会直接改变其调用对象，但是可以通过对callbackfn的调用来改变该对象。 在第一次调用callbackfn之前设置由map处理的元素范围。在调用map之后开始后追加到数组的元素将不会被callbackfn访问。如果改变了数组的现有元素，它们传递给callbackfn的值将是map访问它们时的值；在调用map之后开始但被访问之前删除的元素不会被访问。 当使用一个或两个参数调用map方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 A 为 ? ArraySpeciesCreate(O, len). 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 令 mappedValue 为 ? Call(callbackfn, T, « kValue, k, O »). 执行 ? CreateDataPropertyOrThrow(A, Pk, mappedValue). k 增加 1。 返回 A. 注 2 map函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.19 Array.prototype.pop ( ) 注 1 数组的最后一个元素从数组中删除并返回。 When the pop method is called, 采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 len 是 zero，那么 执行 ? Set(O, \"length\", 0, true). 返回 undefined. 否则len > 0, 令 newLen 为 len - 1. 令 index 为 ! ToString(newLen). 令 element 为 ? Get(O, index). 执行 ? DeletePropertyOrThrow(O, index). 执行 ? Set(O, \"length\", newLen, true). 返回 element. 注 2 “ pop”功能是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.20 Array.prototype.push ( ...items ) 注 1 参数按照它们出现的顺序附加到数组的末尾。调用的结果将返回数组的新长度。 当使用零个或多个参数调用push方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 令 items 为一个列表，其元素按从左到右的顺序是传递给此函数调用的参数。 令 argCount 为 items 中元素的数量。 若 len + argCount > 253 - 1, 抛出 TypeError 异常 重复，直到 items 不为空 从 items 中删除第一个元素，并且令 E 为元素的值。 执行 ? Set(O, ! ToString(len), E, true). len 增加 1。 执行 ? Set(O, \"length\", len, true). 返回 len. push方法的“ length”属性为1。 注 2 push函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.21 Array.prototype.reduce ( callbackfn [ , initialValue ] ) 注 1 callbackfn应该是一个带有四个参数的函数。 “ reduce”作为函数，对数组中第一个元素之后的每个元素以升序调用一次回调。 使用四个参数调用callbackfn：previousValue（从上次调用callbackfn的值），currentValue（当前元素的值），currentIndex和要遍历的对象。首次调用回调时，previousValue和currentValue可以是两个值之一。如果在reduce的调用中提供了initialValue，则previousValue将等于initialValue，而currentValue将等于数组中的第一个值。如果未提供initialValue，则previousValue将等于数组中的第一个值，而currentValue将等于第二个值。如果数组不包含任何元素并且未提供initialValue，则为TypeError。 reduce 不会直接改变其调用对象，但是可以通过对callbackfn的调用来改变该对象。 由reduce处理的元素范围在第一次调用callbackfn之前设置。在调用reduce开始之后追加到数组的元素将不会被callbackfn访问。如果数组的现有元素被更改，则传递给callbackfn的值将是reduce访问它们时的值；开始调用reduce之后被删除的元素不会被访问。 当使用一个或两个参数调用reduce方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 len is 0 and initialValue 不存在, 抛出 TypeError 异常 令 k 为 0. 令 accumulator 为 undefined. 若 initialValue 存在，那么 设置 accumulator 为 initialValue. 否则initialValue不存在, 令 kPresent 为 false. 重复，直到 kPresent 是 false 并且 k 令 Pk 为 ! ToString(k). 设置 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 设置 accumulator 为 ? Get(O, Pk). k 增加 1。 若 kPresent 是 false, 抛出 TypeError 异常 重复，直到 k 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 设置 accumulator 为 ? Call(callbackfn, undefined, « accumulator, kValue, k, O »). k 增加 1。 返回 accumulator. 注 2 “ reduce”功能是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.22 Array.prototype.reduceRight ( callbackfn [ , initialValue ] ) 注 1 callbackfn应该是一个带有四个参数的函数。 “ reduceRight”作为函数对数组中第一个元素之后的每个元素按降序调用一次回调。 使用四个参数调用callbackfn：previousValue（从上次调用callbackfn的值），currentValue（当前元素的值），currentIndex和要遍历的对象。第一次调用该函数时，previousValue和currentValue可以是两个值之一。如果在对reduceRight的调用中提供了initialValue，则previousValue将等于initialValue，而currentValue将等于数组中的最后一个值。如果未提供initialValue，则previousValue将等于数组中的最后一个值，而currentValue将等于倒数第二个值。如果数组不包含任何元素并且未提供initialValue，则为TypeError。 reduceRight 不会直接改变其调用对象，但是可以通过对callbackfn的调用来改变该对象。 由reduceRight处理的元素范围是在第一次调用callbackfn之前设置的。在调用reduceRight开始之后追加到数组的元素将不会被callbackfn访问。如果数组的现有元素被callbackfn更改，则传递给callbackfn的值将是reduceRight访问它们时的值；在调用reduceRight之后并且被访问之前删除的元素不会被访问。 当使用一个或两个参数调用reduceRight方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 len is 0 and initialValue 不存在, 抛出 TypeError 异常 令 k 为 len - 1. 令 accumulator 为 undefined. 若 initialValue 存在，那么 设置 accumulator 为 initialValue. 否则initialValue不存在, 令 kPresent 为 false. 重复，直到 kPresent 是 false 并且 k ≥ 0 令 Pk 为 ! ToString(k). 设置 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 设置 accumulator 为 ? Get(O, Pk). k 减少 1。 若 kPresent 是 false, 抛出 TypeError 异常 重复，直到 k ≥ 0 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 设置 accumulator 为 ? Call(callbackfn, undefined, « accumulator, kValue, k, O »). k 减少 1。 返回 accumulator. 注 2 “ reduceRight”功能是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为一种方法。 22.1.3.23 Array.prototype.reverse ( ) 注 1 重新排列数组的元素，以便颠倒其顺序。该对象作为调用的结果返回。 当调用“ reverse”方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 令 middle 为 floor(len / 2). 令 lower 为 0. 重复，直到 lower ≠ middle 令 upper 为 len - lower - 1. 令 upperP 为 ! ToString(upper). 令 lowerP 为 ! ToString(lower). 令 lowerExists 为 ? HasProperty(O, lowerP). 若 lowerExists 是 true，那么 令 lowerValue 为 ? Get(O, lowerP). 令 upperExists 为 ? HasProperty(O, upperP). 若 upperExists 是 true，那么 令 upperValue 为 ? Get(O, upperP). 若 lowerExists is true and upperExists 是 true，那么 执行 ? Set(O, lowerP, upperValue, true). 执行 ? Set(O, upperP, lowerValue, true). 否则if lowerExists is false and upperExists is true，那么 执行 ? Set(O, lowerP, upperValue, true). 执行 ? DeletePropertyOrThrow(O, upperP). 否则if lowerExists is true and upperExists is false，那么 执行 ? DeletePropertyOrThrow(O, lowerP). 执行 ? Set(O, upperP, lowerValue, true). 否则both lowerExists and upperExists are false, No action is required. lower 增加 1。 返回 O. 注 2 reverse 功能是有意通用的。它不需要此值是Array对象。因此，可以将其转移到其他种类的对象中用作方法。 22.1.3.24 Array.prototype.shift ( ) 注 1 数组的第一个元素从数组中删除并返回。s 当调用shift方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 len 是 zero，那么 执行 ? Set(O, \"length\", 0, true). 返回 undefined. 令 first 为 ? Get(O, \"0\"). 令 k 为 1. 重复，直到 k 令 from 为 ! ToString(k). 令 to 为 ! ToString(k - 1). 令 fromPresent 为 ? HasProperty(O, from). 若 fromPresent 是 true，那么 令 fromVal 为 ? Get(O, from). 执行 ? Set(O, to, fromVal, true). 否则fromPresent 是 false, 执行 ? DeletePropertyOrThrow(O, to). k 增加 1。 执行 ? DeletePropertyOrThrow(O, ! ToString(len - 1)). 执行 ? Set(O, \"length\", len - 1, true). 返回 first. 注 2 shift 功能是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为一种方法。 22.1.3.25 Array.prototype.slice ( start, end ) 注 1 slice方法有两个参数start和end，并返回一个数组，该数组包含从元素开始到元素结束（但不包括元素结束）（如果undefinedend，则从数组的结尾）开始的数组的元素。如果start为负，则将其视为length + start，其中length是数组的长度。如果end为负，则将其视为length + end，其中length是数组的长度。 采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 令 relativeStart 为 ? ToInteger(start). 若 relativeStart 若 end 是 undefined, 令 relativeEnd 为 len; 否则令 relativeEnd 为 ? ToInteger(end). 若 relativeEnd 令 count 为 max(final - k, 0). 令 A 为 ? ArraySpeciesCreate(O, count). 令 n 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 执行 ? CreateDataPropertyOrThrow(A, ! ToString(n), kValue). k 增加 1。 n 增加 1。 执行 ? Set(A, \"length\", n, true). 返回 A. 注 2 在早期版本的ECMAScript中，必须在步骤11中显式设置结果数组的“长度”属性，以确保在不存在结果数组尾随元素的情况下其长度正确。从ES2015开始，当结果Array初始化为适当的长度而不是一个空Array时，就不必设置“ length”了，但是继续进行以保持向后兼容性。 注 3 slice功能是有意通用的。它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为一种方法。 22.1.3.26 Array.prototype.some ( callbackfn [ , thisArg ] ) 注 1 callbackfn应该是一个接受三个参数并返回可强制转换为布尔值true或false的值的函数。 some对数组中存在的每个元素以升序调用一次callbackfn，直到找到其中callbackfn返回true的元素为止。如果找到了这样的元素，some将立即返回true。否则，“ some”将返回false。仅对实际存在的数组元素调用callbackfn。它不要求缺少数组元素。 如果提供了thisArg参数，则它将用作每次调用callbackfn的this值。如果未提供，则使用undefined。 使用三个参数调用callbackfn：元素的值，元素的索引和要遍历的对象。 some 不会直接改变其调用对象，但是可以通过对callbackfn的调用来改变该对象。 在首次调用callbackfn之前设置由some处理的元素范围。在调用some之后开始后附加到数组的元素将不会被callbackfn访问。如果数组的现有元素被更改，则传递给callbackfn的值将是“ some”访问它们时的值。在调用some之后开始但被访问之前删除的元素不会被访问。 “某些”行为就像数学中的“存在”量词一样。特别是对于空数组，它返回false。 当使用一些参数调用“ some”方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kPresent 为 ? HasProperty(O, Pk). 若 kPresent 是 true，那么 令 kValue 为 ? Get(O, Pk). 令 testResult 为 ToBoolean(? Call(callbackfn, T, « kValue, k, O »)). 若 testResult 是 true, 返回 true. k 增加 1。 返回 false. 注 2 some函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为一种方法。 22.1.3.27 Array.prototype.sort ( comparefn ) 此数组的元素已排序。排序必须是稳定的（也就是说，比较相等的元素必须保持其原始顺序）。如果comparefn不是undefined，则它应该是一个接受两个参数x和y的函数，如果x y，则返回正值。 输入后，将执行以下步骤来初始化对sort函数的解释执行： 若 comparefn 不是 undefined 并且 IsCallable(comparefn) 是 false, 抛出 TypeError 异常 令 obj 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(obj, \"length\")). 在此sort方法的规范中，如果以下算法返回true，则将对象obj称为稀疏： 对于范围 0 ≤ i 令 elem 为 obj.[[GetOwnProperty]](! ToString(i)). 若 elem 是 undefined, 返回 true. 返回 false. sort order 是此函数完成后对整数索引小于len的obj的整数索引属性值的排序。然后按以下方式确定“ sort”函数的结果： 如果comparefn不是undefined，并且不是该数组元素的一致比较函数（请参见下文），则排序顺序是实现定义的。如果undefinedcomparefn并且SortCompare不用作一致的比较函数，则排序顺序也是由实现定义的。 设proto为obj.[[GetPrototypeOf]]()。如果proto不为空，且存在一个整数j，满足以下所有条件，则排序顺序由实现定义: obj 是稀疏的 0 ≤ j HasProperty(proto, ToString(j)) 是 true 如果obj是稀疏的，并且下列条件为真，则排序顺序也是实现定义的: IsExtensible(obj) 是 false. obj的任何整数索引属性，如果其名称是非负整数，且小于len，那么它就是一个数据属性，其[[Configurable]]属性为false。 如果下列条件为真，排序顺序也是实现定义的: 如果obj是一个异类对象(包括代理异类对象)，它对[[Get]]、[[Set]]、[[Delete]]和[[GetOwnProperty]]的行为不是这些内部方法的普通对象实现。 如果obj的任何索引属性的名称是小于len的非负整数，那么它就是一个访问器属性，或者是一个数据属性，它的[[Writable]]属性是假的。 如果comparefn是undefined，并且ToString的应用程序对作为SortCompare参数传递的任何值修改obj或obj的原型链上的任何对象。 如果comparefn是undefined，并且ToString的所有应用程序，对于作为参数传递给SortCompare的任何特定值，都不会产生相同的结果。 采取以下步骤： 执行调用obj的[[Get]]和[[Set]]内部方法的一个与实现相关的序列，调用DeletePropertyOrThrow和HasOwnProperty抽象操作，obj作为第一个参数，并进行SortCompare(如下所述)，这样: 每个调用[[Get]]、[[Set]]、HasOwnProperty或DeletePropertyOrThrow的属性键参数是小于len的非负整数的字符串表示。 SortCompare调用的参数是之前调用[[Get]]内部方法返回的值，除非之前调用访问的属性根据HasOwnProperty不存在。如果SortCompare的两个预期参数都对应于不存在的属性，则使用+0而不是调用SortCompare。如果第一个预期参数不存在，就使用+1。若只有第二个潜在的论点是不存在使用1。 如果obj不是稀疏的，那么就不能调用DeletePropertyOrThrow。 如果任何[[Set]]调用返回false，则抛出一个类型错误异常。 如果从这些操作中返回一个突然完成，它将立即作为该函数的值返回。 返回 obj. 除非上面指定了实现定义的排序顺序，否则返回的对象必须具有以下两个特征: 非负整数必须存在一些小于 len 的数学置换 π，以便对于每个小于 len 的非负整数 j，如果存在 old[j] 属性，则 new[π(j)] 与 old[j] 完全相同。但是，如果属性 old[j] 不存在，则 new[π(j)] 不存在。 然后，对于所有小于len的所有非负整数j和k，若 SortCompare(old[j], old[k]) 这里，old[j] 表示在执行这个函数之前调用 obj.[[Get]](j) 的假设结果，new[j] 表示在执行这个函数之后调用 obj.[[Get]](j) 的假设结果。 如果集合S中的所有值A、b和c(可能是相同的值)都满足下列所有要求，则函数comparefn是一组值S的一致比较函数：符号A CF b表示比较fn(a, b) > 0。 调用comparefn(a, b)总是返回相同的值v，当给定一对特定的值a和b作为它的两个参数时。而且，类型(v)是Number，而v不是NaN。注意，这意味着a CF b中的一个对于给定的a和b是正确的。 调用comparefn(a, b)不会修改obj或obj原型链上的任何对象。 a =CF a (reflexivity) 若 a =CF b, 那么 b =CF a (自反性) 若 a =CF b 并且 b =CF c, 那么 a =CF c ( =CF 的传递性) 若 a 若 a >CF b 并且 b >CF c, 那么 a >CF c ( >CF 的传递性) 注 1 上述条件是充分必要的，可以保证comparefn将集合S分成等价类，并且这些等价类是完全有序的。 注 2 ‘sort’函数是故意通用的；它不要求它的这个值是一个数组对象。因此，它可以作为一种方法转移到其他类型的对象中去使用。 22.1.3.27.1 RS: SortCompare ( x, y ) SortCompare抽象操作由两个参数x和y调用，它还可以访问传递给当前调用的‘sort’方法的comparefn参数。采取以下步骤： 若 x 和 y 都是 undefined, 返回 +0. 若 x 是 undefined, 返回 1. 若 y 是 undefined, 返回 -1. 若 comparefn 不是 undefined，那么 令 v 为 ? ToNumber(? Call(comparefn, undefined, « x, y »)). 若 v 是 NaN, 返回 +0. 返回 v. 令 xString 为 ? ToString(x). 令 yString 为 ? ToString(y). 令 xSmaller 为执行抽象关系比较xString 若 xSmaller 是 true, 返回 -1. 令 ySmaller 为执行抽象关系比较yString 若 ySmaller 是 true, 返回 1. 返回 +0. 注 1 因为不存在的属性值总是比undefined属性值大，而且undefined属性值总是比任何其他值大，所以undefined属性值总是排序到结果的末尾，然后是不存在的属性值。 注 2 第5步和第7步中的ToString抽象操作执行的方法调用可能会导致SortCompare表现为不一致的比较函数。 22.1.3.28 Array.prototype.splice ( start, deleteCount, ...items ) 注 1 当使用两个或多个参数start (deleteCount和零个或多个项目)调用“splice”方法时，从整数索引开始的数组的deleteCount元素将被参数项替换。返回一个包含已删除元素(如果有)的数组对象。 采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 令 relativeStart 为 ? ToInteger(start). 若 relativeStart 若实际参数的数量是 0，那么 令 insertCount 为 0. 令 actualDeleteCount 为 0. 否则如果实际参数的数目为1，那么 令 insertCount 为 0. 令 actualDeleteCount 为 len - actualStart. 否则， 令 insertCount 为 令 dc 为 ? ToInteger(deleteCount). 令 actualDeleteCount 为 min(max(dc, 0), len - actualStart). 若 len + insertCount - actualDeleteCount > 253 - 1, 抛出 TypeError 异常 令 A 为 ? ArraySpeciesCreate(O, actualDeleteCount). 令 k 为 0. 重复，直到 k 令 from 为 ! ToString(actualStart + k). 令 fromPresent 为 ? HasProperty(O, from). 若 fromPresent 是 true，那么 令 fromValue 为 ? Get(O, from). 执行 ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue). Increment k by 1. 执行 ? Set(A, \"length\", actualDeleteCount, true). 令 items 为一个列表，其元素按从左到右的顺序是实际参数列表中从第三个参数开始的部分。如果传递的参数少于三个，则该列表为空。 令 itemCount 为 items 中元素的数量。 若 itemCount 设置 k 为 actualStart. 重复，直到 k 令 from 为 ! ToString(k + actualDeleteCount). 令 to 为 ! ToString(k + itemCount). 令 fromPresent 为 ? HasProperty(O, from). 若 fromPresent 是 true，那么 令 fromValue 为 ? Get(O, from). 执行 ? Set(O, to, fromValue, true). 否则fromPresent 是 false, 执行 ? DeletePropertyOrThrow(O, to). k 增加 1。 设置 k 为 len. 重复，直到 k > (len - actualDeleteCount + itemCount) 执行 ? DeletePropertyOrThrow(O, ! ToString(k - 1)). k 减少 1。 否则if itemCount > actualDeleteCount，那么 设置 k 为 (len - actualDeleteCount). 重复，直到 k > actualStart 令 from 为 ! ToString(k + actualDeleteCount - 1). 令 to 为 ! ToString(k + itemCount - 1). 令 fromPresent 为 ? HasProperty(O, from). 若 fromPresent 是 true，那么 令 fromValue 为 ? Get(O, from). 执行 ? Set(O, to, fromValue, true). 否则fromPresent 是 false, 执行 ? DeletePropertyOrThrow(O, to). k 减少 1。 设置 k 为 actualStart. 重复，直到 items 不为空 从 items 中删除第一个元素，并且令 E 为该元素的值。 执行 ? Set(O, ! ToString(k), E, true). k 增加 1。 执行 ? Set(O, \"length\", len - actualDeleteCount + itemCount, true). 返回 A. 注 2 在早期版本的ECMAScript中，必须在步骤19中显式设置结果数组的“length”属性，以确保在不存在结果数组尾随元素的情况下其长度正确。从ES2015开始，当结果Array初始化为适当的长度（而不是一个空Array）时，就不必再设置“ length”了，而是继续进行以保持向后兼容性。 注 3 splice功能是有意通用的。它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.29 Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] ) 包含ECMA-402国际化API的ECMAScript实现必须实现ECMA-402规范中指定的Array.prototype.toLocaleString方法。如果ECMAScript实现不包含ECMA-402 API，则使用以下toLocaleString方法的规范。 注 1 ECMA-402的第一版未包含Array.prototype.toLocaleString方法的替代规范。 ECMA-402规范中定义了此方法的可选参数的含义；不包含ECMA-402支持的实现不得将这些参数位置用于其他任何用途。 采取以下步骤： 令 array 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(array, \"length\")). 令 separator 为列表分隔符String的String值，该值适用于主机环境的当前语言环境（以实现定义的方式派生）。 令 R 为空字符串. 令 k 为 0. 重复，直到 k 若 k > 0，那么 设置 R 为R和分隔符的字符串连接。 令 nextElement 为 ? Get(array, ! ToString(k)). 若 nextElement 不是 undefined 或吧 null，那么 令 S 为 ? ToString(? Invoke(nextElement, \"toLocaleString\")). 设置 R 为R和S的字符串连接。 k 增加 1。 返回 R. 注 2 数组的元素使用其toLocaleString方法转换为String，然后将这些String串联起来，并通过出现以实现定义的特定于区域的方式派生的分隔符String进行分隔。调用此函数的结果旨在类似于“ toString”的结果，不同之处在于此函数的结果旨在特定于语言环境。 注 3 toLocaleString函数是有意通用的。它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.30 Array.prototype.toString ( ) 当调用toString方法时，采取以下步骤： 令 array 为 ? ToObject(this value). 令 func 为 ? Get(array, \"join\"). 若 IsCallable(func) 是 false，将func设置为固有函数％ObjProto_toString％ 返回 ? Call(func, array). 注 toString函数是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.31 Array.prototype.unshift ( ...items ) 注 1 自变量位于数组的开头，因此它们在数组中的顺序与在自变量列表中出现的顺序相同。 当使用零个或多个参数item1，item2等调用unshift方法时，采取以下步骤： 令 O 为 ? ToObject(this value). 令 len 为 ? ToLength(? Get(O, \"length\")). 令 argCount 为 the number of actual arguments. 若 argCount > 0，那么 若 len + argCount > 253 - 1, 抛出 TypeError 异常 令 k 为 len. 重复，直到 k > 0, 令 from 为 ! ToString(k - 1). 令 to 为 ! ToString(k + argCount - 1). 令 fromPresent 为 ? HasProperty(O, from). 若 fromPresent 是 true，那么 令 fromValue 为 ? Get(O, from). 执行 ? Set(O, to, fromValue, true). 否则fromPresent is false, 执行 ? DeletePropertyOrThrow(O, to). k 减少 1。 令 j 为 0. 令 items 为一个列表，其元素按从左到右的顺序是传递给此函数调用的参数。 重复，直到 items 不为空 从 items 中删除第一个元素， 并且令 E 为该元素的值。 执行 ? Set(O, ! ToString(j), E, true). j 增加 1。 执行 ? Set(O, \"length\", len + argCount, true). 返回 len + argCount. unshift方法的“ length”属性为1。 注 2 “ unshift”功能是有意通用的；它不需要此值是Array对象。因此，可以将其转移到其他类型的对象中作为方法。 22.1.3.32 Array.prototype.values ( ) 采取以下步骤： 令 O 为 ? ToObject(this value). 返回 CreateArrayIterator(O, \"value\"). 此函数是％ArrayProto_values％内部对象。 22.1.3.33 Array.prototype [ @@iterator ] ( ) @@iterator属性的初始值与Array.prototype.values属性的初始值是同一函数对象。 22.1.3.34 Array.prototype [ @@unscopables ] @@unscopables数据属性的初始值是通过以下步骤创建的对象： 令 unscopableList 为 ObjectCreate(null). 执行 CreateDataProperty(unscopableList, \"copyWithin\", true). 执行 CreateDataProperty(unscopableList, \"entries\", true). 执行 CreateDataProperty(unscopableList, \"fill\", true). 执行 CreateDataProperty(unscopableList, \"find\", true). 执行 CreateDataProperty(unscopableList, \"findIndex\", true). 执行 CreateDataProperty(unscopableList, \"flat\", true). 执行 CreateDataProperty(unscopableList, \"flatMap\", true). 执行 CreateDataProperty(unscopableList, \"includes\", true). 执行 CreateDataProperty(unscopableList, \"keys\", true). 执行 CreateDataProperty(unscopableList, \"values\", true). 断言：Each of the above calls 返回s true. 返回 unscopableList. 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 注 该对象自己的属性名称是ECMAScript 2015规范之前未包含在Array.prototype的标准属性中的属性名称。出于“ with”语句绑定的目的，这些名称被忽略，以保留现有代码的行为，这些代码可能将这些名称之一用作外部作用域中的绑定，而外部作用域由“ with”语句遮蔽，该对象的绑定对象是一个Array对象。 。 22.1.4 Array 实例属性 数组实例是数组异类对象，并具有为此类对象指定的内部方法。数组实例从Array原型对象继承属性。 数组实例具有“ length”属性和一组带有数组索引名称的可枚举属性。 22.1.4.1 length Array实例的“ length”属性是一个数据属性，其值在数值上总是大于名称为数组索引的每个可配置自己的属性的名称。 “ length”属性最初具有属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. 注 减小“ length”属性的值具有删除自己的数组元素（其数组索引在新旧长度值之间）的副作用。但是，无法删除不可配置的属性。尝试将Array对象的“ length”属性设置为一个数值，该数值在数值上小于或等于该数组现有不可配置的数组索引属性的最大数值自身属性名称，这将导致该长度为设置为一个数字值，该数字值比不可配置的数字自身属性名称大一。见9.4.2.1。 22.1.5 Array 迭代器对象 数组迭代器是一个对象，它表示对某些特定Array实例对象的特定迭代。数组迭代器对象没有命名的构造函数。而是，通过调用Array实例对象的某些方法来创建Array迭代器对象。 22.1.5.1 CreateArrayIterator ( array, kind ) Array对象的几种方法返回Iterator对象。具有参数array和kind的抽象操作CreateArrayIterator用于创建此类迭代器对象。它执行以下步骤： 断言：Type(array) 是 Object. 令 iterator 为 ObjectCreate(%ArrayIteratorPrototype%, « [[IteratedObject]], [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] »). 设置 iterator.[[IteratedObject]] 为 array. 设置 iterator.[[ArrayIteratorNextIndex]] 为 0. 设置 iterator.[[ArrayIterationKind]] 为 kind. 返回 iterator. 22.1.5.2 The %ArrayIteratorPrototype% Object ％ArrayIterator原型％对象： 具有所有数组迭代器对象继承的属性。 是一个普通的对象。 有一个[[Prototype]]内部插槽，其值是内部对象％IteratorPrototype％。 具有以下属性： 22.1.5.2.1 %ArrayIteratorPrototype%.next ( ) 令 O 为 this 值 若 Type(O) 不是 Object, 抛出 TypeError 异常 若 O 没有数组迭代器实例（22.1.5.3）的所有内部插槽，抛出 TypeError 异常 令 a 为 O.[[IteratedObject]]. 若 a 是 undefined, 返回 CreateIterResultObject(undefined, true). 令 index 为 O.[[ArrayIteratorNextIndex]]. 令 itemKind 为 O.[[ArrayIterationKind]]. 若 a 有 [[TypedArrayName]] 内部插槽，那么 若 IsDetachedBuffer(a.[[ViewedArrayBuffer]]) 是 true, 抛出 TypeError 异常 令 len 为 a.[[ArrayLength]]. 否则， 令 len 为 ? ToLength(? Get(a, \"length\")). 若 index ≥ len，那么 设置 O.[[IteratedObject]] 为 undefined. 返回 CreateIterResultObject(undefined, true). 设置 O.[[ArrayIteratorNextIndex]] 为 index + 1. 若 itemKind 是 \"key\", 返回 CreateIterResultObject(index, false). 令 elementKey 为 ! ToString(index). 令 elementValue 为 ? Get(a, elementKey). 若 itemKind 是 \"value\", 令 result 为 elementValue. 否则， 断言：itemKind is \"key+value\". 令 result 为 CreateArrayFromList(« index, elementValue »). 返回 CreateIterResultObject(result, false). 22.1.5.2.2 %ArrayIteratorPrototype% [ @@toStringTag ] @@toStringTag属性的初始值为字符串值“数组迭代器”。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 22.1.5.3 Properties of Array Iterator Instances 数组迭代器实例是从％ArrayIteratorPrototype％内部对象继承属性的普通对象。最初使用表58中列出的内部插槽创建阵列迭代器实例。 表58：数组迭代器实例的内部插槽 内部插槽 描述 [[IteratedObject]] 要迭代其数组元素的对象。 [[ArrayIteratorNextIndex]] 此迭代要检查的下一个整数索引的整数索引。 [[ArrayIterationKind]] 一个String值，用于标识迭代的每个元素返回的内容。可能的值为： \"key\", \"value\", \"key+value\". 22.2 类数组对象 TypedArray对象表示基础二进制数据缓冲区（24.1）的类似数组的视图。 TypedArray实例的每个元素都具有相同的基础二进制标量数据类型。表59中列出了九种受支持元素类型中的每一个的独特TypedArray构造函数。表59中的每个构造函数都有一个对应的不同原型对象。 表59：TypedArray构造函数 构造函数名称和本征 元素类型 元素类型 转换操作 描述 等效C类 型 Int8Array %Int8Array% Int8 1 ToInt8 8位2的补码有符号整数 signed char Uint8Array %Uint8Array% Uint8 1 ToUint8 8位无符号整数 unsigned char Uint8ClampedArray %Uint8ClampedArray% Uint8C 1 ToUint8Clamp 8位无符号整数（强制转换） unsigned char Int16Array %Int16Array% Int16 2 ToInt16 16位2的补码有符号整数 short Uint16Array %Uint16Array% Uint16 2 ToUint16 16位无符号整数 unsigned short Int32Array %Int32Array% Int32 4 ToInt32 32位2的补码有符号整数 int Uint32Array %Uint32Array% Uint32 4 ToUint32 32位无符号整数 unsigned int Float32Array %Float32Array% Float32 4 32位IEEE浮点 float Float64Array %Float64Array% Float64 8 64位IEEE浮点 double 在下面的定义中，对TypedArray的引用应替换为上表中的相应构造函数名称。短语“以字节为单位的元素大小”是指表中与构造函数对应的行的“元素大小”列中的值。短语“元素类型”是指该行的“元素类型”列中的值。 22.2.1 %TypedArray% 内部对象 ％TypedArray％内部对象： 是所有TypedArray构造函数对象都继承的构造函数对象。 连同其相应的原型对象一起，提供了所有TypedArray构造函数及其实例继承的公共属性。 没有全局名称或作为全局对象的属性出现。 充当各种TypedArray构造函数的抽象超类。 调用时将引发错误，因为它是抽象类的构造函数。 TypedArray构造函数不会对其执行“ super”调用。 22.2.1.1 %TypedArray% ( ) ％TypedArray％构造函数执行以下步骤： 抛出 TypeError 异常 ％TypedArray％构造函数的“ length”属性为0。 22.2.2 %TypedArray% 内部对象属性 ％TypedArray％内部对象： 有一个[[Prototype]]内部插槽，其值是内部对象％FunctionPrototype％。 有一个“name”属性，其值为“ TypedArray”。 具有以下属性： 22.2.2.1 %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] ) 当使用参数source和可选参数mapfn和thisArg调用from方法时，采取以下步骤： 令 C 为 this 值 若 IsConstructor(C) 是 false, 抛出 TypeError 异常 若 mapfn is present and mapfn 不是 undefined，那么 若 IsCallable(mapfn) 是 false, 抛出 TypeError 异常 令 mapping 为 true. 否则，令 mapping 为 false. 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 usingIterator 为 ? GetMethod(source, @@iterator). 若 usingIterator 不是 undefined，那么 令 values 为 ? IterableToList(source, usingIterator). 令 len 为 the number of elements in values. 令 targetObj 为 ? TypedArrayCreate(C, « len »). 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为值的第一个元素，然后从值中删除该元素。 若 mapping 是 true，那么 令 mappedValue 为 ? Call(mapfn, T, « kValue, k »). 否则，令 mappedValue 为 kValue. 执行 ? Set(targetObj, Pk, mappedValue, true). k 增加 1。 断言：values现在是一个空列表。 返回 targetObj. 注: source不是Iterable，因此假设它已经是一个类似数组的对象。 令 arrayLike 为 ! ToObject(source). 令 len 为 ? ToLength(? Get(arrayLike, \"length\")). 令 targetObj 为 ? TypedArrayCreate(C, « len »). 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为 ? Get(arrayLike, Pk). 若 mapping 是 true，那么 令 mappedValue 为 ? Call(mapfn, T, « kValue, k »). 否则，令 mappedValue 为 kValue. 执行 ? Set(targetObj, Pk, mappedValue, true). k 增加 1。 返回 targetObj. 22.2.2.1.1Runtime Semantics: IterableToList ( items, method ) 抽象操作IterableToList执行以下步骤： 令 iteratorRecord 为 ? GetIterator(items, sync, method). 令 values 为一个新的空列表 令 next 为 true. 重复，直到 next 不为 false 设置 next 为 ? IteratorStep(iteratorRecord). 若 next 不是 false，那么 令 nextValue 为 ? IteratorValue(next). Append nextValue to the end of the List values. 返回 values. 22.2.2.2 %TypedArray%.of ( ...items ) 当使用任意数量的参数调用of方法时，采取以下步骤： 令 len 为传递给此函数的实际参数数。 令 items 为传递给此函数的参数列表。 令 C 为 this 值 若 IsConstructor(C) 是 false, 抛出 TypeError 异常 令 newObj 为 ? TypedArrayCreate(C, « len »). 令 k 为 0. 重复，直到 k 令 kValue 为 items[k]. 令 Pk 为 ! ToString(k). 执行 ? Set(newObj, Pk, kValue, true). k 增加 1。 返回 newObj. 注 假设items参数是格式正确的rest参数值。 22.2.2.3 %TypedArray%.prototype ％TypedArray％.prototype 的初始值为％TypedArrayPrototype％内部对象。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 22.2.2.4 get %TypedArray% [ @@species ] ％TypedArray％[@@ species]是一个访问器属性，其设置的访问器功能undefined。它的get访问器功能执行以下步骤： 返回 this 值 该函数的名称属性的值是“ get [Symbol.species]”。 注 ％TypedArrayPrototype％方法通常使用其“此”对象的构造函数来创建派生对象。但是，子类构造函数可以通过重新定义其@@ species属性来覆盖该默认行为。 22.2.3 %TypedArrayPrototype% 对象属性 ％TypedArray原型％对象： 有一个[[Prototype]]内部插槽，其值是内部对象％ObjectPrototype％。 是一个普通的对象。 没有[[ViewedArrayBuffer]]或任何其他TypedArray实例对象专用的内部插槽。 22.2.3.1 获取 %TypedArray%.prototype.buffer ％TypedArray％.prototype.buffer是一个访问器属性，其设置的访问器函数undefined。它的get访问器功能执行以下步骤： 令 O 为 this 值 若 Type(O) 不是 Object, 抛出 TypeError 异常 若 O 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：O 有 [[ViewedArrayBuffer]] 内部插槽。 令 buffer 为 O.[[ViewedArrayBuffer]]. 返回 buffer. 22.2.3.2 获取 %TypedArray%.prototype.byteLength ％TypedArray％.prototype.byteLength是一个访问器属性，其设置的访问器功能undefined。它的get访问器功能执行以下步骤： 令 O 为 this 值 若 Type(O) 不是 Object, 抛出 TypeError 异常 若 O 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：O 有 [[ViewedArrayBuffer]] 内部插槽. 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 返回 0. 令 size 为 O.[[ByteLength]]. 返回 size. 22.2.3.3 获取 %TypedArray%.prototype.byteOffset ％TypedArray％.prototype.byteOffset是一个访问器属性，其设置的访问器功能undefined。它的get访问器功能执行以下步骤： 令 O 为 this 值 若 Type(O) 不是 Object, 抛出 TypeError 异常 若 O 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：O 有 [[ViewedArrayBuffer]] 内部插槽. 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 返回 0. 令 offset 为 O.[[ByteOffset]]. 返回 offset. 22.2.3.4 %TypedArray%.prototype.constructor ％TypedArray％.prototype.constructor 的初始值为％TypedArray％内部对象。 22.2.3.5 %TypedArray%.prototype.copyWithin ( target, start [ , end ] ) ％TypedArray％.prototype.copyWithin的参数的解释和使用与22.1.3.3中定义的 Array.prototype.copyWithin 相同。 采取以下步骤： 令 O 为 this 值. 执行 ? ValidateTypedArray(O). 令 len 为 O.[[ArrayLength]]. 令 relativeTarget 为 ? ToInteger(target). 若 relativeTarget 令 relativeStart 为 ? ToInteger(start). 若 relativeStart 若 end 是 undefined, 令 relativeEnd 为 len; 否则令 relativeEnd 为 ? ToInteger(end). 若 relativeEnd 令 count 为 min(final - from, len - to). 若 count > 0，那么 注意：必须以保留源数据的位级别编码的方式执行复制。 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 抛出 TypeError 异常 令 typedArrayName 为 O.[[TypedArrayName]] 的字符串值. 令 elementSize 为表59中为typedArrayName指定的Element Size值的Number值。 令 byteOffset 为 O.[[ByteOffset]]. 令 toByteIndex 为 to × elementSize + byteOffset. 令 fromByteIndex 为 from × elementSize + byteOffset. 令 countBytes 为 count × elementSize. 若 fromByteIndex 令 direction 为 -1. 设置 fromByteIndex 为 fromByteIndex + countBytes - 1. 设置 toByteIndex 为 toByteIndex + countBytes - 1. 否则， 令 direction 为 1. 重复，直到 countBytes > 0 令 value 为 GetValueFromBuffer(buffer, fromByteIndex, \"Uint8\", true, \"Unordered\"). 执行 SetValueInBuffer(buffer, toByteIndex, \"Uint8\", value, true, \"Unordered\"). 设置 fromByteIndex 为 fromByteIndex + direction. 设置 toByteIndex 为 toByteIndex + direction. countBytes 减少 1。 返回 O. 22.2.3.5.1 RS: ValidateTypedArray ( O ) 当使用参数O调用时，采取以下步骤： 若 Type(O) 不是 Object, 抛出 TypeError 异常 若 O 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：O 有 [[ViewedArrayBuffer]] 内部插槽. 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 抛出 TypeError 异常 返回 buffer. 22.2.3.6 %TypedArray%.prototype.entries ( ) 采取以下步骤： 令 O 为 this 值 执行 ? ValidateTypedArray(O). 返回 CreateArrayIterator(O, \"key+value\"). 22.2.3.7 %TypedArray%.prototype.every ( callbackfn [ , thisArg ] ) ％TypedArray％.prototype.every是与22.1.3.5中定义的 Array.prototype.every 实现相同算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，此类优化不得在算法的指定行为中引入任何可观察的变化，并且必须考虑对callbackfn的调用可能导致此值分离的可能性。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.8 %TypedArray%.prototype.fill ( value [ , start [ , end ] ] ) ％TypedArray％.prototype.fill参数的解释和使用与22.1.3.6中定义的Array.prototype.fill相同。 采取以下步骤： 令 O 为 this 值 执行 ? ValidateTypedArray(O). 令 len 为 O.[[ArrayLength]]. 设置 value 为 ? ToNumber(value). 令 relativeStart 为 ? ToInteger(start). 若 relativeStart 若 end 是 undefined, 令 relativeEnd 为 len; 否则令 relativeEnd 为 ? ToInteger(end). 若 relativeEnd 若 IsDetachedBuffer(O.[[ViewedArrayBuffer]]) 是 true, 抛出 TypeError 异常 重复，直到 k 令 Pk 为 ! ToString(k). 执行 ! Set(O, Pk, value, true). k 增加 1。 返回 O. 22.2.3.9 %TypedArray%.prototype.filter ( callbackfn [ , thisArg ] ) ％TypedArray％.prototype.filter参数的解释和使用与22.1.3.7中定义的Array.prototype.filter相同。 当使用一个或两个参数调用filter方法时，采取以下步骤： 令 O 为 this 值 执行 ? ValidateTypedArray(O). 令 len 为 O.[[ArrayLength]]. 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 kept 为一个新的空列表。 令 k 为 0. 令 captured 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为 ? Get(O, Pk). 令 selected 为 ToBoolean(? Call(callbackfn, T, « kValue, k, O »)). 若 selected 是 true，那么 将kValue追加到keep的末尾。 captured 增加 1。 k 增加 1。 令 A 为 ? TypedArraySpeciesCreate(O, « captured »). 令 n 为 0. 对于保留的每个元素e， 执行 ! Set(A, ! ToString(n), e, true). Increment n by 1. 返回 A. 此功能不是通用的。此值必须是具有[[TypedArrayName]]内部插槽的对象。 22.2.3.10 %TypedArray%.prototype.find ( predicate [ , thisArg ] ) ％TypedArray％.prototype.find是一个与22.1.3.8中定义的'Array.prototype.find`相同的算法，其不同之处在于该对象的[[ArrayLength]]内部插槽被访问以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化，并且必须考虑谓词调用可能导致该值分离的可能性。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.11 %TypedArray%.prototype.findIndex ( predicate [ , thisArg ] ) ％TypedArray％.prototype.findIndex是一个独特的函数，实现与22.1.3.9中定义的“ Array.prototype.findIndex`”相同的算法，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化，并且必须考虑谓词调用可能导致该值分离的可能性。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.12 %TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] ) ％TypedArray％.prototype.forEach是一个独特的函数，实现了与22.1.3.12中定义的Array.prototype.forEach相同的算法，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，此类优化不得在算法的指定行为中引入任何可观察的变化，并且必须考虑对callbackfn的调用可能导致此值分离的可能性。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.13 %TypedArray%.prototype.includes ( searchElement [ , fromIndex ] ) ％TypedArray％.prototype.includes是与22.1.3.13中定义的实现相同算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.14 %TypedArray%.prototype.indexOf ( searchElement [ , fromIndex ] ) ％TypedArray％.prototype.indexOf是一个独特的函数，实现与22.1.3.14中定义的 Array.prototype.indexOf 相同的算法，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.15 %TypedArray%.prototype.join ( separator ) ％TypedArray％.prototype.join是一个与22.1.3.15中定义的实现相同算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.16 %TypedArray%.prototype.keys ( ) 采取以下步骤： 令 O 为 this 值 执行 ? ValidateTypedArray(O). 返回 CreateArrayIterator(O, \"key\"). 22.2.3.17 %TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] ) ％TypedArray％.prototype.lastIndexOf是一个与22.1.3.17定义的实现相同算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.18 获取 %TypedArray%.prototype.length ％TypedArray％.prototype.length是一个访问器属性，其设置的访问器函数undefined。它的get访问器功能执行以下步骤： 令 O 为 this 值 若 Type(O) 不是 Object, 抛出 TypeError 异常 若 O 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots. 令 buffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(buffer) 是 true, 返回 0. 令 length 为 O.[[ArrayLength]]. 返回 length. 此功能不是通用的。此值必须是具有[[TypedArrayName]]内部插槽的对象。 22.2.3.19 %TypedArray%.prototype.map ( callbackfn [ , thisArg ] ) ％TypedArray％.prototype.map参数的解释和使用与22.1.3.18中定义的Array.prototype.map相同。 当使用一个或两个参数调用map方法时，采取以下步骤： 令 O 为 this 值 执行 ? ValidateTypedArray(O). 令 len 为 O.[[ArrayLength]]. 若 IsCallable(callbackfn) 是 false, 抛出 TypeError 异常 若 thisArg 存在, 令 T 为 thisArg; 否则令 T 为 undefined. 令 A 为 ? TypedArraySpeciesCreate(O, « len »). 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为 ? Get(O, Pk). 令 mappedValue 为 ? Call(callbackfn, T, « kValue, k, O »). 执行 ? Set(A, Pk, mappedValue, true). k 增加 1。 返回 A. 此功能不是通用的。此值必须是具有[[TypedArrayName]]内部插槽的对象。 22.2.3.20 %TypedArray%.prototype.reduce ( callbackfn [ , initialValue ] ) ％TypedArray％.prototype.reduce是一个独特的函数，其实现与22.1.3.21中定义的“ Array.prototype.reduce”相同的算法，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，此类优化不得在算法的指定行为中引入任何可观察的变化，并且必须考虑对callbackfn的调用可能导致此值分离的可能性。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.21 %TypedArray%.prototype.reduceRight ( callbackfn [ , initialValue ] ) ％TypedArray％.prototype.reduceRight是一个与22.1.3.22中定义的实现与Array.prototype.reduceRight相同的算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，此类优化不得在算法的指定行为中引入任何可观察的变化，并且必须考虑对callbackfn的调用可能导致此值分离的可能性。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.22 %TypedArray%.prototype.reverse ( ) ％TypedArray％.prototype.reverse是与22.1.3.23中定义的实现相同算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.23 %TypedArray%.prototype.set ( overloaded [ , offset ] ) ％TypedArray％.prototype.set是一个函数，其行为根据其第一个参数的类型而重载。 此功能不是通用的。此值必须是具有[[TypedArrayName]]内部插槽的对象。 22.2.3.23.1 %TypedArray%.prototype.set ( array [ , offset ] ) 在此TypedArray中设置多个值，从对象数组中读取值。可选的offset值指示此TypedArray中写入值的第一个元素索引。如果省略，则假定为0。 断言：数组是除带有[[TypedArrayName]]内部插槽的对象以外的任何ECMAScript语言值。如果是这样的对象，则适用22.2.3.23.2中的定义。 令 target 为 this 值 若 Type(target) 不是 Object, 抛出 TypeError 异常 若 target 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：target 有 [[ViewedArrayBuffer]] 内部插槽. 令 targetOffset 为 ? ToInteger(offset). 若 targetOffset 令 targetBuffer 为 target.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(targetBuffer) 是 true, 抛出 TypeError 异常 令 targetLength 为 target.[[ArrayLength]]. 令 targetName 为 target.[[TypedArrayName]] 的字符串值. 令 targetElementSize 为表59中为targetName指定的元素大小值的Number值。 令 targetType 为表59中targetName的元素类型值的字符串值。 令 targetByteOffset 为 target.[[ByteOffset]]. 令 src 为 ? ToObject(array). 令 srcLength 为 ? ToLength(? Get(src, \"length\")). 若 srcLength + targetOffset > targetLength, 抛出 RangeError 异常 令 targetByteIndex 为 targetOffset × targetElementSize + targetByteOffset. 令 k 为 0. 令 limit 为 targetByteIndex + targetElementSize × srcLength. 重复，直到 targetByteIndex 令 Pk 为 ! ToString(k). 令 kNumber 为 ? ToNumber(? Get(src, Pk)). 若 IsDetachedBuffer(targetBuffer) 是 true, 抛出 TypeError 异常 执行 SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber, true, \"Unordered\"). k 增加 1。 设置 targetByteIndex 为 targetByteIndex + targetElementSize. 返回 undefined. 22.2.3.23.2 %TypedArray%.prototype.set ( typedArray [ , offset ] ) 在此TypedArray中设置多个值，并从typedArray参数对象中读取值。可选的offset值指示此TypedArray中写入值的第一个元素索引。如果省略，则假定为0。 断言：typedArray 有 [[TypedArrayName]] 内部插槽。如果不是，则适用22.2.3.23.1中的定义。 令 target 为 this 值 若 Type(target) 不是 Object, 抛出 TypeError 异常 若 target 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：target 有 [[ViewedArrayBuffer]] 内部插槽. 令 targetOffset 为 ? ToInteger(offset). 若 targetOffset 令 targetBuffer 为 target.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(targetBuffer) 是 true, 抛出 TypeError 异常 令 targetLength 为 target.[[ArrayLength]]. 令 srcBuffer 为 typedArray.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(srcBuffer) 是 true, 抛出 TypeError 异常 令 targetName 为 target.[[TypedArrayName]] 的字符串值。 令 targetType 为表59中targetName的元素类型值的字符串值。 令 targetElementSize 为表59中为targetName指定的元素大小值的Number值。 令 targetByteOffset 为 target.[[ByteOffset]]. 令 srcName 为 typedArray.[[TypedArrayName]] 的字符串值。 令 srcType 为表59中srcName的元素类型值的字符串值。 令 srcElementSize 为表59中为srcName指定的元素大小值的Number值。 令 srcLength 为 typedArray.[[ArrayLength]]. 令 srcByteOffset 为 typedArray.[[ByteOffset]]. 若 srcLength + targetOffset > targetLength, 抛出 RangeError 异常 若 IsSharedArrayBuffer(srcBuffer) 和 IsSharedArrayBuffer(targetBuffer) 均为true，那么 若 srcBuffer.[[ArrayBufferData]] 并且 targetBuffer.[[ArrayBufferData]]是相同的共享数据块值， 令 same 为 true; 否则令 same 为 false. 否则，令 same 为 SameValue(srcBuffer, targetBuffer). 若 same 是 true，那么 令 srcByteLength 为 typedArray.[[ByteLength]]. 设置 srcBuffer 为 ? CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, %ArrayBuffer%). 注意：％ArrayBuffer％用于克隆srcBuffer，因为已知它没有任何可观察到的副作用。 令 srcByteIndex 为 0. 否则，令 srcByteIndex 为 srcByteOffset. 令 targetByteIndex 为 targetOffset × targetElementSize + targetByteOffset. 令 limit 为 targetByteIndex + targetElementSize × srcLength. 若 SameValue(srcType, targetType) 是 true，那么 注意：如果srcType和targetType相同，则必须以保留源数据的位级编码的方式执行传输。 重复，直到 targetByteIndex 令 value 为 GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\", true, \"Unordered\"). 执行 SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value, true, \"Unordered\"). srcByteIndex 增加 1。 targetByteIndex 增加 1。 否则， 重复，直到 targetByteIndex 令 value 为 GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, \"Unordered\"). 执行 SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, \"Unordered\"). 设置 srcByteIndex 为 srcByteIndex + srcElementSize. 设置 targetByteIndex 为 targetByteIndex + targetElementSize. 返回 undefined. 22.2.3.24 %TypedArray%.prototype.slice ( start, end ) ％TypedArray％.prototype.slice的参数的解释和使用与22.1.3.25中定义的Array.prototype.slice相同。采取以下步骤： 令 O 为 this 值 执行 ? ValidateTypedArray(O). 令 len 为 O.[[ArrayLength]]. 令 relativeStart 为 ? ToInteger(start). 若 relativeStart 若 end 是 undefined, 令 relativeEnd 为 len; 否则令 relativeEnd 为 ? ToInteger(end). 若 relativeEnd 令 count 为 max(final - k, 0). 令 A 为 ? TypedArraySpeciesCreate(O, « count »). 令 srcName 为 O.[[TypedArrayName]] 的字符串值。 令 srcType 为表59中srcName的元素类型值的字符串值。 令 targetName 为 A.[[TypedArrayName]] 的字符串值。 令 targetType 为表59中targetName的元素类型值的字符串值。 若 SameValue(srcType, targetType) 是 false，那么 令 n 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为 ? Get(O, Pk). 执行 ! Set(A, ! ToString(n), kValue, true). k 增加 1。 n 增加 1。 否则if count > 0，那么 令 srcBuffer 为 O.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(srcBuffer) 是 true, 抛出 TypeError 异常 令 targetBuffer 为 A.[[ViewedArrayBuffer]]. 令 elementSize 为表59中为srcType指定的元素大小值的Number值。 注意：如果srcType和targetType相同，则必须以保留源数据的位级编码的方式执行传输。 令 srcByteOffet 为 O.[[ByteOffset]]. 令 targetByteIndex 为 A.[[ByteOffset]]. 令 srcByteIndex 为 (k × elementSize) + srcByteOffet. 令 limit 为 targetByteIndex + count × elementSize. 重复，直到 targetByteIndex 令 value 为 GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\", true, \"Unordered\"). 执行 SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value, true, \"Unordered\"). srcByteIndex 增加 1。 targetByteIndex 增加 1。 返回 A. 此功能不是通用的。此值必须是具有[[TypedArrayName]]内部插槽的对象。 22.2.3.25 %TypedArray%.prototype.some ( callbackfn [ , thisArg ] ) ％TypedArray％.prototype.some是一个与22.1.3.26中定义的实现相同算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，此类优化不得在算法的指定行为中引入任何可观察的变化，并且必须考虑对callbackfn的调用可能导致此值分离的可能性。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 22.2.3.26 %TypedArray%.prototype.sort ( comparefn ) ％TypedArray％.prototype.sort是一个独特的函数，除了如下所述，它实现的功能与Array.prototype.sort的要求相同，如22.1.3.27中所定义。可以使用以下知识来优化％TypedArray％.prototype.sort规范的实现：该值是一个具有固定长度且整数索引属性不稀疏的对象。算法可能会调用此对象的唯一内部方法是[[Get]]和[[Set]]。 此功能不是通用的。此值必须是具有[[TypedArrayName]]内部插槽的对象。 输入后，执行以下步骤以初始化排序功能的解释执行。这些步骤代替了22.1.3.27中的输入步骤： 若 comparefn 不是 undefined 并且 IsCallable(comparefn) 是 false, 抛出 TypeError 异常 令 obj 为 this 值 令 buffer 为 ? ValidateTypedArray(obj). 令 len 为 obj.[[ArrayLength]]. ％TypedArray％.prototype.sort不应用异类对象的实现定义的排序顺序条件。 ％TypedArray％.prototype.sort使用以下版本的SortCompare。它执行数字比较，而不是22.1.3.27中使用的字符串比较。 SortCompare可以访问sort方法当前调用的comparefn和buffer值。 当使用两个参数x和y调用TypedArray SortCompare抽象操作时，采取以下步骤： 断言：Type(x) 和 Type(y) 都为 Number. 若 comparefn 不是 undefined，那么 令 v 为 ? ToNumber(? Call(comparefn, undefined, « x, y »)). 若 IsDetachedBuffer(buffer) 是 true, 抛出 TypeError 异常 若 v 是 NaN, 返回 +0. 返回 v. 若 x and y are both NaN, 返回 +0. 若 x 是 NaN, 返回 1. 若 y 是 NaN, 返回 -1. 若 x 若 x > y, 返回 1. 若 x is -0 and y 是 +0, 返回 -1. 若 x is +0 and y 是 -0, 返回 1. 返回 +0. 注 因为NaN总是比较大于任何其他值，所以当不提供comparefn时，NaN属性值总是排序到结果的末尾。 22.2.3.27 %TypedArray%.prototype.subarray ( begin, end ) 返回一个新的TypedArray对象，该对象的元素类型与此TypedArray相同，并且其ArrayBuffer与此TypedArray的ArrayBuffer相同，并在开始（包括），直到结束（不包括）之间引用元素。如果begin或end为负，则它是指数组末尾的索引，而不是开头的索引。 令 O 为 this 值 若 Type(O) 不是 Object, 抛出 TypeError 异常 若 O 没有 [[TypedArrayName]] 内部插槽, 抛出 TypeError 异常 断言：O 有 [[ViewedArrayBuffer]] 内部插槽. 令 buffer 为 O.[[ViewedArrayBuffer]]. 令 srcLength 为 O.[[ArrayLength]]. 令 relativeBegin 为 ? ToInteger(begin). 若 relativeBegin 若 end 是 undefined, 令 relativeEnd 为 srcLength; 否则, 令 relativeEnd 为 ? ToInteger(end). 若 relativeEnd 令 newLength 为 max(endIndex - beginIndex, 0). 令 constructorName 为 O.[[TypedArrayName]] 的字符串值。 令 elementSize 为表59中为constructorName指定的元素大小值的Number值。 令 srcByteOffset 为 O.[[ByteOffset]]. 令 beginByteOffset 为 srcByteOffset + beginIndex × elementSize. 令 argumentsList 为 « buffer, beginByteOffset, newLength ». 返回 ? TypedArraySpeciesCreate(O, argumentsList). 此功能不是通用的。此值必须是具有[[TypedArrayName]]内部插槽的对象。 22.2.3.28 %TypedArray%.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] ) ％TypedArray％.prototype.toLocaleString是一个与22.1.3.29中定义的实现与Array.prototype.toLocaleString相同的算法的独特函数，除了访问此对象的[[ArrayLength]]内部插槽以代替执行[length]的[[Get]]。可以使用以下知识来优化算法的实现：该值是一个具有固定长度的对象，并且其整数索引属性不稀疏。但是，这种优化不得在算法的指定行为中引入任何可观察到的变化。 此功能不是通用的。在解释执行算法之前，将ValidateTypedArray应用于此值。如果其结果是突然完成，则抛出该异常，而不是解释执行算法。 注 如果ECMAScript实现包含ECMA-402国际化API，则此函数基于ECMA-402规范中的Array.prototype.toLocaleString算法。 22.2.3.29 %TypedArray%.prototype.toString ( ) ％TypedArray％.prototype.toString数据属性的初始值是与22.1.3.30中定义的Array.prototype.toString`方法相同的内置函数对象。 22.2.3.30 %TypedArray%.prototype.values ( ) 采取以下步骤： 令 O 为 this 值 执行 ? ValidateTypedArray(O). 返回 CreateArrayIterator(O, \"value\"). 22.2.3.31 %TypedArray%.prototype [ @@iterator ] ( ) @@ iterator属性的初始值是与％TypedArray％.prototype.values属性的初始值相同的函数对象。 22.2.3.32 获取 %TypedArray%.prototype [ @@toStringTag ] ％TypedArray％.prototype [@@ toStringTag]是一个访问器属性，其设置的访问器功能undefined。它的get访问器功能执行以下步骤： 令 O 为 this 值 若 Type(O) 不是 Object, 返回 undefined. 若 O 没有 [[TypedArrayName]] 内部插槽, 返回 undefined. 令 name 为 O.[[TypedArrayName]]. 断言：Type(name) is String. 返回 name. 此属性具有特性 { [[Enumerable]]: false, [[Configurable]]: true }. 此函数的name属性的初始值为“ get [Symbol.toStringTag]”。 22.2.4 TypedArray 构造器 每个TypedArray构造函数： 是一个内部对象，具有以下描述的结构，仅在用作表59中的TypedArray而不是用作构造函数名称的名称上有所不同。 是一个函数，其行为根据其参数的数量和类型而重载。调用TypedArray的实际行为取决于传递给它的参数的数量和种类。 并非旨在作为函数调用，并且以这种方式调用时将引发异常。 设计为可归类的。它可以用作类定义的extends子句的值。打算继承指定TypedArray行为的子类构造函数必须包括对TypedArray构造函数的“超级”调用，以使用支持％TypedArray％.prototype内置方法所必需的内部状态来创建和初始化子类实例。 具有一个“ length”属性，其值为3。 22.2.4.1 TypedArray ( ) 仅当不带参数调用TypedArray函数时，此描述才适用。 若 NewTarget 是 undefined, 抛出 TypeError 异常 令 constructorName 为表59中为此TypedArray构造函数指定的构造函数名称值的字符串值。 返回 ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", 0). 22.2.4.2 TypedArray ( length ) 仅当使用至少一个参数调用TypedArray函数且第一个参数的类型不是Object时，此描述才适用。 以参数长度调用的TypedArray执行以下步骤： 断言：Type(length) 不是 Object. 若 NewTarget 是 undefined, 抛出 TypeError 异常 令 elementLength 为 ? ToIndex(length). 令 constructorName 为表59中为此TypedArray构造函数指定的构造函数名称值的字符串值。 返回 ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", elementLength). 22.2.4.2.1 RS: AllocateTypedArray ( constructorName, newTarget, defaultProto [ , length ] ) 带有参数构造函数名、newTarget、defaultProto和可选参数长度的抽象操作AllocateTypedArray用于验证和创建TypedArray构造函数的实例。表59中的TypedArray构造函数的名称需要使用constructorName。若长度参数传递,一个ArrayBuffer长度也分配和与新TypedArray实例相关联。AllocateTypedArray提供了共同的语义,是由所有TypedArray过载使用。AllocateTypedArray执行以下步骤: 令 proto 为 ? GetPrototypeFromConstructor(newTarget, defaultProto). 令 obj 为 IntegerIndexedObjectCreate(proto, « [[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »). 断言：obj.[[ViewedArrayBuffer]] is undefined. 设置 obj.[[TypedArrayName]] 为 constructorName. 若 length 不存在，那么 设置 obj.[[ByteLength]] 为 0. 设置 obj.[[ByteOffset]] 为 0. 设置 obj.[[ArrayLength]] 为 0. 否则， 执行 ? AllocateTypedArrayBuffer(obj, length). 返回 obj. 22.2.4.2.2 RS: AllocateTypedArrayBuffer ( O, length ) 带有参数O和长度的抽象操作AllocateTypedArrayBuffer将ArrayBuffer与TypedArray实例O进行分配和关联。 断言：O 是有 [[ViewedArrayBuffer]] 内部插槽的 Object . 断言：O.[[ViewedArrayBuffer]] 是 undefined. 断言：length ≥ 0. 令 constructorName 为 O.[[TypedArrayName]] 的字符串值。 令 elementSize 为表59中构造名的元素大小值。 令 byteLength 为 elementSize × length. 令 data 为 ? AllocateArrayBuffer(%ArrayBuffer%, byteLength). 设置 O.[[ViewedArrayBuffer]] 为 data. 设置 O.[[ByteLength]] 为 byteLength. 设置 O.[[ByteOffset]] 为 0. 设置 O.[[ArrayLength]] 为 length. 返回 O. 22.2.4.3 TypedArray ( typedArray ) 这个描述仅适用于如果TypedArray函数至少有一个参数，第一个参数的类型是对象，对象有[[TypedArrayName]]内部插槽。 使用参数TypedArray调用TypedArray执行以下步骤: 断言：Type(typedArray) 是 Object，并且 typedArray 有 [[TypedArrayName]] 内部插槽. 若 NewTarget 是 undefined, 抛出 TypeError 异常 令 constructorName 为表59中为此类型darray构造函数指定的构造函数名称值的字符串值。 令 O 为 ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\"). 令 srcArray 为 typedArray. 令 srcData 为 srcArray.[[ViewedArrayBuffer]]. 若 IsDetachedBuffer(srcData) 是 true, 抛出 TypeError 异常 令 elementType 为表59中构造名的元素类型值的字符串值。 令 elementLength 为 srcArray.[[ArrayLength]]. 令 srcName 为 srcArray.[[TypedArrayName]] 的字符串值。 令 srcType 为表59中srcName的元素类型值的字符串值。 令 srcElementSize 为srcName表59中的元素大小值。 令 srcByteOffset 为 srcArray.[[ByteOffset]]. 令 elementSize 为表59中构造名的元素大小值。 令 byteLength 为 elementSize × elementLength. 若 IsSharedArrayBuffer(srcData) 是 false，那么 令 bufferConstructor 为 ? SpeciesConstructor(srcData, %ArrayBuffer%). 否则， 令 bufferConstructor 为 %ArrayBuffer%. 若 SameValue(elementType, srcType) 是 true，那么 令 data 为 ? CloneArrayBuffer(srcData, srcByteOffset, byteLength, bufferConstructor). 否则， 令 data 为 ? AllocateArrayBuffer(bufferConstructor, byteLength). 若 IsDetachedBuffer(srcData) 是 true, 抛出 TypeError 异常 令 srcByteIndex 为 srcByteOffset. 令 targetByteIndex 为 0. 令 count 为 elementLength. 重复，直到 count > 0 令 value 为 GetValueFromBuffer(srcData, srcByteIndex, srcType, true, \"Unordered\"). 执行 SetValueInBuffer(data, targetByteIndex, elementType, value, true, \"Unordered\"). 设置 srcByteIndex 为 srcByteIndex + srcElementSize. 设置 targetByteIndex 为 targetByteIndex + elementSize. Decrement count by 1. 设置 O.[[ViewedArrayBuffer]] 为 data. 设置 O.[[ByteLength]] 为 byteLength. 设置 O.[[ByteOffset]] 为 0. 设置 O.[[ArrayLength]] 为 elementLength. 返回 O. 22.2.4.4 TypedArray ( object ) 这种描述只适用于以下情况:使用至少一个参数调用TypedArray函数，并且第一个参数的类型是Object，而该对象既没有[[TypedArrayName]]，也没有[[ArrayBufferData]]内部槽。 使用参数对象调用TypedArray执行以下步骤: 断言：Type(object) 是 Object 并且 object 既没有[[TypedArrayName]]，也没有[[ArrayBufferData]]内部槽。 若 NewTarget 是 undefined, 抛出 TypeError 异常 令 constructorName 为表59中为此类型darray构造函数指定的构造函数名称值的字符串值。 令 O 为 ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\"). 令 usingIterator 为 ? GetMethod(object, @@iterator). 若 usingIterator 不是 undefined，那么 令 values 为 ? IterableToList(object, usingIterator). 令 len 为值中元素的数量。 执行 ? AllocateTypedArrayBuffer(O, len). 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为值的第一个元素并从值中删除该元素。 执行 ? Set(O, Pk, kValue, true). k 增加 1。 断言：值现在是一个空列表。 返回 O. 注意：对象不是一个可迭代的，所以假设它已经是一个类似数组的对象。 令 arrayLike 为 object. 令 len 为 ? ToLength(? Get(arrayLike, \"length\")). 执行 ? AllocateTypedArrayBuffer(O, len). 令 k 为 0. 重复，直到 k 令 Pk 为 ! ToString(k). 令 kValue 为 ? Get(arrayLike, Pk). 执行 ? Set(O, Pk, kValue, true). k 增加 1。 返回 O. 22.2.4.5 TypedArray ( buffer [ , byteOffset [ , length ] ] ) 这种描述只适用于以下情况:使用至少一个参数调用TypedArray函数，且第一个参数的类型是Object，且该对象具有[[ArrayBufferData]]内部槽。 使用至少一个参数缓冲区调用TypedArray执行以下步骤: 断言：类型(buffer)是对象，buffer有一个[[ArrayBufferData]]内部槽。 若 NewTarget 是 undefined, 抛出 TypeError 异常 令 constructorName 指定为构造函数的名称值在表59 TypedArray构造函数的字符串值。 令 O 为 ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\"). 令 elementSize 为表59中用于构造名称的元素大小值的数值。 令 offset 为 ? ToIndex(byteOffset). 若 offset modulo elementSize ≠ 0, 抛出 RangeError 异常 若 length 存在，并且 length 不是 undefined，那么 令 newLength 为 ? ToIndex(length). 若 IsDetachedBuffer(buffer) 是 true, 抛出 TypeError 异常 令 bufferByteLength 为 buffer.[[ArrayBufferByteLength]]. 若 length 是不存在的或为 undefined 的，那么 若 bufferByteLength modulo elementSize ≠ 0, 抛出 RangeError 异常 令 newByteLength 为 bufferByteLength - offset. 若 newByteLength 否则， 令 newByteLength 为 newLength × elementSize. 若 offset + newByteLength > bufferByteLength, 抛出 RangeError 异常 设置 O.[[ViewedArrayBuffer]] 为 buffer. 设置 O.[[ByteLength]] 为 newByteLength. 设置 O.[[ByteOffset]] 为 offset. 设置 O.[[ArrayLength]] 为 newByteLength / elementSize. 返回 O. 22.2.4.6 TypedArrayCreate ( constructor, argumentList ) 带有参数构造函数和argumentList的抽象操作TypedArrayCreate用于指定使用构造函数创建一个新的TypedArray对象。它执行以下步骤: 令 newTypedArray 为 ? Construct(constructor, argumentList). 执行 ? ValidateTypedArray(newTypedArray). 若 argumentList 是 a List of a single Number，那么 若 newTypedArray.[[ArrayLength]] 返回 newTypedArray. 22.2.4.7 TypedArraySpeciesCreate ( exemplar, argumentList ) 带有参数范例和参数列表的抽象操作TypedArraySpeciesCreate用于指定使用来自范例的构造函数创建一个新的TypedArray对象。它执行以下步骤: 断言：exemplar 是有 [[TypedArrayName]] 内部插槽的 Object. 令 defaultConstructor 为表59的第一列中列出的内在对象的范例[[TypedArrayName]]。 令 constructor 为 ? SpeciesConstructor(exemplar, defaultConstructor). 返回 ? TypedArrayCreate(constructor, argumentList). 22.2.5 TypedArray 构造器属性 每个TypedArray构造函数: 有 [[Prototype]] 内部插槽其值为内部对象%TypedArray%。 是否有一个name属性，其值是表59中为其指定的构造函数名称的字符串值。 具有以下特性： 22.2.5.1 TypedArray.BYTES_PER_ELEMENT TypedArray的值。BYTES_PER_ELEMENT是表59中为TypedArray指定的元素大小值的数值。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 22.2.5.2 TypedArray.prototype TypedArray.prototype 的初始值为相应的 TypedArray 原型内部对象（22.2.6）。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 22.2.6 TypedArray 原型对象属性 每个TypedArray原型对象： 有 [[Prototype]] 内部插槽其值是内部对象％TypedArrayPrototype％。 是一个普通的对象。 没有 [[ViewedArrayBuffer]] 或任何其他 TypedArray 实例对象专用的内部插槽 22.2.6.1 TypedArray.prototype.BYTES_PER_ELEMENT TypedArray.prototype.BYTES_PER_ELEMENT 的值是表59中为 TypedArray 指定的元素大小值的Number值。 此属性具有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 22.2.6.2 TypedArray.prototype.constructor TypedArray.prototype.constructor 的初始值为相应的 ％TypedArray％ 内部对象。 22.2.7 TypedArray 实例属性 TypedArray实例是整数索引的异类对象。每个TypedArray实例都从相应的TypedArray原型对象继承属性。每个TypedArray实例都有以下内部插槽：[[TypedArrayName]]，[[ViewedArrayBuffer]]，[[ByteLength]]，[[ByteOffset]]和[[ArrayLength]]。 "},"keyed-collections.html":{"url":"keyed-collections.html","title":"23 带键的集合","keywords":"","body":"23 带键的集合 23.1 Map 对象 Map objects are collections of key/value pairs where both the keys and values may be arbitrary ECMAScript language values. A distinct key value may only occur in one key/value pair within the Map's collection. Distinct key values are discriminated using the SameValueZero comparison algorithm. Map object must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structures used in this Map objects specification is only intended to describe the required observable semantics of Map objects. It is not intended to be a viable implementation model. 23.1.1 Map 构造器 The Map constructor: is the intrinsic object %Map%. is the initial value of the Map property of the global object. creates and initializes a new Map object when called as a constructor. is not intended to be called as a function and will throw an exception when called in that manner. is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified Map behaviour must include a super call to the Map constructor to create and initialize the subclass instance with the internal state necessary to support the Map.prototype built-in methods. 23.1.1.1 Map ( [ iterable ] ) When the Map function is called with optional argument iterable, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let map be ? OrdinaryCreateFromConstructor(NewTarget, \"%MapPrototype%\", « [[MapData]] »). Set map.[[MapData]] to a new empty List. If iterable is not present, or is either undefined or null, return map. Let adder be ? Get(map, \"set\"). Return ? AddEntriesFromIterable(map, iterable, adder). NOTE If the parameter iterable is present, it is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key. 23.1.1.2 AddEntriesFromIterable ( target, iterable, adder ) The abstract operation AddEntriesFromIterable accepts a target object, an iterable of entries, and an adder function to be invoked, with target as the receiver. If IsCallable(adder) is false, throw a TypeError exception. Assert: iterable is present, and is neither undefined nor null. Let iteratorRecord be ? GetIterator(iterable). Repeat, Let next be ? IteratorStep(iteratorRecord). If next is false, return target. Let nextItem be ? IteratorValue(next). If Type(nextItem) is not Object, then Let error be ThrowCompletion(a newly created TypeError object). Return ? IteratorClose(iteratorRecord, error). Let k be Get(nextItem, \"0\"). If k is an abrupt completion, return ? IteratorClose(iteratorRecord, k). Let v be Get(nextItem, \"1\"). If v is an abrupt completion, return ? IteratorClose(iteratorRecord, v). Let status be Call(adder, target, « k.[[Value]], v.[[Value]] »). If status is an abrupt completion, return ? IteratorClose(iteratorRecord, status). NOTE The parameter iterable is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key. 23.1.2 Map 构造器属性 The Map constructor: has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%. has the following properties: 23.1.2.1 Map.prototype The initial value of Map.prototype is the intrinsic object %MapPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 23.1.2.2 获取 Map [ @@species ] Map[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value. The value of the name property of this function is \"get [Symbol.species]\". NOTE Methods that create derived collection objects should call @@species to determine the constructor to use to create the derived objects. Subclass constructor may over-ride @@species to change the default constructor assignment. 23.1.3 Map 原型对象属性 The Map prototype object: is the intrinsic object %MapPrototype%. has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%. is an ordinary object. does not have a [[MapData]] internal slot. 23.1.3.1 Map.prototype.clear ( ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[MapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[MapData]]. For each Record { [[Key]], [[Value]] } p that is an element of entries, do a. Set p.[[Key]] to empty. b. Set p.[[Value]] to empty. Return undefined. NOTE The existing [[MapData]] List is preserved because there may be existing Map Iterator objects that are suspended midway through iterating over that List. 23.1.3.2 Map.prototype.constructor The initial value of Map.prototype.constructor is the intrinsic object %Map%. 23.1.3.3 Map.prototype.delete ( key ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[MapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[MapData]]. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then Set p.[[Key]] to empty. Set p.[[Value]] to empty. Return true. Return false. NOTE The value empty is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures. 23.1.3.4 Map.prototype.entries ( ) The following steps are taken: Let M be the this value. Return ? CreateMapIterator(M, \"key+value\"). 23.1.3.5 Map.prototype.forEach ( callbackfn [ , thisArg ] ) When the forEach method is called with one or two arguments, the following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[MapData]] internal slot, throw a TypeError exception. If IsCallable(callbackfn) is false, throw a TypeError exception. If thisArg is present, let T be thisArg; else let T be undefined. Let entries be the List that is M.[[MapData]]. For each Record { [[Key]], [[Value]] } e that is an element of entries, in original key insertion order, do If e.[[Key]] is not empty, then Perform ? Call(callbackfn, T, « e.[[Value]], e.[[Key]], M »). Return undefined. NOTE callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each key/value pair present in the map object, in key insertion order. callbackfn is called only for keys of the map which actually exist; it is not called for keys that have been deleted from the map. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the value of the item, the key of the item, and the Map object being traversed. forEach does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. Each entry of a map's [[MapData]] is only visited once. New keys added after the call to forEach begins are visited. A key will be revisited if it is deleted after it has been visited and then re-added before the forEach call completes. Keys that are deleted after the call to forEach begins and before being visited are not visited unless the key is added again before the forEach call completes. 23.1.3.6 Map.prototype.get ( key ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[MapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[MapData]]. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return p.[[Value]]. Return undefined. 23.1.3.7 Map.prototype.has ( key ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[MapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[MapData]]. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return true. Return false 23.1.3.8 Map.prototype.keys ( ) The following steps are taken: Let M be the this value. Return ? CreateMapIterator(M, \"key\"). 23.1.3.9 Map.prototype.set ( key, value ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[MapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[MapData]]. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then Set p.[[Value]] to value. Return M. If key is -0, set key to +0. Let p be the Record { [[Key]]: key, [[Value]]: value }. Append p as the last element of entries. Return M. 23.1.3.10 获取 Map.prototype.size Map.prototype.size is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[MapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[MapData]]. Let count be 0. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty, increase count by 1. Return count. 23.1.3.11 Map.prototype.values ( ) The following steps are taken: Let M be the this value. Return ? CreateMapIterator(M, \"value\"). 23.1.3.12 Map.prototype [ @@iterator ] ( ) The initial value of the @@iterator property is the same function object as the initial value of the entries property. 23.1.3.13 Map.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value \"Map\". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 23.1.4 Map 实例属性 Map instances are ordinary objects that inherit properties from the Map prototype. Map instances also have a [[MapData]] internal slot. 23.1.5 Map 迭代器对象 A Map Iterator is an object, that represents a specific iteration over some specific Map instance object. There is not a named constructor for Map Iterator objects. Instead, map iterator objects are created by calling certain methods of Map instance objects. 23.1.5.1 CreateMapIterator ( map, kind ) Several methods of Map objects return Iterator objects. The abstract operation CreateMapIterator with arguments map and kind is used to create such iterator objects. It performs the following steps: If Type(map) is not Object, throw a TypeError exception. If map does not have a [[MapData]] internal slot, throw a TypeError exception. Let iterator be ObjectCreate(%MapIteratorPrototype%, « [[Map]], [[MapNextIndex]], [[MapIterationKind]] »). Set iterator.[[Map]] to map. Set iterator.[[MapNextIndex]] to 0. Set iterator.[[MapIterationKind]] to kind. Return iterator. 23.1.5.2 The %MapIteratorPrototype% Object The %MapIteratorPrototype% object: has properties that are inherited by all Map Iterator Objects. is an ordinary object. has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%. has the following properties: 23.1.5.2.1 %MapIteratorPrototype%.next ( ) Let O be the this value. If Type(O) is not Object, throw a TypeError exception. If O does not have all of the internal slots of a Map Iterator Instance (23.1.5.3), throw a TypeError exception. Let m be O.[[Map]]. Let index be O.[[MapNextIndex]]. Let itemKind be O.[[MapIterationKind]]. If m is undefined, return CreateIterResultObject(undefined, true). Assert: m has a [[MapData]] internal slot. Let entries be the List that is m.[[MapData]]. Let numEntries be the number of elements of entries. NOTE: numEntries must be redetermined each time this method is evaluated. Repeat, while index is less than numEntries, Let e be the Record { [[Key]], [[Value]] } that is the value of entries[index]. Increase index by 1. Set O.[[MapNextIndex]] to index. If e.[[Key]] is not empty, then If itemKind is \"key\", let result be e.[[Key]]. Else if itemKind is \"value\", let result be e.[[Value]]. Else, Assert: itemKind is \"key+value\". Let result be CreateArrayFromList(« e.[[Key]], e.[[Value]] »). Return CreateIterResultObject(result, false). Set O.[[Map]] to undefined. Return CreateIterResultObject(undefined, true). 23.1.5.2.2 %MapIteratorPrototype% [ @@toStringTag ] The initial value of the @@toStringTag property is the String value \"Map Iterator\". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 23.1.5.3 Map 迭代器实例属性 Map Iterator instances are ordinary objects that inherit properties from the %MapIteratorPrototype% intrinsic object. Map Iterator instances are initially created with the internal slots described in Table 60. Table 60: Internal Slots of Map Iterator Instances Internal Slot Description [[Map]] The Map object that is being iterated. [[MapNextIndex]] The integer index of the next Map data element to be examined by this iterator. [[MapIterationKind]] A String value that identifies what is to be returned for each element of the iteration. The possible values are: \"key\", \"value\", \"key+value\". 23.2 Set 对象 Set objects are collections of ECMAScript language values. A distinct value may only occur once as an element of a Set's collection. Distinct values are discriminated using the SameValueZero comparison algorithm. Set objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structures used in this Set objects specification is only intended to describe the required observable semantics of Set objects. It is not intended to be a viable implementation model. 23.2.1 Set 构造器 The Set constructor: is the intrinsic object %Set%. is the initial value of the Set property of the global object. creates and initializes a new Set object when called as a constructor. is not intended to be called as a function and will throw an exception when called in that manner. is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified Set behaviour must include a super call to the Set constructor to create and initialize the subclass instance with the internal state necessary to support the Set.prototype built-in methods. 23.2.1.1 Set ( [ iterable ] ) When the Set function is called with optional argument iterable, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let set be ? OrdinaryCreateFromConstructor(NewTarget, \"%SetPrototype%\", « [[SetData]] »). Set set.[[SetData]] to a new empty List. If iterable is not present, set iterable to undefined. If iterable is either undefined or null, return set. Let adder be ? Get(set, \"add\"). If IsCallable(adder) is false, throw a TypeError exception. Let iteratorRecord be ? GetIterator(iterable). Repeat, Let next be ? IteratorStep(iteratorRecord). If next is false, return set. Let nextValue be ? IteratorValue(next). Let status be Call(adder, set, « nextValue »). If status is an abrupt completion, return ? IteratorClose(iteratorRecord, status). 23.2.2 Set 构造器属性 The Set constructor: has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%. has the following properties: 23.2.2.1 Set.prototype The initial value of Set.prototype is the intrinsic %SetPrototype% object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 23.2.2.2 获取 Set [ @@species ] Set[@@species] is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Return the this value. The value of the name property of this function is \"get [Symbol.species]\". NOTE Methods that create derived collection objects should call @@species to determine the constructor to use to create the derived objects. Subclass constructor may over-ride @@species to change the default constructor assignment. 23.2.3 Set 原型对象属性 The Set prototype object: is the intrinsic object %SetPrototype%. has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%. is an ordinary object. does not have a [[SetData]] internal slot. 23.2.3.1 Set.prototype.add ( value ) The following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[SetData]] internal slot, throw a TypeError exception. Let entries be the List that is S.[[SetData]]. For each e that is an element of entries, do If e is not empty and SameValueZero(e, value) is true, then Return S. If value is -0, set value to +0. Append value as the last element of entries. Return S. 23.2.3.2 Set.prototype.clear ( ) The following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[SetData]] internal slot, throw a TypeError exception. Let entries be the List that is S.[[SetData]]. For each e that is an element of entries, do Replace the element of entries whose value is e with an element whose value is empty. Return undefined. NOTE The existing [[SetData]] List is preserved because there may be existing Set Iterator objects that are suspended midway through iterating over that List. 23.2.3.3 Set.prototype.constructor The initial value of Set.prototype.constructor is the intrinsic object %Set%. 23.2.3.4 Set.prototype.delete ( value ) The following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[SetData]] internal slot, throw a TypeError exception. Let entries be the List that is S.[[SetData]]. For each e that is an element of entries, do If e is not empty and SameValueZero(e, value) is true, then Replace the element of entries whose value is e with an element whose value is empty. Return true. Return false. NOTE The value empty is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures. 23.2.3.5 Set.prototype.entries ( ) The following steps are taken: Let S be the this value. Return ? CreateSetIterator(S, \"key+value\"). NOTE For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value. 23.2.3.6 Set.prototype.forEach ( callbackfn [ , thisArg ] ) When the forEach method is called with one or two arguments, the following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[SetData]] internal slot, throw a TypeError exception. If IsCallable(callbackfn) is false, throw a TypeError exception. If thisArg is present, let T be thisArg; else let T be undefined. Let entries be the List that is S.[[SetData]]. For each e that is an element of entries, in original insertion order, do If e is not empty, then Perform ? Call(callbackfn, T, « e, e, S »). Return undefined. NOTE callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each value present in the set object, in value insertion order. callbackfn is called only for values of the Set which actually exist; it is not called for keys that have been deleted from the set. If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not provided, undefined is used instead. callbackfn is called with three arguments: the first two arguments are a value contained in the Set. The same value is passed for both arguments. The Set object being traversed is passed as the third argument. The callbackfn is called with three arguments to be consistent with the call back functions used by forEach methods for Map and Array. For Sets, each item value is considered to be both the key and the value. forEach does not directly mutate the object on which it is called but the object may be mutated by the calls to callbackfn. Each value is normally visited only once. However, a value will be revisited if it is deleted after it has been visited and then re-added before the forEach call completes. Values that are deleted after the call to forEach begins and before being visited are not visited unless the value is added again before the forEach call completes. New values added after the call to forEach begins are visited. 23.2.3.7 Set.prototype.has ( value ) The following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[SetData]] internal slot, throw a TypeError exception. Let entries be the List that is S.[[SetData]]. For each e that is an element of entries, do If e is not empty and SameValueZero(e, value) is true, return true. Return false. 23.2.3.8 Set.prototype.keys ( ) The initial value of the keys property is the same function object as the initial value of the values property. NOTE For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value. 23.2.3.9 获取 Set.prototype.size Set.prototype.size is an accessor property whose set accessor function is undefined. Its get accessor function performs the following steps: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[SetData]] internal slot, throw a TypeError exception. Let entries be the List that is S.[[SetData]]. Let count be 0. For each e that is an element of entries, do If e is not empty, increase count by 1. Return count. 23.2.3.10 Set.prototype.values ( ) The following steps are taken: Let S be the this value. Return ? CreateSetIterator(S, \"value\"). 23.2.3.11 Set.prototype [ @@iterator ] ( ) The initial value of the @@iterator property is the same function object as the initial value of the values property. 23.2.3.12 Set.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value \"Set\". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 23.2.4 Set 实例属性 Set instances are ordinary objects that inherit properties from the Set prototype. Set instances also have a [[SetData]] internal slot. 23.2.5 Set 实例对象 A Set Iterator is an ordinary object, with the structure defined below, that represents a specific iteration over some specific Set instance object. There is not a named constructor for Set Iterator objects. Instead, set iterator objects are created by calling certain methods of Set instance objects. 23.2.5.1 CreateSetIterator ( set, kind ) Several methods of Set objects return Iterator objects. The abstract operation CreateSetIterator with arguments set and kind is used to create such iterator objects. It performs the following steps: If Type(set) is not Object, throw a TypeError exception. If set does not have a [[SetData]] internal slot, throw a TypeError exception. Let iterator be ObjectCreate(%SetIteratorPrototype%, « [[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]] »). Set iterator.[[IteratedSet]] to set. Set iterator.[[SetNextIndex]] to 0. Set iterator.[[SetIterationKind]] to kind. Return iterator. 23.2.5.2 %SetIteratorPrototype% 对象 The %SetIteratorPrototype% object: has properties that are inherited by all Set Iterator Objects. is an ordinary object. has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%. has the following properties: 23.2.5.2.1 %SetIteratorPrototype%.next ( ) Let O be the this value. If Type(O) is not Object, throw a TypeError exception. If O does not have all of the internal slots of a Set Iterator Instance (23.2.5.3), throw a TypeError exception. Let s be O.[[IteratedSet]]. Let index be O.[[SetNextIndex]]. Let itemKind be O.[[SetIterationKind]]. If s is undefined, return CreateIterResultObject(undefined, true). Assert: s has a [[SetData]] internal slot. Let entries be the List that is s.[[SetData]]. Let numEntries be the number of elements of entries. NOTE: numEntries must be redetermined each time this method is evaluated. Repeat, while index is less than numEntries, Let e be entries[index]. Increase index by 1. Set O.[[SetNextIndex]] to index. If e is not empty, then If itemKind is \"key+value\", then Return CreateIterResultObject(CreateArrayFromList(« e, e »), false). Return CreateIterResultObject(e, false). Set O.[[IteratedSet]] to undefined. Return CreateIterResultObject(undefined, true). 23.2.5.2.2 %SetIteratorPrototype% [ @@toStringTag ] The initial value of the @@toStringTag property is the String value \"Set Iterator\". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 23.2.5.3 Set 迭代器对象属性 Set Iterator instances are ordinary objects that inherit properties from the %SetIteratorPrototype% intrinsic object. Set Iterator instances are initially created with the internal slots specified in Table 61. Table 61: Internal Slots of Set Iterator Instances Internal Slot Description [[IteratedSet]] The Set object that is being iterated. [[SetNextIndex]] The integer index of the next Set data element to be examined by this iterator [[SetIterationKind]] A String value that identifies what is to be returned for each element of the iteration. The possible values are: \"key\", \"value\", \"key+value\". \"key\" and \"value\" have the same meaning. 23.3 WeakMap 对象 WeakMap objects are collections of key/value pairs where the keys are objects and values may be arbitrary ECMAScript language values. A WeakMap may be queried to see if it contains a key/value pair with a specific key, but no mechanism is provided for enumerating the objects it holds as keys. If an object that is being used as the key of a WeakMap key/value pair is only reachable by following a chain of references that start within that WeakMap, then that key/value pair is inaccessible and is automatically removed from the WeakMap. WeakMap implementations must detect and remove such key/value pairs and any associated resources. An implementation may impose an arbitrarily determined latency between the time a key/value pair of a WeakMap becomes inaccessible and the time when the key/value pair is removed from the WeakMap. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to observe a key of a WeakMap that does not require the observer to present the observed key. WeakMap objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of key/value pairs in the collection. The data structure used in this WeakMap objects specification are only intended to describe the required observable semantics of WeakMap objects. It is not intended to be a viable implementation model. NOTE WeakMap and WeakSets are intended to provide mechanisms for dynamically associating state with an object in a manner that does not “leak” memory resources if, in the absence of the WeakMap or WeakSet, the object otherwise became inaccessible and subject to resource reclamation by the implementation's garbage collection mechanisms. This characteristic can be achieved by using an inverted per-object mapping of weak map instances to keys. Alternatively each weak map may internally store its key to value mappings but this approach requires coordination between the WeakMap or WeakSet implementation and the garbage collector. The following references describe mechanism that may be useful to implementations of WeakMap and WeakSets: Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97), A. Michael Berman (Ed.). ACM, New York, NY, USA, 176-183, http://doi.acm.org/10.1145/263698.263733. Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008, http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak 23.3.1 WeakMap 构造器 The WeakMap constructor: is the intrinsic object %WeakMap%. is the initial value of the WeakMap property of the global object. creates and initializes a new WeakMap object when called as a constructor. is not intended to be called as a function and will throw an exception when called in that manner. is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified WeakMap behaviour must include a super call to the WeakMap constructor to create and initialize the subclass instance with the internal state necessary to support the WeakMap.prototype built-in methods. 23.3.1.1 WeakMap ( [ iterable ] ) When the WeakMap function is called with optional argument iterable, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let map be ? OrdinaryCreateFromConstructor(NewTarget, \"%WeakMapPrototype%\", « [[WeakMapData]] »). Set map.[[WeakMapData]] to a new empty List. If iterable is not present, or is either undefined or null, return map. Let adder be ? Get(map, \"set\"). Return ? AddEntriesFromIterable(map, iterable, adder). NOTE If the parameter iterable is present, it is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a WeakMap key and whose second element is the value to associate with that key. 23.3.2 WeakMap 构造器属性 The WeakMap constructor: has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%. has the following properties: 23.3.2.1 WeakMap.prototype The initial value of WeakMap.prototype is the intrinsic object %WeakMapPrototype%. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 23.3.3 WeakMap 原型对象属性 The WeakMap prototype object: is the intrinsic object %WeakMapPrototype%. has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%. is an ordinary object. does not have a [[WeakMapData]] internal slot. 23.3.3.1 WeakMap.prototype.constructor The initial value of WeakMap.prototype.constructor is the intrinsic object %WeakMap%. 23.3.3.2 WeakMap.prototype.delete ( key ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[WeakMapData]]. If Type(key) is not Object, return false. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then Set p.[[Key]] to empty. Set p.[[Value]] to empty. Return true. Return false. NOTE The value empty is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures. 23.3.3.3 WeakMap.prototype.get ( key ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[WeakMapData]]. If Type(key) is not Object, return undefined. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]]. Return undefined. 23.3.3.4 WeakMap.prototype.has ( key ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[WeakMapData]]. If Type(key) is not Object, return false. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return true. Return false. 23.3.3.5 WeakMap.prototype.set ( key, value ) The following steps are taken: Let M be the this value. If Type(M) is not Object, throw a TypeError exception. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception. Let entries be the List that is M.[[WeakMapData]]. If Type(key) is not Object, throw a TypeError exception. For each Record { [[Key]], [[Value]] } p that is an element of entries, do If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then Set p.[[Value]] to value. Return M. Let p be the Record { [[Key]]: key, [[Value]]: value }. Append p as the last element of entries. Return M. 23.3.3.6 WeakMap.prototype [ @@toStringTag ] The initial value of the @@toStringTag property is the String value \"WeakMap\". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 23.3.4 WeakMap 实例属性 WeakMap instances are ordinary objects that inherit properties from the WeakMap prototype. WeakMap instances also have a [[WeakMapData]] internal slot. 23.4 WeakSet 对象 WeakSet objects are collections of objects. A distinct object may only occur once as an element of a WeakSet's collection. A WeakSet may be queried to see if it contains a specific object, but no mechanism is provided for enumerating the objects it holds. If an object that is contained by a WeakSet is only reachable by following a chain of references that start within that WeakSet, then that object is inaccessible and is automatically removed from the WeakSet. WeakSet implementations must detect and remove such objects and any associated resources. An implementation may impose an arbitrarily determined latency between the time an object contained in a WeakSet becomes inaccessible and the time when the object is removed from the WeakSet. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to determine if a WeakSet contains a particular object that does not require the observer to present the observed object. WeakSet objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this WeakSet objects specification is only intended to describe the required observable semantics of WeakSet objects. It is not intended to be a viable implementation model. NOTE See the NOTE in 23.3. 23.4.1 WeakSet 构造器 The WeakSet constructor: is the intrinsic object %WeakSet%. is the initial value of the WeakSet property of the global object. creates and initializes a new WeakSet object when called as a constructor. is not intended to be called as a function and will throw an exception when called in that manner. is designed to be subclassable. It may be used as the value in an extends clause of a class definition. Subclass constructors that intend to inherit the specified WeakSet behaviour must include a super call to the WeakSet constructor to create and initialize the subclass instance with the internal state necessary to support the WeakSet.prototype built-in methods. 23.4.1.1 WeakSet ( [ iterable ] ) When the WeakSet function is called with optional argument iterable, the following steps are taken: If NewTarget is undefined, throw a TypeError exception. Let set be ? OrdinaryCreateFromConstructor(NewTarget, \"%WeakSetPrototype%\", « [[WeakSetData]] »). Set set.[[WeakSetData]] to a new empty List. If iterable is not present, set iterable to undefined. If iterable is either undefined or null, return set. Let adder be ? Get(set, \"add\"). If IsCallable(adder) is false, throw a TypeError exception. Let iteratorRecord be ? GetIterator(iterable). Repeat, Let next be ? IteratorStep(iteratorRecord). If next is false, return set. Let nextValue be ? IteratorValue(next). Let status be Call(adder, set, « nextValue »). If status is an abrupt completion, return ? IteratorClose(iteratorRecord, status). 23.4.2 WeakSet 构造器属性 The WeakSet constructor: has a [[Prototype]] internal slot whose value is the intrinsic object %FunctionPrototype%. has the following properties: 23.4.2.1 WeakSet.prototype The initial value of WeakSet.prototype is the intrinsic %WeakSetPrototype% object. This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 23.4.3 WeakSet 原型对象属性 The WeakSet prototype object: is the intrinsic object %WeakSetPrototype%. has a [[Prototype]] internal slot whose value is the intrinsic object %ObjectPrototype%. is an ordinary object. does not have a [[WeakSetData]] internal slot. 23.4.3.1 WeakSet.prototype.add ( value ) The following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception. If Type(value) is not Object, throw a TypeError exception. Let entries be the List that is S.[[WeakSetData]]. For each e that is an element of entries, do If e is not empty and SameValue(e, value) is true, then Return S. Append value as the last element of entries. Return S. 23.4.3.2 WeakSet.prototype.constructor The initial value of WeakSet.prototype.constructor is the %WeakSet% intrinsic object. 23.4.3.3 WeakSet.prototype.delete ( value ) The following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception. If Type(value) is not Object, return false. Let entries be the List that is S.[[WeakSetData]]. For each e that is an element of entries, do If e is not empty and SameValue(e, value) is true, then Replace the element of entries whose value is e with an element whose value is empty. Return true. Return false. NOTE The value empty is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures. 23.4.3.4 WeakSet.prototype.has ( value ) The following steps are taken: Let S be the this value. If Type(S) is not Object, throw a TypeError exception. If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception. Let entries be the List that is S.[[WeakSetData]]. If Type(value) is not Object, return false. For each e that is an element of entries, do If e is not empty and SameValue(e, value) is true, return true. Return false. 23.4.3.5 WeakSet.prototype [ @@toStringTag] The initial value of the @@toStringTag property is the String value \"WeakSet\". This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }. 23.4.4 WeakSet 实例属性 WeakSet instances are ordinary objects that inherit properties from the WeakSet prototype. WeakSet instances also have a [[WeakSetData]] internal slot. "}}